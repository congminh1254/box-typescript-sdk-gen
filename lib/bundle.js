(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["box-typescript-sdk-gen"] = {}));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */


    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
        function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
        function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }

    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    class BoxSdkError extends Error {
        constructor(fields) {
            super(fields.message);
            this.name = 'BoxSDKError';
            Object.assign(this, fields);
            this.message = JSON.stringify(fields, undefined, 2);
        }
    }
    class BoxApiError extends BoxSdkError {
        constructor(fields) {
            super(fields);
        }
    }

    function jsonToSerializedData(text) {
        return JSON.parse(text);
    }
    function sdToJson(data) {
        return JSON.stringify(data);
    }
    function sdToUrlParams(data) {
        if (!sdIsMap(data) && !sdIsString(data)) {
            throw new Error('Expecting an object or string as an argument for sdToUrlParams');
        }
        const dataAsMap = sdIsString(data)
            ? JSON.parse(data)
            : data;
        return new URLSearchParams(Object.fromEntries(Object.entries(dataAsMap).filter(([key, value]) => value != null))).toString();
    }
    function sdIsBoolean(data) {
        return typeof data == 'boolean';
    }
    function sdIsNumber(data) {
        return typeof data == 'number';
    }
    function sdIsString(data) {
        return typeof data == 'string';
    }
    function sdIsList(data) {
        return Array.isArray(data);
    }
    function sdIsMap(data) {
        return typeof data === 'object' && data != null && !Array.isArray(data);
    }

    class BaseUrls {
        constructor(fields) {
            this.baseUrl = 'https://api.box.com';
            this.uploadUrl = 'https://upload.box.com/api';
            this.oauth2Url = 'https://account.box.com/api/oauth2';
            if (fields.baseUrl) {
                this.baseUrl = fields.baseUrl;
            }
            if (fields.uploadUrl) {
                this.uploadUrl = fields.uploadUrl;
            }
            if (fields.oauth2Url) {
                this.oauth2Url = fields.oauth2Url;
            }
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var buffer = {};

    var base64Js = {};

    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;

    function getLens (b64) {
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=');
      if (validLen === -1) validLen = len;

      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4);

      return [validLen, placeHoldersLen]
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function toByteArray (b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

      var curByte = 0;

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen;

      var i;
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = (tmp >> 16) & 0xFF;
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        );
      }

      return parts.join('')
    }

    var ieee754 = {};

    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

    ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    };

    ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    (function (exports) {

    	const base64 = base64Js;
    	const ieee754$1 = ieee754;
    	const customInspectSymbol =
    	  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    	    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    	    : null;

    	exports.Buffer = Buffer;
    	exports.SlowBuffer = SlowBuffer;
    	exports.INSPECT_MAX_BYTES = 50;

    	const K_MAX_LENGTH = 0x7fffffff;
    	exports.kMaxLength = K_MAX_LENGTH;

    	/**
    	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
    	 *   === true    Use Uint8Array implementation (fastest)
    	 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
    	 *               implementation (most compatible, even IE6)
    	 *
    	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
    	 * Opera 11.6+, iOS 4.2+.
    	 *
    	 * We report that the browser does not support typed arrays if the are not subclassable
    	 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
    	 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
    	 * for __proto__ and has a buggy typed array implementation.
    	 */
    	Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    	if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    	    typeof console.error === 'function') {
    	  console.error(
    	    'This browser lacks typed array (Uint8Array) support which is required by ' +
    	    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    	  );
    	}

    	function typedArraySupport () {
    	  // Can typed array instances can be augmented?
    	  try {
    	    const arr = new Uint8Array(1);
    	    const proto = { foo: function () { return 42 } };
    	    Object.setPrototypeOf(proto, Uint8Array.prototype);
    	    Object.setPrototypeOf(arr, proto);
    	    return arr.foo() === 42
    	  } catch (e) {
    	    return false
    	  }
    	}

    	Object.defineProperty(Buffer.prototype, 'parent', {
    	  enumerable: true,
    	  get: function () {
    	    if (!Buffer.isBuffer(this)) return undefined
    	    return this.buffer
    	  }
    	});

    	Object.defineProperty(Buffer.prototype, 'offset', {
    	  enumerable: true,
    	  get: function () {
    	    if (!Buffer.isBuffer(this)) return undefined
    	    return this.byteOffset
    	  }
    	});

    	function createBuffer (length) {
    	  if (length > K_MAX_LENGTH) {
    	    throw new RangeError('The value "' + length + '" is invalid for option "size"')
    	  }
    	  // Return an augmented `Uint8Array` instance
    	  const buf = new Uint8Array(length);
    	  Object.setPrototypeOf(buf, Buffer.prototype);
    	  return buf
    	}

    	/**
    	 * The Buffer constructor returns instances of `Uint8Array` that have their
    	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
    	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
    	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
    	 * returns a single octet.
    	 *
    	 * The `Uint8Array` prototype remains unmodified.
    	 */

    	function Buffer (arg, encodingOrOffset, length) {
    	  // Common case.
    	  if (typeof arg === 'number') {
    	    if (typeof encodingOrOffset === 'string') {
    	      throw new TypeError(
    	        'The "string" argument must be of type string. Received type number'
    	      )
    	    }
    	    return allocUnsafe(arg)
    	  }
    	  return from(arg, encodingOrOffset, length)
    	}

    	Buffer.poolSize = 8192; // not used by this implementation

    	function from (value, encodingOrOffset, length) {
    	  if (typeof value === 'string') {
    	    return fromString(value, encodingOrOffset)
    	  }

    	  if (ArrayBuffer.isView(value)) {
    	    return fromArrayView(value)
    	  }

    	  if (value == null) {
    	    throw new TypeError(
    	      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    	      'or Array-like Object. Received type ' + (typeof value)
    	    )
    	  }

    	  if (isInstance(value, ArrayBuffer) ||
    	      (value && isInstance(value.buffer, ArrayBuffer))) {
    	    return fromArrayBuffer(value, encodingOrOffset, length)
    	  }

    	  if (typeof SharedArrayBuffer !== 'undefined' &&
    	      (isInstance(value, SharedArrayBuffer) ||
    	      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    	    return fromArrayBuffer(value, encodingOrOffset, length)
    	  }

    	  if (typeof value === 'number') {
    	    throw new TypeError(
    	      'The "value" argument must not be of type number. Received type number'
    	    )
    	  }

    	  const valueOf = value.valueOf && value.valueOf();
    	  if (valueOf != null && valueOf !== value) {
    	    return Buffer.from(valueOf, encodingOrOffset, length)
    	  }

    	  const b = fromObject(value);
    	  if (b) return b

    	  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
    	      typeof value[Symbol.toPrimitive] === 'function') {
    	    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
    	  }

    	  throw new TypeError(
    	    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    	    'or Array-like Object. Received type ' + (typeof value)
    	  )
    	}

    	/**
    	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
    	 * if value is a number.
    	 * Buffer.from(str[, encoding])
    	 * Buffer.from(array)
    	 * Buffer.from(buffer)
    	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
    	 **/
    	Buffer.from = function (value, encodingOrOffset, length) {
    	  return from(value, encodingOrOffset, length)
    	};

    	// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    	// https://github.com/feross/buffer/pull/148
    	Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    	Object.setPrototypeOf(Buffer, Uint8Array);

    	function assertSize (size) {
    	  if (typeof size !== 'number') {
    	    throw new TypeError('"size" argument must be of type number')
    	  } else if (size < 0) {
    	    throw new RangeError('The value "' + size + '" is invalid for option "size"')
    	  }
    	}

    	function alloc (size, fill, encoding) {
    	  assertSize(size);
    	  if (size <= 0) {
    	    return createBuffer(size)
    	  }
    	  if (fill !== undefined) {
    	    // Only pay attention to encoding if it's a string. This
    	    // prevents accidentally sending in a number that would
    	    // be interpreted as a start offset.
    	    return typeof encoding === 'string'
    	      ? createBuffer(size).fill(fill, encoding)
    	      : createBuffer(size).fill(fill)
    	  }
    	  return createBuffer(size)
    	}

    	/**
    	 * Creates a new filled Buffer instance.
    	 * alloc(size[, fill[, encoding]])
    	 **/
    	Buffer.alloc = function (size, fill, encoding) {
    	  return alloc(size, fill, encoding)
    	};

    	function allocUnsafe (size) {
    	  assertSize(size);
    	  return createBuffer(size < 0 ? 0 : checked(size) | 0)
    	}

    	/**
    	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
    	 * */
    	Buffer.allocUnsafe = function (size) {
    	  return allocUnsafe(size)
    	};
    	/**
    	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
    	 */
    	Buffer.allocUnsafeSlow = function (size) {
    	  return allocUnsafe(size)
    	};

    	function fromString (string, encoding) {
    	  if (typeof encoding !== 'string' || encoding === '') {
    	    encoding = 'utf8';
    	  }

    	  if (!Buffer.isEncoding(encoding)) {
    	    throw new TypeError('Unknown encoding: ' + encoding)
    	  }

    	  const length = byteLength(string, encoding) | 0;
    	  let buf = createBuffer(length);

    	  const actual = buf.write(string, encoding);

    	  if (actual !== length) {
    	    // Writing a hex string, for example, that contains invalid characters will
    	    // cause everything after the first invalid character to be ignored. (e.g.
    	    // 'abxxcd' will be treated as 'ab')
    	    buf = buf.slice(0, actual);
    	  }

    	  return buf
    	}

    	function fromArrayLike (array) {
    	  const length = array.length < 0 ? 0 : checked(array.length) | 0;
    	  const buf = createBuffer(length);
    	  for (let i = 0; i < length; i += 1) {
    	    buf[i] = array[i] & 255;
    	  }
    	  return buf
    	}

    	function fromArrayView (arrayView) {
    	  if (isInstance(arrayView, Uint8Array)) {
    	    const copy = new Uint8Array(arrayView);
    	    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
    	  }
    	  return fromArrayLike(arrayView)
    	}

    	function fromArrayBuffer (array, byteOffset, length) {
    	  if (byteOffset < 0 || array.byteLength < byteOffset) {
    	    throw new RangeError('"offset" is outside of buffer bounds')
    	  }

    	  if (array.byteLength < byteOffset + (length || 0)) {
    	    throw new RangeError('"length" is outside of buffer bounds')
    	  }

    	  let buf;
    	  if (byteOffset === undefined && length === undefined) {
    	    buf = new Uint8Array(array);
    	  } else if (length === undefined) {
    	    buf = new Uint8Array(array, byteOffset);
    	  } else {
    	    buf = new Uint8Array(array, byteOffset, length);
    	  }

    	  // Return an augmented `Uint8Array` instance
    	  Object.setPrototypeOf(buf, Buffer.prototype);

    	  return buf
    	}

    	function fromObject (obj) {
    	  if (Buffer.isBuffer(obj)) {
    	    const len = checked(obj.length) | 0;
    	    const buf = createBuffer(len);

    	    if (buf.length === 0) {
    	      return buf
    	    }

    	    obj.copy(buf, 0, 0, len);
    	    return buf
    	  }

    	  if (obj.length !== undefined) {
    	    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
    	      return createBuffer(0)
    	    }
    	    return fromArrayLike(obj)
    	  }

    	  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    	    return fromArrayLike(obj.data)
    	  }
    	}

    	function checked (length) {
    	  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    	  // length is NaN (which is otherwise coerced to zero.)
    	  if (length >= K_MAX_LENGTH) {
    	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
    	                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    	  }
    	  return length | 0
    	}

    	function SlowBuffer (length) {
    	  if (+length != length) { // eslint-disable-line eqeqeq
    	    length = 0;
    	  }
    	  return Buffer.alloc(+length)
    	}

    	Buffer.isBuffer = function isBuffer (b) {
    	  return b != null && b._isBuffer === true &&
    	    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    	};

    	Buffer.compare = function compare (a, b) {
    	  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    	  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    	    throw new TypeError(
    	      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    	    )
    	  }

    	  if (a === b) return 0

    	  let x = a.length;
    	  let y = b.length;

    	  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    	    if (a[i] !== b[i]) {
    	      x = a[i];
    	      y = b[i];
    	      break
    	    }
    	  }

    	  if (x < y) return -1
    	  if (y < x) return 1
    	  return 0
    	};

    	Buffer.isEncoding = function isEncoding (encoding) {
    	  switch (String(encoding).toLowerCase()) {
    	    case 'hex':
    	    case 'utf8':
    	    case 'utf-8':
    	    case 'ascii':
    	    case 'latin1':
    	    case 'binary':
    	    case 'base64':
    	    case 'ucs2':
    	    case 'ucs-2':
    	    case 'utf16le':
    	    case 'utf-16le':
    	      return true
    	    default:
    	      return false
    	  }
    	};

    	Buffer.concat = function concat (list, length) {
    	  if (!Array.isArray(list)) {
    	    throw new TypeError('"list" argument must be an Array of Buffers')
    	  }

    	  if (list.length === 0) {
    	    return Buffer.alloc(0)
    	  }

    	  let i;
    	  if (length === undefined) {
    	    length = 0;
    	    for (i = 0; i < list.length; ++i) {
    	      length += list[i].length;
    	    }
    	  }

    	  const buffer = Buffer.allocUnsafe(length);
    	  let pos = 0;
    	  for (i = 0; i < list.length; ++i) {
    	    let buf = list[i];
    	    if (isInstance(buf, Uint8Array)) {
    	      if (pos + buf.length > buffer.length) {
    	        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    	        buf.copy(buffer, pos);
    	      } else {
    	        Uint8Array.prototype.set.call(
    	          buffer,
    	          buf,
    	          pos
    	        );
    	      }
    	    } else if (!Buffer.isBuffer(buf)) {
    	      throw new TypeError('"list" argument must be an Array of Buffers')
    	    } else {
    	      buf.copy(buffer, pos);
    	    }
    	    pos += buf.length;
    	  }
    	  return buffer
    	};

    	function byteLength (string, encoding) {
    	  if (Buffer.isBuffer(string)) {
    	    return string.length
    	  }
    	  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    	    return string.byteLength
    	  }
    	  if (typeof string !== 'string') {
    	    throw new TypeError(
    	      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
    	      'Received type ' + typeof string
    	    )
    	  }

    	  const len = string.length;
    	  const mustMatch = (arguments.length > 2 && arguments[2] === true);
    	  if (!mustMatch && len === 0) return 0

    	  // Use a for loop to avoid recursion
    	  let loweredCase = false;
    	  for (;;) {
    	    switch (encoding) {
    	      case 'ascii':
    	      case 'latin1':
    	      case 'binary':
    	        return len
    	      case 'utf8':
    	      case 'utf-8':
    	        return utf8ToBytes(string).length
    	      case 'ucs2':
    	      case 'ucs-2':
    	      case 'utf16le':
    	      case 'utf-16le':
    	        return len * 2
    	      case 'hex':
    	        return len >>> 1
    	      case 'base64':
    	        return base64ToBytes(string).length
    	      default:
    	        if (loweredCase) {
    	          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
    	        }
    	        encoding = ('' + encoding).toLowerCase();
    	        loweredCase = true;
    	    }
    	  }
    	}
    	Buffer.byteLength = byteLength;

    	function slowToString (encoding, start, end) {
    	  let loweredCase = false;

    	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    	  // property of a typed array.

    	  // This behaves neither like String nor Uint8Array in that we set start/end
    	  // to their upper/lower bounds if the value passed is out of range.
    	  // undefined is handled specially as per ECMA-262 6th Edition,
    	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    	  if (start === undefined || start < 0) {
    	    start = 0;
    	  }
    	  // Return early if start > this.length. Done here to prevent potential uint32
    	  // coercion fail below.
    	  if (start > this.length) {
    	    return ''
    	  }

    	  if (end === undefined || end > this.length) {
    	    end = this.length;
    	  }

    	  if (end <= 0) {
    	    return ''
    	  }

    	  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    	  end >>>= 0;
    	  start >>>= 0;

    	  if (end <= start) {
    	    return ''
    	  }

    	  if (!encoding) encoding = 'utf8';

    	  while (true) {
    	    switch (encoding) {
    	      case 'hex':
    	        return hexSlice(this, start, end)

    	      case 'utf8':
    	      case 'utf-8':
    	        return utf8Slice(this, start, end)

    	      case 'ascii':
    	        return asciiSlice(this, start, end)

    	      case 'latin1':
    	      case 'binary':
    	        return latin1Slice(this, start, end)

    	      case 'base64':
    	        return base64Slice(this, start, end)

    	      case 'ucs2':
    	      case 'ucs-2':
    	      case 'utf16le':
    	      case 'utf-16le':
    	        return utf16leSlice(this, start, end)

    	      default:
    	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
    	        encoding = (encoding + '').toLowerCase();
    	        loweredCase = true;
    	    }
    	  }
    	}

    	// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    	// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    	// reliably in a browserify context because there could be multiple different
    	// copies of the 'buffer' package in use. This method works even for Buffer
    	// instances that were created from another copy of the `buffer` package.
    	// See: https://github.com/feross/buffer/issues/154
    	Buffer.prototype._isBuffer = true;

    	function swap (b, n, m) {
    	  const i = b[n];
    	  b[n] = b[m];
    	  b[m] = i;
    	}

    	Buffer.prototype.swap16 = function swap16 () {
    	  const len = this.length;
    	  if (len % 2 !== 0) {
    	    throw new RangeError('Buffer size must be a multiple of 16-bits')
    	  }
    	  for (let i = 0; i < len; i += 2) {
    	    swap(this, i, i + 1);
    	  }
    	  return this
    	};

    	Buffer.prototype.swap32 = function swap32 () {
    	  const len = this.length;
    	  if (len % 4 !== 0) {
    	    throw new RangeError('Buffer size must be a multiple of 32-bits')
    	  }
    	  for (let i = 0; i < len; i += 4) {
    	    swap(this, i, i + 3);
    	    swap(this, i + 1, i + 2);
    	  }
    	  return this
    	};

    	Buffer.prototype.swap64 = function swap64 () {
    	  const len = this.length;
    	  if (len % 8 !== 0) {
    	    throw new RangeError('Buffer size must be a multiple of 64-bits')
    	  }
    	  for (let i = 0; i < len; i += 8) {
    	    swap(this, i, i + 7);
    	    swap(this, i + 1, i + 6);
    	    swap(this, i + 2, i + 5);
    	    swap(this, i + 3, i + 4);
    	  }
    	  return this
    	};

    	Buffer.prototype.toString = function toString () {
    	  const length = this.length;
    	  if (length === 0) return ''
    	  if (arguments.length === 0) return utf8Slice(this, 0, length)
    	  return slowToString.apply(this, arguments)
    	};

    	Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    	Buffer.prototype.equals = function equals (b) {
    	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    	  if (this === b) return true
    	  return Buffer.compare(this, b) === 0
    	};

    	Buffer.prototype.inspect = function inspect () {
    	  let str = '';
    	  const max = exports.INSPECT_MAX_BYTES;
    	  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    	  if (this.length > max) str += ' ... ';
    	  return '<Buffer ' + str + '>'
    	};
    	if (customInspectSymbol) {
    	  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    	}

    	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    	  if (isInstance(target, Uint8Array)) {
    	    target = Buffer.from(target, target.offset, target.byteLength);
    	  }
    	  if (!Buffer.isBuffer(target)) {
    	    throw new TypeError(
    	      'The "target" argument must be one of type Buffer or Uint8Array. ' +
    	      'Received type ' + (typeof target)
    	    )
    	  }

    	  if (start === undefined) {
    	    start = 0;
    	  }
    	  if (end === undefined) {
    	    end = target ? target.length : 0;
    	  }
    	  if (thisStart === undefined) {
    	    thisStart = 0;
    	  }
    	  if (thisEnd === undefined) {
    	    thisEnd = this.length;
    	  }

    	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    	    throw new RangeError('out of range index')
    	  }

    	  if (thisStart >= thisEnd && start >= end) {
    	    return 0
    	  }
    	  if (thisStart >= thisEnd) {
    	    return -1
    	  }
    	  if (start >= end) {
    	    return 1
    	  }

    	  start >>>= 0;
    	  end >>>= 0;
    	  thisStart >>>= 0;
    	  thisEnd >>>= 0;

    	  if (this === target) return 0

    	  let x = thisEnd - thisStart;
    	  let y = end - start;
    	  const len = Math.min(x, y);

    	  const thisCopy = this.slice(thisStart, thisEnd);
    	  const targetCopy = target.slice(start, end);

    	  for (let i = 0; i < len; ++i) {
    	    if (thisCopy[i] !== targetCopy[i]) {
    	      x = thisCopy[i];
    	      y = targetCopy[i];
    	      break
    	    }
    	  }

    	  if (x < y) return -1
    	  if (y < x) return 1
    	  return 0
    	};

    	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    	//
    	// Arguments:
    	// - buffer - a Buffer to search
    	// - val - a string, Buffer, or number
    	// - byteOffset - an index into `buffer`; will be clamped to an int32
    	// - encoding - an optional encoding, relevant is val is a string
    	// - dir - true for indexOf, false for lastIndexOf
    	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    	  // Empty buffer means no match
    	  if (buffer.length === 0) return -1

    	  // Normalize byteOffset
    	  if (typeof byteOffset === 'string') {
    	    encoding = byteOffset;
    	    byteOffset = 0;
    	  } else if (byteOffset > 0x7fffffff) {
    	    byteOffset = 0x7fffffff;
    	  } else if (byteOffset < -0x80000000) {
    	    byteOffset = -0x80000000;
    	  }
    	  byteOffset = +byteOffset; // Coerce to Number.
    	  if (numberIsNaN(byteOffset)) {
    	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    	    byteOffset = dir ? 0 : (buffer.length - 1);
    	  }

    	  // Normalize byteOffset: negative offsets start from the end of the buffer
    	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    	  if (byteOffset >= buffer.length) {
    	    if (dir) return -1
    	    else byteOffset = buffer.length - 1;
    	  } else if (byteOffset < 0) {
    	    if (dir) byteOffset = 0;
    	    else return -1
    	  }

    	  // Normalize val
    	  if (typeof val === 'string') {
    	    val = Buffer.from(val, encoding);
    	  }

    	  // Finally, search either indexOf (if dir is true) or lastIndexOf
    	  if (Buffer.isBuffer(val)) {
    	    // Special case: looking for empty string/buffer always fails
    	    if (val.length === 0) {
    	      return -1
    	    }
    	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    	  } else if (typeof val === 'number') {
    	    val = val & 0xFF; // Search for a byte value [0-255]
    	    if (typeof Uint8Array.prototype.indexOf === 'function') {
    	      if (dir) {
    	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
    	      } else {
    	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
    	      }
    	    }
    	    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
    	  }

    	  throw new TypeError('val must be string, number or Buffer')
    	}

    	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    	  let indexSize = 1;
    	  let arrLength = arr.length;
    	  let valLength = val.length;

    	  if (encoding !== undefined) {
    	    encoding = String(encoding).toLowerCase();
    	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
    	        encoding === 'utf16le' || encoding === 'utf-16le') {
    	      if (arr.length < 2 || val.length < 2) {
    	        return -1
    	      }
    	      indexSize = 2;
    	      arrLength /= 2;
    	      valLength /= 2;
    	      byteOffset /= 2;
    	    }
    	  }

    	  function read (buf, i) {
    	    if (indexSize === 1) {
    	      return buf[i]
    	    } else {
    	      return buf.readUInt16BE(i * indexSize)
    	    }
    	  }

    	  let i;
    	  if (dir) {
    	    let foundIndex = -1;
    	    for (i = byteOffset; i < arrLength; i++) {
    	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
    	        if (foundIndex === -1) foundIndex = i;
    	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
    	      } else {
    	        if (foundIndex !== -1) i -= i - foundIndex;
    	        foundIndex = -1;
    	      }
    	    }
    	  } else {
    	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    	    for (i = byteOffset; i >= 0; i--) {
    	      let found = true;
    	      for (let j = 0; j < valLength; j++) {
    	        if (read(arr, i + j) !== read(val, j)) {
    	          found = false;
    	          break
    	        }
    	      }
    	      if (found) return i
    	    }
    	  }

    	  return -1
    	}

    	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    	  return this.indexOf(val, byteOffset, encoding) !== -1
    	};

    	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    	};

    	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    	};

    	function hexWrite (buf, string, offset, length) {
    	  offset = Number(offset) || 0;
    	  const remaining = buf.length - offset;
    	  if (!length) {
    	    length = remaining;
    	  } else {
    	    length = Number(length);
    	    if (length > remaining) {
    	      length = remaining;
    	    }
    	  }

    	  const strLen = string.length;

    	  if (length > strLen / 2) {
    	    length = strLen / 2;
    	  }
    	  let i;
    	  for (i = 0; i < length; ++i) {
    	    const parsed = parseInt(string.substr(i * 2, 2), 16);
    	    if (numberIsNaN(parsed)) return i
    	    buf[offset + i] = parsed;
    	  }
    	  return i
    	}

    	function utf8Write (buf, string, offset, length) {
    	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    	}

    	function asciiWrite (buf, string, offset, length) {
    	  return blitBuffer(asciiToBytes(string), buf, offset, length)
    	}

    	function base64Write (buf, string, offset, length) {
    	  return blitBuffer(base64ToBytes(string), buf, offset, length)
    	}

    	function ucs2Write (buf, string, offset, length) {
    	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    	}

    	Buffer.prototype.write = function write (string, offset, length, encoding) {
    	  // Buffer#write(string)
    	  if (offset === undefined) {
    	    encoding = 'utf8';
    	    length = this.length;
    	    offset = 0;
    	  // Buffer#write(string, encoding)
    	  } else if (length === undefined && typeof offset === 'string') {
    	    encoding = offset;
    	    length = this.length;
    	    offset = 0;
    	  // Buffer#write(string, offset[, length][, encoding])
    	  } else if (isFinite(offset)) {
    	    offset = offset >>> 0;
    	    if (isFinite(length)) {
    	      length = length >>> 0;
    	      if (encoding === undefined) encoding = 'utf8';
    	    } else {
    	      encoding = length;
    	      length = undefined;
    	    }
    	  } else {
    	    throw new Error(
    	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    	    )
    	  }

    	  const remaining = this.length - offset;
    	  if (length === undefined || length > remaining) length = remaining;

    	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    	    throw new RangeError('Attempt to write outside buffer bounds')
    	  }

    	  if (!encoding) encoding = 'utf8';

    	  let loweredCase = false;
    	  for (;;) {
    	    switch (encoding) {
    	      case 'hex':
    	        return hexWrite(this, string, offset, length)

    	      case 'utf8':
    	      case 'utf-8':
    	        return utf8Write(this, string, offset, length)

    	      case 'ascii':
    	      case 'latin1':
    	      case 'binary':
    	        return asciiWrite(this, string, offset, length)

    	      case 'base64':
    	        // Warning: maxLength not taken into account in base64Write
    	        return base64Write(this, string, offset, length)

    	      case 'ucs2':
    	      case 'ucs-2':
    	      case 'utf16le':
    	      case 'utf-16le':
    	        return ucs2Write(this, string, offset, length)

    	      default:
    	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
    	        encoding = ('' + encoding).toLowerCase();
    	        loweredCase = true;
    	    }
    	  }
    	};

    	Buffer.prototype.toJSON = function toJSON () {
    	  return {
    	    type: 'Buffer',
    	    data: Array.prototype.slice.call(this._arr || this, 0)
    	  }
    	};

    	function base64Slice (buf, start, end) {
    	  if (start === 0 && end === buf.length) {
    	    return base64.fromByteArray(buf)
    	  } else {
    	    return base64.fromByteArray(buf.slice(start, end))
    	  }
    	}

    	function utf8Slice (buf, start, end) {
    	  end = Math.min(buf.length, end);
    	  const res = [];

    	  let i = start;
    	  while (i < end) {
    	    const firstByte = buf[i];
    	    let codePoint = null;
    	    let bytesPerSequence = (firstByte > 0xEF)
    	      ? 4
    	      : (firstByte > 0xDF)
    	          ? 3
    	          : (firstByte > 0xBF)
    	              ? 2
    	              : 1;

    	    if (i + bytesPerSequence <= end) {
    	      let secondByte, thirdByte, fourthByte, tempCodePoint;

    	      switch (bytesPerSequence) {
    	        case 1:
    	          if (firstByte < 0x80) {
    	            codePoint = firstByte;
    	          }
    	          break
    	        case 2:
    	          secondByte = buf[i + 1];
    	          if ((secondByte & 0xC0) === 0x80) {
    	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
    	            if (tempCodePoint > 0x7F) {
    	              codePoint = tempCodePoint;
    	            }
    	          }
    	          break
    	        case 3:
    	          secondByte = buf[i + 1];
    	          thirdByte = buf[i + 2];
    	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
    	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
    	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
    	              codePoint = tempCodePoint;
    	            }
    	          }
    	          break
    	        case 4:
    	          secondByte = buf[i + 1];
    	          thirdByte = buf[i + 2];
    	          fourthByte = buf[i + 3];
    	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
    	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
    	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
    	              codePoint = tempCodePoint;
    	            }
    	          }
    	      }
    	    }

    	    if (codePoint === null) {
    	      // we did not generate a valid codePoint so insert a
    	      // replacement char (U+FFFD) and advance only 1 byte
    	      codePoint = 0xFFFD;
    	      bytesPerSequence = 1;
    	    } else if (codePoint > 0xFFFF) {
    	      // encode to utf16 (surrogate pair dance)
    	      codePoint -= 0x10000;
    	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
    	      codePoint = 0xDC00 | codePoint & 0x3FF;
    	    }

    	    res.push(codePoint);
    	    i += bytesPerSequence;
    	  }

    	  return decodeCodePointsArray(res)
    	}

    	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
    	// the lowest limit is Chrome, with 0x10000 args.
    	// We go 1 magnitude less, for safety
    	const MAX_ARGUMENTS_LENGTH = 0x1000;

    	function decodeCodePointsArray (codePoints) {
    	  const len = codePoints.length;
    	  if (len <= MAX_ARGUMENTS_LENGTH) {
    	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    	  }

    	  // Decode in chunks to avoid "call stack size exceeded".
    	  let res = '';
    	  let i = 0;
    	  while (i < len) {
    	    res += String.fromCharCode.apply(
    	      String,
    	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    	    );
    	  }
    	  return res
    	}

    	function asciiSlice (buf, start, end) {
    	  let ret = '';
    	  end = Math.min(buf.length, end);

    	  for (let i = start; i < end; ++i) {
    	    ret += String.fromCharCode(buf[i] & 0x7F);
    	  }
    	  return ret
    	}

    	function latin1Slice (buf, start, end) {
    	  let ret = '';
    	  end = Math.min(buf.length, end);

    	  for (let i = start; i < end; ++i) {
    	    ret += String.fromCharCode(buf[i]);
    	  }
    	  return ret
    	}

    	function hexSlice (buf, start, end) {
    	  const len = buf.length;

    	  if (!start || start < 0) start = 0;
    	  if (!end || end < 0 || end > len) end = len;

    	  let out = '';
    	  for (let i = start; i < end; ++i) {
    	    out += hexSliceLookupTable[buf[i]];
    	  }
    	  return out
    	}

    	function utf16leSlice (buf, start, end) {
    	  const bytes = buf.slice(start, end);
    	  let res = '';
    	  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    	  for (let i = 0; i < bytes.length - 1; i += 2) {
    	    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
    	  }
    	  return res
    	}

    	Buffer.prototype.slice = function slice (start, end) {
    	  const len = this.length;
    	  start = ~~start;
    	  end = end === undefined ? len : ~~end;

    	  if (start < 0) {
    	    start += len;
    	    if (start < 0) start = 0;
    	  } else if (start > len) {
    	    start = len;
    	  }

    	  if (end < 0) {
    	    end += len;
    	    if (end < 0) end = 0;
    	  } else if (end > len) {
    	    end = len;
    	  }

    	  if (end < start) end = start;

    	  const newBuf = this.subarray(start, end);
    	  // Return an augmented `Uint8Array` instance
    	  Object.setPrototypeOf(newBuf, Buffer.prototype);

    	  return newBuf
    	};

    	/*
    	 * Need to make sure that buffer isn't trying to write out of bounds.
    	 */
    	function checkOffset (offset, ext, length) {
    	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    	}

    	Buffer.prototype.readUintLE =
    	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) checkOffset(offset, byteLength, this.length);

    	  let val = this[offset];
    	  let mul = 1;
    	  let i = 0;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    val += this[offset + i] * mul;
    	  }

    	  return val
    	};

    	Buffer.prototype.readUintBE =
    	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) {
    	    checkOffset(offset, byteLength, this.length);
    	  }

    	  let val = this[offset + --byteLength];
    	  let mul = 1;
    	  while (byteLength > 0 && (mul *= 0x100)) {
    	    val += this[offset + --byteLength] * mul;
    	  }

    	  return val
    	};

    	Buffer.prototype.readUint8 =
    	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 1, this.length);
    	  return this[offset]
    	};

    	Buffer.prototype.readUint16LE =
    	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  return this[offset] | (this[offset + 1] << 8)
    	};

    	Buffer.prototype.readUint16BE =
    	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  return (this[offset] << 8) | this[offset + 1]
    	};

    	Buffer.prototype.readUint32LE =
    	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return ((this[offset]) |
    	      (this[offset + 1] << 8) |
    	      (this[offset + 2] << 16)) +
    	      (this[offset + 3] * 0x1000000)
    	};

    	Buffer.prototype.readUint32BE =
    	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return (this[offset] * 0x1000000) +
    	    ((this[offset + 1] << 16) |
    	    (this[offset + 2] << 8) |
    	    this[offset + 3])
    	};

    	Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const lo = first +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 24;

    	  const hi = this[++offset] +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset] * 2 ** 16 +
    	    last * 2 ** 24;

    	  return BigInt(lo) + (BigInt(hi) << BigInt(32))
    	});

    	Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const hi = first * 2 ** 24 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset];

    	  const lo = this[++offset] * 2 ** 24 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    last;

    	  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
    	});

    	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) checkOffset(offset, byteLength, this.length);

    	  let val = this[offset];
    	  let mul = 1;
    	  let i = 0;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    val += this[offset + i] * mul;
    	  }
    	  mul *= 0x80;

    	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    	  return val
    	};

    	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) checkOffset(offset, byteLength, this.length);

    	  let i = byteLength;
    	  let mul = 1;
    	  let val = this[offset + --i];
    	  while (i > 0 && (mul *= 0x100)) {
    	    val += this[offset + --i] * mul;
    	  }
    	  mul *= 0x80;

    	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    	  return val
    	};

    	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 1, this.length);
    	  if (!(this[offset] & 0x80)) return (this[offset])
    	  return ((0xff - this[offset] + 1) * -1)
    	};

    	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  const val = this[offset] | (this[offset + 1] << 8);
    	  return (val & 0x8000) ? val | 0xFFFF0000 : val
    	};

    	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  const val = this[offset + 1] | (this[offset] << 8);
    	  return (val & 0x8000) ? val | 0xFFFF0000 : val
    	};

    	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return (this[offset]) |
    	    (this[offset + 1] << 8) |
    	    (this[offset + 2] << 16) |
    	    (this[offset + 3] << 24)
    	};

    	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return (this[offset] << 24) |
    	    (this[offset + 1] << 16) |
    	    (this[offset + 2] << 8) |
    	    (this[offset + 3])
    	};

    	Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const val = this[offset + 4] +
    	    this[offset + 5] * 2 ** 8 +
    	    this[offset + 6] * 2 ** 16 +
    	    (last << 24); // Overflow

    	  return (BigInt(val) << BigInt(32)) +
    	    BigInt(first +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 24)
    	});

    	Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const val = (first << 24) + // Overflow
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset];

    	  return (BigInt(val) << BigInt(32)) +
    	    BigInt(this[++offset] * 2 ** 24 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    last)
    	});

    	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);
    	  return ieee754$1.read(this, offset, true, 23, 4)
    	};

    	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);
    	  return ieee754$1.read(this, offset, false, 23, 4)
    	};

    	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 8, this.length);
    	  return ieee754$1.read(this, offset, true, 52, 8)
    	};

    	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 8, this.length);
    	  return ieee754$1.read(this, offset, false, 52, 8)
    	};

    	function checkInt (buf, value, offset, ext, max, min) {
    	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
    	}

    	Buffer.prototype.writeUintLE =
    	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) {
    	    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    	    checkInt(this, value, offset, byteLength, maxBytes, 0);
    	  }

    	  let mul = 1;
    	  let i = 0;
    	  this[offset] = value & 0xFF;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    this[offset + i] = (value / mul) & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeUintBE =
    	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) {
    	    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    	    checkInt(this, value, offset, byteLength, maxBytes, 0);
    	  }

    	  let i = byteLength - 1;
    	  let mul = 1;
    	  this[offset + i] = value & 0xFF;
    	  while (--i >= 0 && (mul *= 0x100)) {
    	    this[offset + i] = (value / mul) & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeUint8 =
    	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    	  this[offset] = (value & 0xff);
    	  return offset + 1
    	};

    	Buffer.prototype.writeUint16LE =
    	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    	  this[offset] = (value & 0xff);
    	  this[offset + 1] = (value >>> 8);
    	  return offset + 2
    	};

    	Buffer.prototype.writeUint16BE =
    	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    	  this[offset] = (value >>> 8);
    	  this[offset + 1] = (value & 0xff);
    	  return offset + 2
    	};

    	Buffer.prototype.writeUint32LE =
    	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    	  this[offset + 3] = (value >>> 24);
    	  this[offset + 2] = (value >>> 16);
    	  this[offset + 1] = (value >>> 8);
    	  this[offset] = (value & 0xff);
    	  return offset + 4
    	};

    	Buffer.prototype.writeUint32BE =
    	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    	  this[offset] = (value >>> 24);
    	  this[offset + 1] = (value >>> 16);
    	  this[offset + 2] = (value >>> 8);
    	  this[offset + 3] = (value & 0xff);
    	  return offset + 4
    	};

    	function wrtBigUInt64LE (buf, value, offset, min, max) {
    	  checkIntBI(value, min, max, buf, offset, 7);

    	  let lo = Number(value & BigInt(0xffffffff));
    	  buf[offset++] = lo;
    	  lo = lo >> 8;
    	  buf[offset++] = lo;
    	  lo = lo >> 8;
    	  buf[offset++] = lo;
    	  lo = lo >> 8;
    	  buf[offset++] = lo;
    	  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    	  buf[offset++] = hi;
    	  hi = hi >> 8;
    	  buf[offset++] = hi;
    	  hi = hi >> 8;
    	  buf[offset++] = hi;
    	  hi = hi >> 8;
    	  buf[offset++] = hi;
    	  return offset
    	}

    	function wrtBigUInt64BE (buf, value, offset, min, max) {
    	  checkIntBI(value, min, max, buf, offset, 7);

    	  let lo = Number(value & BigInt(0xffffffff));
    	  buf[offset + 7] = lo;
    	  lo = lo >> 8;
    	  buf[offset + 6] = lo;
    	  lo = lo >> 8;
    	  buf[offset + 5] = lo;
    	  lo = lo >> 8;
    	  buf[offset + 4] = lo;
    	  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    	  buf[offset + 3] = hi;
    	  hi = hi >> 8;
    	  buf[offset + 2] = hi;
    	  hi = hi >> 8;
    	  buf[offset + 1] = hi;
    	  hi = hi >> 8;
    	  buf[offset] = hi;
    	  return offset + 8
    	}

    	Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
    	  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    	});

    	Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
    	  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    	});

    	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    const limit = Math.pow(2, (8 * byteLength) - 1);

    	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
    	  }

    	  let i = 0;
    	  let mul = 1;
    	  let sub = 0;
    	  this[offset] = value & 0xFF;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
    	      sub = 1;
    	    }
    	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    const limit = Math.pow(2, (8 * byteLength) - 1);

    	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
    	  }

    	  let i = byteLength - 1;
    	  let mul = 1;
    	  let sub = 0;
    	  this[offset + i] = value & 0xFF;
    	  while (--i >= 0 && (mul *= 0x100)) {
    	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
    	      sub = 1;
    	    }
    	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    	  if (value < 0) value = 0xff + value + 1;
    	  this[offset] = (value & 0xff);
    	  return offset + 1
    	};

    	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    	  this[offset] = (value & 0xff);
    	  this[offset + 1] = (value >>> 8);
    	  return offset + 2
    	};

    	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    	  this[offset] = (value >>> 8);
    	  this[offset + 1] = (value & 0xff);
    	  return offset + 2
    	};

    	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    	  this[offset] = (value & 0xff);
    	  this[offset + 1] = (value >>> 8);
    	  this[offset + 2] = (value >>> 16);
    	  this[offset + 3] = (value >>> 24);
    	  return offset + 4
    	};

    	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    	  if (value < 0) value = 0xffffffff + value + 1;
    	  this[offset] = (value >>> 24);
    	  this[offset + 1] = (value >>> 16);
    	  this[offset + 2] = (value >>> 8);
    	  this[offset + 3] = (value & 0xff);
    	  return offset + 4
    	};

    	Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
    	  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    	});

    	Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
    	  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    	});

    	function checkIEEE754 (buf, value, offset, ext, max, min) {
    	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
    	  if (offset < 0) throw new RangeError('Index out of range')
    	}

    	function writeFloat (buf, value, offset, littleEndian, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    checkIEEE754(buf, value, offset, 4);
    	  }
    	  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    	  return offset + 4
    	}

    	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    	  return writeFloat(this, value, offset, true, noAssert)
    	};

    	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    	  return writeFloat(this, value, offset, false, noAssert)
    	};

    	function writeDouble (buf, value, offset, littleEndian, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    checkIEEE754(buf, value, offset, 8);
    	  }
    	  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    	  return offset + 8
    	}

    	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    	  return writeDouble(this, value, offset, true, noAssert)
    	};

    	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    	  return writeDouble(this, value, offset, false, noAssert)
    	};

    	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    	  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    	  if (!start) start = 0;
    	  if (!end && end !== 0) end = this.length;
    	  if (targetStart >= target.length) targetStart = target.length;
    	  if (!targetStart) targetStart = 0;
    	  if (end > 0 && end < start) end = start;

    	  // Copy 0 bytes; we're done
    	  if (end === start) return 0
    	  if (target.length === 0 || this.length === 0) return 0

    	  // Fatal error conditions
    	  if (targetStart < 0) {
    	    throw new RangeError('targetStart out of bounds')
    	  }
    	  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

    	  // Are we oob?
    	  if (end > this.length) end = this.length;
    	  if (target.length - targetStart < end - start) {
    	    end = target.length - targetStart + start;
    	  }

    	  const len = end - start;

    	  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    	    // Use built-in when available, missing from IE11
    	    this.copyWithin(targetStart, start, end);
    	  } else {
    	    Uint8Array.prototype.set.call(
    	      target,
    	      this.subarray(start, end),
    	      targetStart
    	    );
    	  }

    	  return len
    	};

    	// Usage:
    	//    buffer.fill(number[, offset[, end]])
    	//    buffer.fill(buffer[, offset[, end]])
    	//    buffer.fill(string[, offset[, end]][, encoding])
    	Buffer.prototype.fill = function fill (val, start, end, encoding) {
    	  // Handle string cases:
    	  if (typeof val === 'string') {
    	    if (typeof start === 'string') {
    	      encoding = start;
    	      start = 0;
    	      end = this.length;
    	    } else if (typeof end === 'string') {
    	      encoding = end;
    	      end = this.length;
    	    }
    	    if (encoding !== undefined && typeof encoding !== 'string') {
    	      throw new TypeError('encoding must be a string')
    	    }
    	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
    	      throw new TypeError('Unknown encoding: ' + encoding)
    	    }
    	    if (val.length === 1) {
    	      const code = val.charCodeAt(0);
    	      if ((encoding === 'utf8' && code < 128) ||
    	          encoding === 'latin1') {
    	        // Fast path: If `val` fits into a single byte, use that numeric value.
    	        val = code;
    	      }
    	    }
    	  } else if (typeof val === 'number') {
    	    val = val & 255;
    	  } else if (typeof val === 'boolean') {
    	    val = Number(val);
    	  }

    	  // Invalid ranges are not set to a default, so can range check early.
    	  if (start < 0 || this.length < start || this.length < end) {
    	    throw new RangeError('Out of range index')
    	  }

    	  if (end <= start) {
    	    return this
    	  }

    	  start = start >>> 0;
    	  end = end === undefined ? this.length : end >>> 0;

    	  if (!val) val = 0;

    	  let i;
    	  if (typeof val === 'number') {
    	    for (i = start; i < end; ++i) {
    	      this[i] = val;
    	    }
    	  } else {
    	    const bytes = Buffer.isBuffer(val)
    	      ? val
    	      : Buffer.from(val, encoding);
    	    const len = bytes.length;
    	    if (len === 0) {
    	      throw new TypeError('The value "' + val +
    	        '" is invalid for argument "value"')
    	    }
    	    for (i = 0; i < end - start; ++i) {
    	      this[i + start] = bytes[i % len];
    	    }
    	  }

    	  return this
    	};

    	// CUSTOM ERRORS
    	// =============

    	// Simplified versions from Node, changed for Buffer-only usage
    	const errors = {};
    	function E (sym, getMessage, Base) {
    	  errors[sym] = class NodeError extends Base {
    	    constructor () {
    	      super();

    	      Object.defineProperty(this, 'message', {
    	        value: getMessage.apply(this, arguments),
    	        writable: true,
    	        configurable: true
    	      });

    	      // Add the error code to the name to include it in the stack trace.
    	      this.name = `${this.name} [${sym}]`;
    	      // Access the stack to generate the error message including the error code
    	      // from the name.
    	      this.stack; // eslint-disable-line no-unused-expressions
    	      // Reset the name to the actual name.
    	      delete this.name;
    	    }

    	    get code () {
    	      return sym
    	    }

    	    set code (value) {
    	      Object.defineProperty(this, 'code', {
    	        configurable: true,
    	        enumerable: true,
    	        value,
    	        writable: true
    	      });
    	    }

    	    toString () {
    	      return `${this.name} [${sym}]: ${this.message}`
    	    }
    	  };
    	}

    	E('ERR_BUFFER_OUT_OF_BOUNDS',
    	  function (name) {
    	    if (name) {
    	      return `${name} is outside of buffer bounds`
    	    }

    	    return 'Attempt to access memory outside buffer bounds'
    	  }, RangeError);
    	E('ERR_INVALID_ARG_TYPE',
    	  function (name, actual) {
    	    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
    	  }, TypeError);
    	E('ERR_OUT_OF_RANGE',
    	  function (str, range, input) {
    	    let msg = `The value of "${str}" is out of range.`;
    	    let received = input;
    	    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
    	      received = addNumericalSeparator(String(input));
    	    } else if (typeof input === 'bigint') {
    	      received = String(input);
    	      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
    	        received = addNumericalSeparator(received);
    	      }
    	      received += 'n';
    	    }
    	    msg += ` It must be ${range}. Received ${received}`;
    	    return msg
    	  }, RangeError);

    	function addNumericalSeparator (val) {
    	  let res = '';
    	  let i = val.length;
    	  const start = val[0] === '-' ? 1 : 0;
    	  for (; i >= start + 4; i -= 3) {
    	    res = `_${val.slice(i - 3, i)}${res}`;
    	  }
    	  return `${val.slice(0, i)}${res}`
    	}

    	// CHECK FUNCTIONS
    	// ===============

    	function checkBounds (buf, offset, byteLength) {
    	  validateNumber(offset, 'offset');
    	  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    	    boundsError(offset, buf.length - (byteLength + 1));
    	  }
    	}

    	function checkIntBI (value, min, max, buf, offset, byteLength) {
    	  if (value > max || value < min) {
    	    const n = typeof min === 'bigint' ? 'n' : '';
    	    let range;
    	    {
    	      if (min === 0 || min === BigInt(0)) {
    	        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
    	      } else {
    	        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
    	                `${(byteLength + 1) * 8 - 1}${n}`;
    	      }
    	    }
    	    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
    	  }
    	  checkBounds(buf, offset, byteLength);
    	}

    	function validateNumber (value, name) {
    	  if (typeof value !== 'number') {
    	    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
    	  }
    	}

    	function boundsError (value, length, type) {
    	  if (Math.floor(value) !== value) {
    	    validateNumber(value, type);
    	    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value)
    	  }

    	  if (length < 0) {
    	    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
    	  }

    	  throw new errors.ERR_OUT_OF_RANGE('offset',
    	                                    `>= ${0} and <= ${length}`,
    	                                    value)
    	}

    	// HELPER FUNCTIONS
    	// ================

    	const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    	function base64clean (str) {
    	  // Node takes equal signs as end of the Base64 encoding
    	  str = str.split('=')[0];
    	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
    	  str = str.trim().replace(INVALID_BASE64_RE, '');
    	  // Node converts strings with length < 2 to ''
    	  if (str.length < 2) return ''
    	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    	  while (str.length % 4 !== 0) {
    	    str = str + '=';
    	  }
    	  return str
    	}

    	function utf8ToBytes (string, units) {
    	  units = units || Infinity;
    	  let codePoint;
    	  const length = string.length;
    	  let leadSurrogate = null;
    	  const bytes = [];

    	  for (let i = 0; i < length; ++i) {
    	    codePoint = string.charCodeAt(i);

    	    // is surrogate component
    	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
    	      // last char was a lead
    	      if (!leadSurrogate) {
    	        // no lead yet
    	        if (codePoint > 0xDBFF) {
    	          // unexpected trail
    	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	          continue
    	        } else if (i + 1 === length) {
    	          // unpaired lead
    	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	          continue
    	        }

    	        // valid lead
    	        leadSurrogate = codePoint;

    	        continue
    	      }

    	      // 2 leads in a row
    	      if (codePoint < 0xDC00) {
    	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	        leadSurrogate = codePoint;
    	        continue
    	      }

    	      // valid surrogate pair
    	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    	    } else if (leadSurrogate) {
    	      // valid bmp char, but last char was a lead
    	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	    }

    	    leadSurrogate = null;

    	    // encode utf8
    	    if (codePoint < 0x80) {
    	      if ((units -= 1) < 0) break
    	      bytes.push(codePoint);
    	    } else if (codePoint < 0x800) {
    	      if ((units -= 2) < 0) break
    	      bytes.push(
    	        codePoint >> 0x6 | 0xC0,
    	        codePoint & 0x3F | 0x80
    	      );
    	    } else if (codePoint < 0x10000) {
    	      if ((units -= 3) < 0) break
    	      bytes.push(
    	        codePoint >> 0xC | 0xE0,
    	        codePoint >> 0x6 & 0x3F | 0x80,
    	        codePoint & 0x3F | 0x80
    	      );
    	    } else if (codePoint < 0x110000) {
    	      if ((units -= 4) < 0) break
    	      bytes.push(
    	        codePoint >> 0x12 | 0xF0,
    	        codePoint >> 0xC & 0x3F | 0x80,
    	        codePoint >> 0x6 & 0x3F | 0x80,
    	        codePoint & 0x3F | 0x80
    	      );
    	    } else {
    	      throw new Error('Invalid code point')
    	    }
    	  }

    	  return bytes
    	}

    	function asciiToBytes (str) {
    	  const byteArray = [];
    	  for (let i = 0; i < str.length; ++i) {
    	    // Node's code seems to be doing this and not & 0x7F..
    	    byteArray.push(str.charCodeAt(i) & 0xFF);
    	  }
    	  return byteArray
    	}

    	function utf16leToBytes (str, units) {
    	  let c, hi, lo;
    	  const byteArray = [];
    	  for (let i = 0; i < str.length; ++i) {
    	    if ((units -= 2) < 0) break

    	    c = str.charCodeAt(i);
    	    hi = c >> 8;
    	    lo = c % 256;
    	    byteArray.push(lo);
    	    byteArray.push(hi);
    	  }

    	  return byteArray
    	}

    	function base64ToBytes (str) {
    	  return base64.toByteArray(base64clean(str))
    	}

    	function blitBuffer (src, dst, offset, length) {
    	  let i;
    	  for (i = 0; i < length; ++i) {
    	    if ((i + offset >= dst.length) || (i >= src.length)) break
    	    dst[i + offset] = src[i];
    	  }
    	  return i
    	}

    	// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    	// the `instanceof` check but they should be treated as of that type.
    	// See: https://github.com/feross/buffer/issues/166
    	function isInstance (obj, type) {
    	  return obj instanceof type ||
    	    (obj != null && obj.constructor != null && obj.constructor.name != null &&
    	      obj.constructor.name === type.name)
    	}
    	function numberIsNaN (obj) {
    	  // For IE11 support
    	  return obj !== obj // eslint-disable-line no-self-compare
    	}

    	// Create lookup table for `toString('hex')`
    	// See: https://github.com/feross/buffer/issues/219
    	const hexSliceLookupTable = (function () {
    	  const alphabet = '0123456789abcdef';
    	  const table = new Array(256);
    	  for (let i = 0; i < 16; ++i) {
    	    const i16 = i * 16;
    	    for (let j = 0; j < 16; ++j) {
    	      table[i16 + j] = alphabet[i] + alphabet[j];
    	    }
    	  }
    	  return table
    	})();

    	// Return not function with Error if BigInt not supported
    	function defineBigIntMethod (fn) {
    	  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
    	}

    	function BufferBigIntNotDefined () {
    	  throw new Error('BigInt not supported')
    	} 
    } (buffer));

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    const byteToHex = [];

    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1));
    }

    function unsafeStringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }

    const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var native = {
      randomUUID
    };

    function v4(options, buf, offset) {
      if (native.randomUUID && !buf && !options) {
        return native.randomUUID();
      }

      options = options || {};
      const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      return unsafeStringify(rnds);
    }

    var crypto$1 = crypto;
    const isCryptoKey = (key) => key instanceof CryptoKey;

    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    function concat(...buffers) {
        const size = buffers.reduce((acc, { length }) => acc + length, 0);
        const buf = new Uint8Array(size);
        let i = 0;
        for (const buffer of buffers) {
            buf.set(buffer, i);
            i += buffer.length;
        }
        return buf;
    }

    const encodeBase64 = (input) => {
        let unencoded = input;
        if (typeof unencoded === 'string') {
            unencoded = encoder.encode(unencoded);
        }
        const CHUNK_SIZE = 0x8000;
        const arr = [];
        for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
            arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
        }
        return btoa(arr.join(''));
    };
    const encode = (input) => {
        return encodeBase64(input).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    };
    const decodeBase64 = (encoded) => {
        const binary = atob(encoded);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
    };
    const decode = (input) => {
        let encoded = input;
        if (encoded instanceof Uint8Array) {
            encoded = decoder.decode(encoded);
        }
        encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
        try {
            return decodeBase64(encoded);
        }
        catch {
            throw new TypeError('The input to be decoded is not correctly encoded.');
        }
    };

    class JOSEError extends Error {
        static get code() {
            return 'ERR_JOSE_GENERIC';
        }
        constructor(message) {
            super(message);
            this.code = 'ERR_JOSE_GENERIC';
            this.name = this.constructor.name;
            Error.captureStackTrace?.(this, this.constructor);
        }
    }
    class JOSENotSupported extends JOSEError {
        constructor() {
            super(...arguments);
            this.code = 'ERR_JOSE_NOT_SUPPORTED';
        }
        static get code() {
            return 'ERR_JOSE_NOT_SUPPORTED';
        }
    }
    class JWSInvalid extends JOSEError {
        constructor() {
            super(...arguments);
            this.code = 'ERR_JWS_INVALID';
        }
        static get code() {
            return 'ERR_JWS_INVALID';
        }
    }
    class JWTInvalid extends JOSEError {
        constructor() {
            super(...arguments);
            this.code = 'ERR_JWT_INVALID';
        }
        static get code() {
            return 'ERR_JWT_INVALID';
        }
    }

    function unusable(name, prop = 'algorithm.name') {
        return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
    }
    function isAlgorithm(algorithm, name) {
        return algorithm.name === name;
    }
    function getHashLength(hash) {
        return parseInt(hash.name.slice(4), 10);
    }
    function getNamedCurve$1(alg) {
        switch (alg) {
            case 'ES256':
                return 'P-256';
            case 'ES384':
                return 'P-384';
            case 'ES512':
                return 'P-521';
            default:
                throw new Error('unreachable');
        }
    }
    function checkUsage(key, usages) {
        if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
            let msg = 'CryptoKey does not support this operation, its usages must include ';
            if (usages.length > 2) {
                const last = usages.pop();
                msg += `one of ${usages.join(', ')}, or ${last}.`;
            }
            else if (usages.length === 2) {
                msg += `one of ${usages[0]} or ${usages[1]}.`;
            }
            else {
                msg += `${usages[0]}.`;
            }
            throw new TypeError(msg);
        }
    }
    function checkSigCryptoKey(key, alg, ...usages) {
        switch (alg) {
            case 'HS256':
            case 'HS384':
            case 'HS512': {
                if (!isAlgorithm(key.algorithm, 'HMAC'))
                    throw unusable('HMAC');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected)
                    throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
            case 'RS256':
            case 'RS384':
            case 'RS512': {
                if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
                    throw unusable('RSASSA-PKCS1-v1_5');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected)
                    throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
            case 'PS256':
            case 'PS384':
            case 'PS512': {
                if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
                    throw unusable('RSA-PSS');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected)
                    throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
            case 'EdDSA': {
                if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {
                    throw unusable('Ed25519 or Ed448');
                }
                break;
            }
            case 'ES256':
            case 'ES384':
            case 'ES512': {
                if (!isAlgorithm(key.algorithm, 'ECDSA'))
                    throw unusable('ECDSA');
                const expected = getNamedCurve$1(alg);
                const actual = key.algorithm.namedCurve;
                if (actual !== expected)
                    throw unusable(expected, 'algorithm.namedCurve');
                break;
            }
            default:
                throw new TypeError('CryptoKey does not support this operation');
        }
        checkUsage(key, usages);
    }

    function message(msg, actual, ...types) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(', ')}, or ${last}.`;
        }
        else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}.`;
        }
        else {
            msg += `of type ${types[0]}.`;
        }
        if (actual == null) {
            msg += ` Received ${actual}`;
        }
        else if (typeof actual === 'function' && actual.name) {
            msg += ` Received function ${actual.name}`;
        }
        else if (typeof actual === 'object' && actual != null) {
            if (actual.constructor?.name) {
                msg += ` Received an instance of ${actual.constructor.name}`;
            }
        }
        return msg;
    }
    var invalidKeyInput = (actual, ...types) => {
        return message('Key must be ', actual, ...types);
    };
    function withAlg(alg, actual, ...types) {
        return message(`Key for the ${alg} algorithm must be `, actual, ...types);
    }

    var isKeyLike = (key) => {
        if (isCryptoKey(key)) {
            return true;
        }
        return key?.[Symbol.toStringTag] === 'KeyObject';
    };
    const types = ['CryptoKey'];

    const isDisjoint = (...headers) => {
        const sources = headers.filter(Boolean);
        if (sources.length === 0 || sources.length === 1) {
            return true;
        }
        let acc;
        for (const header of sources) {
            const parameters = Object.keys(header);
            if (!acc || acc.size === 0) {
                acc = new Set(parameters);
                continue;
            }
            for (const parameter of parameters) {
                if (acc.has(parameter)) {
                    return false;
                }
                acc.add(parameter);
            }
        }
        return true;
    };

    function isObjectLike(value) {
        return typeof value === 'object' && value !== null;
    }
    function isObject(input) {
        if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
            return false;
        }
        if (Object.getPrototypeOf(input) === null) {
            return true;
        }
        let proto = input;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(input) === proto;
    }

    var checkKeyLength = (alg, key) => {
        if (alg.startsWith('RS') || alg.startsWith('PS')) {
            const { modulusLength } = key.algorithm;
            if (typeof modulusLength !== 'number' || modulusLength < 2048) {
                throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
            }
        }
    };

    function subtleMapping(jwk) {
        let algorithm;
        let keyUsages;
        switch (jwk.kty) {
            case 'RSA': {
                switch (jwk.alg) {
                    case 'PS256':
                    case 'PS384':
                    case 'PS512':
                        algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };
                        keyUsages = jwk.d ? ['sign'] : ['verify'];
                        break;
                    case 'RS256':
                    case 'RS384':
                    case 'RS512':
                        algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };
                        keyUsages = jwk.d ? ['sign'] : ['verify'];
                        break;
                    case 'RSA-OAEP':
                    case 'RSA-OAEP-256':
                    case 'RSA-OAEP-384':
                    case 'RSA-OAEP-512':
                        algorithm = {
                            name: 'RSA-OAEP',
                            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,
                        };
                        keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];
                        break;
                    default:
                        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
            }
            case 'EC': {
                switch (jwk.alg) {
                    case 'ES256':
                        algorithm = { name: 'ECDSA', namedCurve: 'P-256' };
                        keyUsages = jwk.d ? ['sign'] : ['verify'];
                        break;
                    case 'ES384':
                        algorithm = { name: 'ECDSA', namedCurve: 'P-384' };
                        keyUsages = jwk.d ? ['sign'] : ['verify'];
                        break;
                    case 'ES512':
                        algorithm = { name: 'ECDSA', namedCurve: 'P-521' };
                        keyUsages = jwk.d ? ['sign'] : ['verify'];
                        break;
                    case 'ECDH-ES':
                    case 'ECDH-ES+A128KW':
                    case 'ECDH-ES+A192KW':
                    case 'ECDH-ES+A256KW':
                        algorithm = { name: 'ECDH', namedCurve: jwk.crv };
                        keyUsages = jwk.d ? ['deriveBits'] : [];
                        break;
                    default:
                        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
            }
            case 'OKP': {
                switch (jwk.alg) {
                    case 'EdDSA':
                        algorithm = { name: jwk.crv };
                        keyUsages = jwk.d ? ['sign'] : ['verify'];
                        break;
                    case 'ECDH-ES':
                    case 'ECDH-ES+A128KW':
                    case 'ECDH-ES+A192KW':
                    case 'ECDH-ES+A256KW':
                        algorithm = { name: jwk.crv };
                        keyUsages = jwk.d ? ['deriveBits'] : [];
                        break;
                    default:
                        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
                }
                break;
            }
            default:
                throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
        }
        return { algorithm, keyUsages };
    }
    const parse = async (jwk) => {
        if (!jwk.alg) {
            throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
        }
        const { algorithm, keyUsages } = subtleMapping(jwk);
        const rest = [
            algorithm,
            jwk.ext ?? false,
            jwk.key_ops ?? keyUsages,
        ];
        const keyData = { ...jwk };
        delete keyData.alg;
        delete keyData.use;
        return crypto$1.subtle.importKey('jwk', keyData, ...rest);
    };

    const normalizeSecretKey = (k) => decode(k);
    let privCache;
    let pubCache;
    const isKeyObject = (key) => {
        return key?.[Symbol.toStringTag] === 'KeyObject';
    };
    const importAndCache = async (cache, key, jwk, alg) => {
        let cached = cache.get(key);
        if (cached?.[alg]) {
            return cached[alg];
        }
        const cryptoKey = await parse({ ...jwk, alg });
        if (!cached) {
            cache.set(key, { [alg]: cryptoKey });
        }
        else {
            cached[alg] = cryptoKey;
        }
        return cryptoKey;
    };
    const normalizePublicKey = (key, alg) => {
        if (isKeyObject(key)) {
            let jwk = key.export({ format: 'jwk' });
            delete jwk.d;
            delete jwk.dp;
            delete jwk.dq;
            delete jwk.p;
            delete jwk.q;
            delete jwk.qi;
            if (jwk.k) {
                return normalizeSecretKey(jwk.k);
            }
            pubCache || (pubCache = new WeakMap());
            return importAndCache(pubCache, key, jwk, alg);
        }
        return key;
    };
    const normalizePrivateKey = (key, alg) => {
        if (isKeyObject(key)) {
            let jwk = key.export({ format: 'jwk' });
            if (jwk.k) {
                return normalizeSecretKey(jwk.k);
            }
            privCache || (privCache = new WeakMap());
            return importAndCache(privCache, key, jwk, alg);
        }
        return key;
    };
    var normalize = { normalizePublicKey, normalizePrivateKey };

    const findOid = (keyData, oid, from = 0) => {
        if (from === 0) {
            oid.unshift(oid.length);
            oid.unshift(0x06);
        }
        const i = keyData.indexOf(oid[0], from);
        if (i === -1)
            return false;
        const sub = keyData.subarray(i, i + oid.length);
        if (sub.length !== oid.length)
            return false;
        return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
    };
    const getNamedCurve = (keyData) => {
        switch (true) {
            case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):
                return 'P-256';
            case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):
                return 'P-384';
            case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):
                return 'P-521';
            case findOid(keyData, [0x2b, 0x65, 0x6e]):
                return 'X25519';
            case findOid(keyData, [0x2b, 0x65, 0x6f]):
                return 'X448';
            case findOid(keyData, [0x2b, 0x65, 0x70]):
                return 'Ed25519';
            case findOid(keyData, [0x2b, 0x65, 0x71]):
                return 'Ed448';
            default:
                throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');
        }
    };
    const genericImport = async (replace, keyFormat, pem, alg, options) => {
        let algorithm;
        let keyUsages;
        const keyData = new Uint8Array(atob(pem.replace(replace, ''))
            .split('')
            .map((c) => c.charCodeAt(0)));
        switch (alg) {
            case 'PS256':
            case 'PS384':
            case 'PS512':
                algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };
                keyUsages = ['sign'];
                break;
            case 'RS256':
            case 'RS384':
            case 'RS512':
                algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };
                keyUsages = ['sign'];
                break;
            case 'RSA-OAEP':
            case 'RSA-OAEP-256':
            case 'RSA-OAEP-384':
            case 'RSA-OAEP-512':
                algorithm = {
                    name: 'RSA-OAEP',
                    hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
                };
                keyUsages = ['decrypt', 'unwrapKey'];
                break;
            case 'ES256':
                algorithm = { name: 'ECDSA', namedCurve: 'P-256' };
                keyUsages = ['sign'];
                break;
            case 'ES384':
                algorithm = { name: 'ECDSA', namedCurve: 'P-384' };
                keyUsages = ['sign'];
                break;
            case 'ES512':
                algorithm = { name: 'ECDSA', namedCurve: 'P-521' };
                keyUsages = ['sign'];
                break;
            case 'ECDH-ES':
            case 'ECDH-ES+A128KW':
            case 'ECDH-ES+A192KW':
            case 'ECDH-ES+A256KW': {
                const namedCurve = getNamedCurve(keyData);
                algorithm = namedCurve.startsWith('P-') ? { name: 'ECDH', namedCurve } : { name: namedCurve };
                keyUsages = ['deriveBits'];
                break;
            }
            case 'EdDSA':
                algorithm = { name: getNamedCurve(keyData) };
                keyUsages = ['sign'];
                break;
            default:
                throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
        }
        return crypto$1.subtle.importKey(keyFormat, keyData, algorithm, false, keyUsages);
    };
    const fromPKCS8 = (pem, alg, options) => {
        return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, 'pkcs8', pem, alg);
    };

    async function importPKCS8(pkcs8, alg, options) {
        if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {
            throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
        }
        return fromPKCS8(pkcs8, alg);
    }

    const tag = (key) => key?.[Symbol.toStringTag];
    const symmetricTypeCheck = (alg, key) => {
        if (key instanceof Uint8Array)
            return;
        if (!isKeyLike(key)) {
            throw new TypeError(withAlg(alg, key, ...types, 'Uint8Array'));
        }
        if (key.type !== 'secret') {
            throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
        }
    };
    const asymmetricTypeCheck = (alg, key, usage) => {
        if (!isKeyLike(key)) {
            throw new TypeError(withAlg(alg, key, ...types));
        }
        if (key.type === 'secret') {
            throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
        }
        if (key.type === 'public') {
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
        }
        if (key.algorithm && usage === 'verify' && key.type === 'private') {
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
        }
        if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
        }
    };
    const checkKeyType = (alg, key, usage) => {
        const symmetric = alg.startsWith('HS') ||
            alg === 'dir' ||
            alg.startsWith('PBES2') ||
            /^A\d{3}(?:GCM)?KW$/.test(alg);
        if (symmetric) {
            symmetricTypeCheck(alg, key);
        }
        else {
            asymmetricTypeCheck(alg, key, usage);
        }
    };

    function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
        if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {
            throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
        }
        if (!protectedHeader || protectedHeader.crit === undefined) {
            return new Set();
        }
        if (!Array.isArray(protectedHeader.crit) ||
            protectedHeader.crit.length === 0 ||
            protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
            throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
        }
        let recognized;
        if (recognizedOption !== undefined) {
            recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
        }
        else {
            recognized = recognizedDefault;
        }
        for (const parameter of protectedHeader.crit) {
            if (!recognized.has(parameter)) {
                throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
            }
            if (joseHeader[parameter] === undefined) {
                throw new Err(`Extension Header Parameter "${parameter}" is missing`);
            }
            if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
                throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
            }
        }
        return new Set(protectedHeader.crit);
    }

    function subtleDsa(alg, algorithm) {
        const hash = `SHA-${alg.slice(-3)}`;
        switch (alg) {
            case 'HS256':
            case 'HS384':
            case 'HS512':
                return { hash, name: 'HMAC' };
            case 'PS256':
            case 'PS384':
            case 'PS512':
                return { hash, name: 'RSA-PSS', saltLength: alg.slice(-3) >> 3 };
            case 'RS256':
            case 'RS384':
            case 'RS512':
                return { hash, name: 'RSASSA-PKCS1-v1_5' };
            case 'ES256':
            case 'ES384':
            case 'ES512':
                return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };
            case 'EdDSA':
                return { name: algorithm.name };
            default:
                throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
        }
    }

    async function getCryptoKey(alg, key, usage) {
        {
            key = await normalize.normalizePrivateKey(key, alg);
        }
        if (isCryptoKey(key)) {
            checkSigCryptoKey(key, alg, usage);
            return key;
        }
        if (key instanceof Uint8Array) {
            if (!alg.startsWith('HS')) {
                throw new TypeError(invalidKeyInput(key, ...types));
            }
            return crypto$1.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);
        }
        throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));
    }

    var epoch = (date) => Math.floor(date.getTime() / 1000);

    const minute = 60;
    const hour = minute * 60;
    const day = hour * 24;
    const week = day * 7;
    const year = day * 365.25;
    const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
    var secs = (str) => {
        const matched = REGEX.exec(str);
        if (!matched || (matched[4] && matched[1])) {
            throw new TypeError('Invalid time period format');
        }
        const value = parseFloat(matched[2]);
        const unit = matched[3].toLowerCase();
        let numericDate;
        switch (unit) {
            case 'sec':
            case 'secs':
            case 'second':
            case 'seconds':
            case 's':
                numericDate = Math.round(value);
                break;
            case 'minute':
            case 'minutes':
            case 'min':
            case 'mins':
            case 'm':
                numericDate = Math.round(value * minute);
                break;
            case 'hour':
            case 'hours':
            case 'hr':
            case 'hrs':
            case 'h':
                numericDate = Math.round(value * hour);
                break;
            case 'day':
            case 'days':
            case 'd':
                numericDate = Math.round(value * day);
                break;
            case 'week':
            case 'weeks':
            case 'w':
                numericDate = Math.round(value * week);
                break;
            default:
                numericDate = Math.round(value * year);
                break;
        }
        if (matched[1] === '-' || matched[4] === 'ago') {
            return -numericDate;
        }
        return numericDate;
    };

    const sign = async (alg, key, data) => {
        const cryptoKey = await getCryptoKey(alg, key, 'sign');
        checkKeyLength(alg, cryptoKey);
        const signature = await crypto$1.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
        return new Uint8Array(signature);
    };

    class FlattenedSign {
        constructor(payload) {
            if (!(payload instanceof Uint8Array)) {
                throw new TypeError('payload must be an instance of Uint8Array');
            }
            this._payload = payload;
        }
        setProtectedHeader(protectedHeader) {
            if (this._protectedHeader) {
                throw new TypeError('setProtectedHeader can only be called once');
            }
            this._protectedHeader = protectedHeader;
            return this;
        }
        setUnprotectedHeader(unprotectedHeader) {
            if (this._unprotectedHeader) {
                throw new TypeError('setUnprotectedHeader can only be called once');
            }
            this._unprotectedHeader = unprotectedHeader;
            return this;
        }
        async sign(key, options) {
            if (!this._protectedHeader && !this._unprotectedHeader) {
                throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
            }
            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {
                throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
            }
            const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
            };
            const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this._protectedHeader, joseHeader);
            let b64 = true;
            if (extensions.has('b64')) {
                b64 = this._protectedHeader.b64;
                if (typeof b64 !== 'boolean') {
                    throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
                }
            }
            const { alg } = joseHeader;
            if (typeof alg !== 'string' || !alg) {
                throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
            }
            checkKeyType(alg, key, 'sign');
            let payload = this._payload;
            if (b64) {
                payload = encoder.encode(encode(payload));
            }
            let protectedHeader;
            if (this._protectedHeader) {
                protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
            }
            else {
                protectedHeader = encoder.encode('');
            }
            const data = concat(protectedHeader, encoder.encode('.'), payload);
            const signature = await sign(alg, key, data);
            const jws = {
                signature: encode(signature),
                payload: '',
            };
            if (b64) {
                jws.payload = decoder.decode(payload);
            }
            if (this._unprotectedHeader) {
                jws.header = this._unprotectedHeader;
            }
            if (this._protectedHeader) {
                jws.protected = decoder.decode(protectedHeader);
            }
            return jws;
        }
    }

    class CompactSign {
        constructor(payload) {
            this._flattened = new FlattenedSign(payload);
        }
        setProtectedHeader(protectedHeader) {
            this._flattened.setProtectedHeader(protectedHeader);
            return this;
        }
        async sign(key, options) {
            const jws = await this._flattened.sign(key, options);
            if (jws.payload === undefined) {
                throw new TypeError('use the flattened module for creating JWS with b64: false');
            }
            return `${jws.protected}.${jws.payload}.${jws.signature}`;
        }
    }

    function validateInput(label, input) {
        if (!Number.isFinite(input)) {
            throw new TypeError(`Invalid ${label} input`);
        }
        return input;
    }
    class ProduceJWT {
        constructor(payload = {}) {
            if (!isObject(payload)) {
                throw new TypeError('JWT Claims Set MUST be an object');
            }
            this._payload = payload;
        }
        setIssuer(issuer) {
            this._payload = { ...this._payload, iss: issuer };
            return this;
        }
        setSubject(subject) {
            this._payload = { ...this._payload, sub: subject };
            return this;
        }
        setAudience(audience) {
            this._payload = { ...this._payload, aud: audience };
            return this;
        }
        setJti(jwtId) {
            this._payload = { ...this._payload, jti: jwtId };
            return this;
        }
        setNotBefore(input) {
            if (typeof input === 'number') {
                this._payload = { ...this._payload, nbf: validateInput('setNotBefore', input) };
            }
            else if (input instanceof Date) {
                this._payload = { ...this._payload, nbf: validateInput('setNotBefore', epoch(input)) };
            }
            else {
                this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };
            }
            return this;
        }
        setExpirationTime(input) {
            if (typeof input === 'number') {
                this._payload = { ...this._payload, exp: validateInput('setExpirationTime', input) };
            }
            else if (input instanceof Date) {
                this._payload = { ...this._payload, exp: validateInput('setExpirationTime', epoch(input)) };
            }
            else {
                this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };
            }
            return this;
        }
        setIssuedAt(input) {
            if (typeof input === 'undefined') {
                this._payload = { ...this._payload, iat: epoch(new Date()) };
            }
            else if (input instanceof Date) {
                this._payload = { ...this._payload, iat: validateInput('setIssuedAt', epoch(input)) };
            }
            else if (typeof input === 'string') {
                this._payload = {
                    ...this._payload,
                    iat: validateInput('setIssuedAt', epoch(new Date()) + secs(input)),
                };
            }
            else {
                this._payload = { ...this._payload, iat: validateInput('setIssuedAt', input) };
            }
            return this;
        }
    }

    class SignJWT extends ProduceJWT {
        setProtectedHeader(protectedHeader) {
            this._protectedHeader = protectedHeader;
            return this;
        }
        async sign(key, options) {
            const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
            sig.setProtectedHeader(this._protectedHeader);
            if (Array.isArray(this._protectedHeader?.crit) &&
                this._protectedHeader.crit.includes('b64') &&
                this._protectedHeader.b64 === false) {
                throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
            }
            return sig.sign(key, options);
        }
    }

    var _Hash_hash, _Hash_chunks;
    function isBrowser() {
        return (typeof window === 'object' && typeof document === 'object' && window.crypto);
    }
    function getUuid() {
        return v4();
    }
    function hexToBase64(data) {
        return buffer.Buffer.from(data, 'hex').toString('base64');
    }
    // using wrappers for date/datetime because of inability to export built-in Date types
    class DateWrapper {
        constructor(value) {
            this.value = value;
        }
    }
    class DateTimeWrapper {
        constructor(value) {
            this.value = value;
        }
    }
    function dateFromString(value) {
        return new DateWrapper(new Date(value));
    }
    function dateToString(date) {
        return date.value.toISOString().match(/^\d{4}-\d{2}-\d{2}/)[0];
    }
    function dateTimeFromString(value) {
        return new DateTimeWrapper(new Date(value));
    }
    function dateTimeToString(dateTime) {
        return (dateTime.value
            .toISOString()
            .match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)[0] + '+00:00');
    }
    // Function to convert a hexadecimal string to base64
    function hexStrToBase64(hex) {
        const hexString = hex.toString(); // Ensure the input is a string
        const hexBytes = new Uint8Array(hexString.length / 2);
        // Convert the hexadecimal string to bytes
        for (let i = 0; i < hexString.length; i += 2) {
            hexBytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
        }
        // Encode the bytes as base64
        const base64 = btoa(String.fromCharCode.apply(null, Array.from(hexBytes)));
        return base64;
    }
    class Hash {
        constructor({ algorithm }) {
            _Hash_hash.set(this, void 0);
            _Hash_chunks.set(this, void 0); // In browser environment, we need to buffer the chunks until we get the hash object
            this.algorithm = algorithm;
            __classPrivateFieldSet(this, _Hash_chunks, new Uint8Array(), "f");
            if (isBrowser()) {
                __classPrivateFieldSet(this, _Hash_hash, undefined, "f");
            }
            else {
                __classPrivateFieldSet(this, _Hash_hash, eval('require')('crypto').createHash(algorithm), "f");
            }
        }
        updateHash(data) {
            if (isBrowser()) {
                let dataBuffer = typeof data === 'string' ? new TextEncoder().encode(data) : data;
                let newChunks = new Uint8Array(__classPrivateFieldGet(this, _Hash_chunks, "f").length + dataBuffer.length);
                newChunks.set(__classPrivateFieldGet(this, _Hash_chunks, "f"));
                newChunks.set(dataBuffer, __classPrivateFieldGet(this, _Hash_chunks, "f").length);
                __classPrivateFieldSet(this, _Hash_chunks, newChunks, "f");
                return;
            }
            __classPrivateFieldGet(this, _Hash_hash, "f").update(data);
        }
        digestHash(encoding) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isBrowser()) {
                    __classPrivateFieldSet(this, _Hash_hash, yield window.crypto.subtle.digest(this.algorithm, __classPrivateFieldGet(this, _Hash_chunks, "f")), "f");
                    const hashArray = Array.from(new Uint8Array(__classPrivateFieldGet(this, _Hash_hash, "f")));
                    const hashHex = hashArray
                        .map((b) => b.toString(16).padStart(2, '0'))
                        .join('');
                    if (encoding === 'base64') {
                        return hexStrToBase64(hashHex);
                    }
                    return hashHex;
                }
                return __classPrivateFieldGet(this, _Hash_hash, "f").digest(encoding);
            });
        }
    }
    _Hash_hash = new WeakMap(), _Hash_chunks = new WeakMap();
    function generateByteStreamFromBuffer(buffer$1) {
        return isBrowser()
            ? new ReadableStream({
                start(controller) {
                    controller.enqueue(new Uint8Array(buffer$1));
                    controller.close();
                },
            })
            : eval('require')('stream').Readable.from(buffer.Buffer.from(buffer$1));
    }
    function bufferLength(buffer) {
        return buffer.length;
    }
    function readByteStream(byteStream) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, byteStream_1, byteStream_1_1;
            var _b, e_1, _c, _d;
            const buffers = [];
            try {
                for (_a = true, byteStream_1 = __asyncValues(byteStream); byteStream_1_1 = yield byteStream_1.next(), _b = byteStream_1_1.done, !_b; _a = true) {
                    _d = byteStream_1_1.value;
                    _a = false;
                    const data = _d;
                    buffers.push(data);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_a && !_b && (_c = byteStream_1.return)) yield _c.call(byteStream_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return buffer.Buffer.concat(buffers);
        });
    }
    function iterateChunks(stream, chunkSize, fileSize) {
        return __asyncGenerator(this, arguments, function* iterateChunks_1() {
            var _a, e_2, _b, _c;
            let buffers = [];
            let totalSize = 0;
            let consumedSize = 0;
            let chunkCnt = 0;
            while (consumedSize < fileSize && !stream.readableEnded) {
                try {
                    for (var _d = true, stream_1 = (e_2 = void 0, __asyncValues(stream)), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true) {
                        _c = stream_1_1.value;
                        _d = false;
                        const data = _c;
                        if (!buffer.Buffer.isBuffer(data)) {
                            throw new Error('Expecting a chunk of stream to be a Buffer');
                        }
                        consumedSize += data.length;
                        buffers.push(data);
                        totalSize += data.length;
                        if (totalSize < chunkSize) {
                            continue;
                        }
                        const buffer$1 = buffer.Buffer.concat(buffers);
                        let start = 0;
                        while (totalSize >= chunkSize) {
                            yield yield __await(generateByteStreamFromBuffer(buffer$1.subarray(start, start + chunkSize)));
                            console.log(`Chunk number ${chunkCnt++}`);
                            start += chunkSize;
                            totalSize -= chunkSize;
                        }
                        buffers = totalSize > 0 ? [buffer$1.subarray(start)] : [];
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = stream_1.return)) yield __await(_b.call(stream_1));
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (consumedSize !== fileSize) {
                throw new Error(`Stream size ${consumedSize} does not match expected file size ${fileSize}`);
            }
            if (totalSize > 0) {
                yield yield __await(generateByteStreamFromBuffer(buffer.Buffer.concat(buffers)));
            }
        });
    }
    function reduceIterator(iterator, reducer, initialValue) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = initialValue;
            let iteration = yield iterator.next();
            while (!iteration.done) {
                result = yield reducer(result, iteration.value);
                iteration = yield iterator.next();
            }
            return result;
        });
    }
    function prepareParams(map) {
        if (!map || typeof map !== 'object') {
            throw new Error('Expecting obj to be an object in prepareParams');
        }
        return Object.fromEntries(Object.entries(map).filter((entry) => typeof entry[1] === 'string'));
    }
    function toString(value) {
        if (typeof value === 'string' || value == null) {
            return value;
        }
        return String(value);
    }
    /**
     * Creates a JWT assertion.
     *
     * @param claims
     * @param key
     * @param options
     * @returns
     */
    function createJwtAssertion(claims, key, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const crypto = eval('require')('crypto');
            const privateKey = crypto.createPrivateKey({
                key: key.key,
                format: 'pem',
                type: 'pkcs8',
                passphrase: key.passphrase,
            });
            const pem = privateKey.export({ type: 'pkcs8', format: 'pem' }).toString();
            const pkcs8 = yield importPKCS8(pem, options.algorithm || 'RS256');
            let signer = new SignJWT(claims);
            signer = options.audience ? signer.setAudience(options.audience) : signer;
            signer = options.expiresIn
                ? signer.setExpirationTime(options.expiresIn)
                : signer;
            signer = options.issuer ? signer.setIssuer(options.issuer) : signer;
            signer = options.jwtid ? signer.setJti(options.jwtid) : signer;
            signer = options.notBefore ? signer.setNotBefore(options.notBefore) : signer;
            signer = options.subject ? signer.setSubject(options.subject) : signer;
            signer = options.algorithm
                ? signer.setProtectedHeader({ alg: options.algorithm })
                : signer;
            signer = signer.setIssuedAt();
            return yield signer.sign(pkcs8);
        });
    }
    /**
     * Reads a text file and returns its content.
     */
    function readTextFromFile(filepath) {
        return eval('require')('fs').readFileSync(filepath, 'utf8');
    }
    /**
     * Get current epoch time in seconds.
     */
    function getEpochTimeInSeconds() {
        return Math.floor(Date.now() / 1000);
    }
    /**
     * Create web agent from proxy agent options.
     */
    function createAgent(options) {
        if (isBrowser()) {
            return undefined;
        }
        const ProxyAgent = eval('require')('proxy-agent').ProxyAgent;
        return options ? new ProxyAgent(options) : new ProxyAgent();
    }

    class NetworkSession {
        constructor(fields) {
            this.additionalHeaders = {};
            this.baseUrls = new BaseUrls({});
            this.interceptors = [];
            this.agent = createAgent(void 0);
            if (fields.additionalHeaders) {
                this.additionalHeaders = fields.additionalHeaders;
            }
            if (fields.baseUrls) {
                this.baseUrls = fields.baseUrls;
            }
            if (fields.interceptors) {
                this.interceptors = fields.interceptors;
            }
            if (fields.agent) {
                this.agent = fields.agent;
            }
            if (fields.agentOptions) {
                this.agentOptions = fields.agentOptions;
            }
        }
        withAdditionalHeaders(additionalHeaders = {}) {
            return new NetworkSession({
                additionalHeaders: Object.assign(Object.assign({}, this.additionalHeaders), additionalHeaders),
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: this.agent,
                agentOptions: this.agentOptions,
            });
        }
        withCustomBaseUrls(baseUrls) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: baseUrls,
                interceptors: this.interceptors,
                agent: this.agent,
                agentOptions: this.agentOptions,
            });
        }
        withCustomAgentOptions(agentOptions) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: createAgent(agentOptions),
                agentOptions: this.agentOptions,
            });
        }
        withInterceptors(interceptors) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors.concat(interceptors),
                agent: this.agent,
                agentOptions: this.agentOptions,
            });
        }
    }

    class InMemoryTokenStorage {
        constructor(fields) {
            this.token = void 0;
            if (fields.token) {
                this.token = fields.token;
            }
        }
        store(token) {
            return __awaiter(this, void 0, void 0, function* () {
                this.token = token;
                return void 0;
            });
        }
        get() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.token;
            });
        }
        clear() {
            return __awaiter(this, void 0, void 0, function* () {
                this.token = void 0;
                return void 0;
            });
        }
    }

    function serializeFileBaseTypeField(val) {
        return val;
    }
    function deserializeFileBaseTypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileBaseTypeField" });
    }
    function serializeFileBase(val) {
        return {
            ['id']: val.id,
            ['etag']: val.etag == void 0 ? void 0 : val.etag,
            ['type']: serializeFileBaseTypeField(val.type),
        };
    }
    function deserializeFileBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileBase"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileBase"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileBase"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileBase" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return { id: id, etag: etag, type: type };
    }

    function deserializeFileVersionBaseTypeField(val) {
        if (val == 'file_version') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionBaseTypeField",
        });
    }

    function deserializeFileVersionMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileVersionMini"' });
        }
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileVersionMini"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileVersionMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileVersionMini" to be defined',
            });
        }
        const type = deserializeFileVersionBaseTypeField(val.type);
        return { sha1: sha1, id: id, type: type };
    }

    function deserializeFileMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileMini"' });
        }
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FileMini"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileMini"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileMini"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileMini"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileMini" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return {
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function serializeFolderBaseTypeField(val) {
        return val;
    }
    function deserializeFolderBaseTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FolderBaseTypeField" });
    }
    function serializeFolderBase(val) {
        return {
            ['id']: val.id,
            ['etag']: val.etag == void 0 ? void 0 : val.etag,
            ['type']: serializeFolderBaseTypeField(val.type),
        };
    }

    function serializeFolderMini(val) {
        const base = serializeFolderBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderMini"' });
        }
        return Object.assign(Object.assign({}, base), {
            ['sequence_id']: val.sequenceId == void 0 ? void 0 : val.sequenceId,
            ['name']: val.name == void 0 ? void 0 : val.name,
        });
    }
    function deserializeFolderMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderMini"' });
        }
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FolderMini"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FolderMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FolderMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderMini"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FolderMini"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FolderMini" to be defined',
            });
        }
        const type = deserializeFolderBaseTypeField(val.type);
        return {
            sequenceId: sequenceId,
            name: name,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function deserializeFileMiniOrFolderMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileMiniOrFolderMini"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileMini(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderMini(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize FileMiniOrFolderMini" });
    }

    function deserializeFileOrFolderScopeScopeField(val) {
        if (val == 'annotation_edit') {
            return val;
        }
        if (val == 'annotation_view_all') {
            return val;
        }
        if (val == 'annotation_view_self') {
            return val;
        }
        if (val == 'base_explorer') {
            return val;
        }
        if (val == 'base_picker') {
            return val;
        }
        if (val == 'base_preview') {
            return val;
        }
        if (val == 'base_upload') {
            return val;
        }
        if (val == 'item_delete') {
            return val;
        }
        if (val == 'item_download') {
            return val;
        }
        if (val == 'item_preview') {
            return val;
        }
        if (val == 'item_rename') {
            return val;
        }
        if (val == 'item_share') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileOrFolderScopeScopeField",
        });
    }
    function deserializeFileOrFolderScope(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileOrFolderScope"',
            });
        }
        const scope = val.scope == void 0
            ? void 0
            : deserializeFileOrFolderScopeScopeField(val.scope);
        const object = val.object == void 0 ? void 0 : deserializeFileMiniOrFolderMini(val.object);
        return { scope: scope, object: object };
    }

    function deserializeAccessTokenTokenTypeField(val) {
        if (val == 'bearer') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AccessTokenTokenTypeField",
        });
    }
    function deserializeAccessTokenIssuedTokenTypeField(val) {
        if (val == 'urn:ietf:params:oauth:token-type:access_token') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AccessTokenIssuedTokenTypeField",
        });
    }
    function deserializeAccessToken(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AccessToken"' });
        }
        if (!(val.access_token == void 0) && !sdIsString(val.access_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_token" of type "AccessToken"',
            });
        }
        const accessToken = val.access_token == void 0 ? void 0 : val.access_token;
        if (!(val.expires_in == void 0) && !sdIsNumber(val.expires_in)) {
            throw new BoxSdkError({
                message: 'Expecting number for "expires_in" of type "AccessToken"',
            });
        }
        const expiresIn = val.expires_in == void 0 ? void 0 : val.expires_in;
        const tokenType = val.token_type == void 0
            ? void 0
            : deserializeAccessTokenTokenTypeField(val.token_type);
        if (!(val.restricted_to == void 0) && !sdIsList(val.restricted_to)) {
            throw new BoxSdkError({
                message: 'Expecting array for "restricted_to" of type "AccessToken"',
            });
        }
        const restrictedTo = val.restricted_to == void 0
            ? void 0
            : sdIsList(val.restricted_to)
                ? val.restricted_to.map(function (itm) {
                    return deserializeFileOrFolderScope(itm);
                })
                : [];
        if (!(val.refresh_token == void 0) && !sdIsString(val.refresh_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "refresh_token" of type "AccessToken"',
            });
        }
        const refreshToken = val.refresh_token == void 0 ? void 0 : val.refresh_token;
        const issuedTokenType = val.issued_token_type == void 0
            ? void 0
            : deserializeAccessTokenIssuedTokenTypeField(val.issued_token_type);
        return {
            accessToken: accessToken,
            expiresIn: expiresIn,
            tokenType: tokenType,
            restrictedTo: restrictedTo,
            refreshToken: refreshToken,
            issuedTokenType: issuedTokenType,
        };
    }

    function serializePostOAuth2TokenGrantTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenSubjectTokenTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenActorTokenTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenBoxSubjectTypeField(val) {
        return val;
    }
    function serializePostOAuth2Token(val) {
        return {
            ['grant_type']: serializePostOAuth2TokenGrantTypeField(val.grantType),
            ['client_id']: val.clientId == void 0 ? void 0 : val.clientId,
            ['client_secret']: val.clientSecret == void 0 ? void 0 : val.clientSecret,
            ['code']: val.code == void 0 ? void 0 : val.code,
            ['refresh_token']: val.refreshToken == void 0 ? void 0 : val.refreshToken,
            ['assertion']: val.assertion == void 0 ? void 0 : val.assertion,
            ['subject_token']: val.subjectToken == void 0 ? void 0 : val.subjectToken,
            ['subject_token_type']: val.subjectTokenType == void 0
                ? void 0
                : serializePostOAuth2TokenSubjectTokenTypeField(val.subjectTokenType),
            ['actor_token']: val.actorToken == void 0 ? void 0 : val.actorToken,
            ['actor_token_type']: val.actorTokenType == void 0
                ? void 0
                : serializePostOAuth2TokenActorTokenTypeField(val.actorTokenType),
            ['scope']: val.scope == void 0 ? void 0 : val.scope,
            ['resource']: val.resource == void 0 ? void 0 : val.resource,
            ['box_subject_type']: val.boxSubjectType == void 0
                ? void 0
                : serializePostOAuth2TokenBoxSubjectTypeField(val.boxSubjectType),
            ['box_subject_id']: val.boxSubjectId == void 0 ? void 0 : val.boxSubjectId,
            ['box_shared_link']: val.boxSharedLink == void 0 ? void 0 : val.boxSharedLink,
        };
    }

    class PostOAuth2TokenRefreshAccessToken {
        constructor(fields) {
            this.grantType = 'refresh_token';
            if (fields.grantType) {
                this.grantType = fields.grantType;
            }
            if (fields.clientId) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.refreshToken) {
                this.refreshToken = fields.refreshToken;
            }
        }
    }
    function serializePostOAuth2TokenRefreshAccessTokenGrantTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenRefreshAccessToken(val) {
        return {
            ['grant_type']: serializePostOAuth2TokenRefreshAccessTokenGrantTypeField(val.grantType),
            ['client_id']: val.clientId,
            ['client_secret']: val.clientSecret,
            ['refresh_token']: val.refreshToken,
        };
    }

    function serializePostOAuth2Revoke(val) {
        return {
            ['client_id']: val.clientId == void 0 ? void 0 : val.clientId,
            ['client_secret']: val.clientSecret == void 0 ? void 0 : val.clientSecret,
            ['token']: val.token == void 0 ? void 0 : val.token,
        };
    }

    var browser = {exports: {}};

    (function (module, exports) {

    	// ref: https://github.com/tc39/proposal-global
    	var getGlobal = function () {
    		// the only reliable means to get the global object is
    		// `Function('return this')()`
    		// However, this causes CSP violations in Chrome apps.
    		if (typeof self !== 'undefined') { return self; }
    		if (typeof window !== 'undefined') { return window; }
    		if (typeof commonjsGlobal !== 'undefined') { return commonjsGlobal; }
    		throw new Error('unable to locate global object');
    	};

    	var globalObject = getGlobal();

    	module.exports = exports = globalObject.fetch;

    	// Needed for TypeScript and Webpack.
    	if (globalObject.fetch) {
    		exports.default = globalObject.fetch.bind(globalObject);
    	}

    	exports.Headers = globalObject.Headers;
    	exports.Request = globalObject.Request;
    	exports.Response = globalObject.Response; 
    } (browser, browser.exports));

    var browserExports = browser.exports;
    var nodeFetch = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

    const sdkVersion = '1.2.0';

    // Retry intervals are between 50% and 150% of the exponentially increasing base amount
    const RETRY_RANDOMIZATION_FACTOR = 0.5;
    /**
     * Calculate the exponential backoff time with randomized jitter
     * @param {int} numRetries Which retry number this one will be
     * @param {int} baseInterval The base retry interval set in config
     * @returns {int} The number of milliseconds after which to retry
     */
    function getRetryTimeout(numRetries, baseInterval) {
        var minRandomization = 1 - RETRY_RANDOMIZATION_FACTOR;
        var maxRandomization = 1 + RETRY_RANDOMIZATION_FACTOR;
        var randomization = Math.random() * (maxRandomization - minRandomization) + minRandomization;
        var exponential = Math.pow(2, numRetries - 1);
        return Math.ceil(exponential * baseInterval * randomization);
    }

    const userAgentHeader = `Box JavaScript generated SDK v${sdkVersion} (${isBrowser() ? navigator.userAgent : `Node ${process.version}`})`;
    const xBoxUaHeader = constructBoxUAHeader();
    function createRequestInit(options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const { method = 'GET', headers = {}, contentType: contentTypeInput = 'application/json', data, fileStream, } = options;
            const { contentType, body } = yield (() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (options.multipartData) {
                    const FormData = isBrowser()
                        ? window.FormData
                        : eval('require')('form-data');
                    const formData = new FormData();
                    for (const item of options.multipartData) {
                        if (item.fileStream) {
                            const buffer = yield readByteStream(item.fileStream);
                            const blob = isBrowser() ? new Blob([buffer]) : buffer;
                            headers['content-md5'] = yield calculateMD5Hash(buffer);
                            formData.append(item.partName, blob, {
                                filename: (_a = item.fileName) !== null && _a !== void 0 ? _a : 'file',
                                contentType: (_b = item.contentType) !== null && _b !== void 0 ? _b : 'application/octet-stream',
                            });
                        }
                        else if (item.data) {
                            formData.append(item.partName, sdToJson(item.data));
                        }
                        else {
                            throw new BoxSdkError({
                                message: 'Multipart item must have either body or fileStream',
                            });
                        }
                    }
                    return {
                        contentType: !isBrowser()
                            ? `multipart/form-data; boundary=${formData.getBoundary()}`
                            : undefined,
                        body: formData,
                    };
                }
                const contentType = contentTypeInput;
                switch (contentType) {
                    case 'application/json':
                    case 'application/json-patch+json':
                        return { contentType, body: sdToJson(data) };
                    case 'application/x-www-form-urlencoded':
                        return { contentType, body: sdToUrlParams(data) };
                    case 'application/octet-stream':
                        if (!fileStream) {
                            throw new BoxSdkError({
                                message: 'fileStream required for application/octet-stream content type',
                            });
                        }
                        return { contentType, body: fileStream };
                    default:
                        throw new BoxSdkError({
                            message: `Unsupported content type : ${contentType}`,
                        });
                }
            }))();
            return {
                method,
                headers: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (contentType && { 'Content-Type': contentType })), headers), (options.auth && {
                    Authorization: yield options.auth.retrieveAuthorizationHeader(options.networkSession),
                })), { 'User-Agent': userAgentHeader, 'X-Box-UA': xBoxUaHeader }), (_a = options.networkSession) === null || _a === void 0 ? void 0 : _a.additionalHeaders),
                body,
                signal: options.cancellationToken,
                agent: (_b = options.networkSession) === null || _b === void 0 ? void 0 : _b.agent,
            };
        });
    }
    const DEFAULT_MAX_ATTEMPTS = 5;
    const RETRY_BASE_INTERVAL = 1;
    const STATUS_CODE_ACCEPTED = 202, STATUS_CODE_UNAUTHORIZED = 401, STATUS_CODE_TOO_MANY_REQUESTS = 429;
    function fetch(resource, options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const fetchOptions = ((_b = (_a = options.networkSession) === null || _a === void 0 ? void 0 : _a.interceptors) === null || _b === void 0 ? void 0 : _b.length)
                ? (_c = options.networkSession) === null || _c === void 0 ? void 0 : _c.interceptors.reduce((modifiedOptions, interceptor) => interceptor.beforeRequest(modifiedOptions), options)
                : options;
            const requestInit = yield createRequestInit(fetchOptions);
            const { params = {} } = fetchOptions;
            const response = yield nodeFetch(''.concat(resource, Object.keys(params).length === 0 || resource.endsWith('?') ? '' : '?', new URLSearchParams(params).toString()), Object.assign(Object.assign({}, requestInit), { redirect: 'manual' }));
            const contentType = (_d = response.headers.get('content-type')) !== null && _d !== void 0 ? _d : '';
            const responseBytesBuffer = yield response.arrayBuffer();
            const data = (() => {
                if (contentType.includes('application/json')) {
                    const text = new TextDecoder().decode(responseBytesBuffer);
                    return jsonToSerializedData(text);
                }
                return void 0;
            })();
            const content = generateByteStreamFromBuffer(responseBytesBuffer);
            let fetchResponse = {
                status: response.status,
                data,
                content,
                headers: Object.fromEntries(Array.from(response.headers.entries())),
            };
            if ((_f = (_e = fetchOptions.networkSession) === null || _e === void 0 ? void 0 : _e.interceptors) === null || _f === void 0 ? void 0 : _f.length) {
                fetchResponse = (_g = fetchOptions.networkSession) === null || _g === void 0 ? void 0 : _g.interceptors.reduce((modifiedResponse, interceptor) => interceptor.afterRequest(modifiedResponse), fetchResponse);
            }
            if (fetchResponse.status >= 300 && fetchResponse.status < 400) {
                if (!fetchResponse.headers['location']) {
                    throw new BoxSdkError({
                        message: `Unable to follow redirect for ${resource}`,
                    });
                }
                return fetch(fetchResponse.headers['location'], options);
            }
            const acceptedWithRetryAfter = fetchResponse.status === STATUS_CODE_ACCEPTED &&
                fetchResponse.headers['retry-after'];
            if (fetchResponse.status >= 400 || acceptedWithRetryAfter) {
                const { numRetries = 0 } = fetchOptions;
                const reauthenticationNeeded = fetchResponse.status == STATUS_CODE_UNAUTHORIZED;
                if (reauthenticationNeeded && fetchOptions.auth) {
                    yield fetchOptions.auth.refreshToken(fetchOptions.networkSession);
                    // retry the request right away
                    return fetch(resource, Object.assign(Object.assign({}, fetchOptions), { numRetries: numRetries + 1 }));
                }
                const isRetryable = fetchOptions.contentType !== 'application/x-www-form-urlencoded' &&
                    (fetchResponse.status === STATUS_CODE_TOO_MANY_REQUESTS ||
                        acceptedWithRetryAfter ||
                        fetchResponse.status >= 500);
                if (isRetryable && numRetries < DEFAULT_MAX_ATTEMPTS) {
                    const retryTimeout = fetchResponse.headers['retry-after']
                        ? parseFloat(fetchResponse.headers['retry-after']) * 1000
                        : getRetryTimeout(numRetries, RETRY_BASE_INTERVAL * 1000);
                    yield new Promise((resolve) => setTimeout(resolve, retryTimeout));
                    return fetch(resource, Object.assign(Object.assign({}, fetchOptions), { numRetries: numRetries + 1 }));
                }
                const [code, contextInfo, requestId, helpUrl] = sdIsMap(fetchResponse.data)
                    ? [
                        sdToJson(fetchResponse.data['code']),
                        sdIsMap(fetchResponse.data['context_info'])
                            ? fetchResponse.data['context_info']
                            : undefined,
                        sdToJson(fetchResponse.data['request_id']),
                        sdToJson(fetchResponse.data['help_url']),
                    ]
                    : [];
                throw new BoxApiError({
                    message: `${fetchResponse.status}`,
                    timestamp: `${Date.now()}`,
                    requestInfo: {
                        method: requestInit.method,
                        url: resource,
                        queryParams: params,
                        headers: (_h = requestInit.headers) !== null && _h !== void 0 ? _h : {},
                        body: typeof requestInit.body === 'string' ? requestInit.body : undefined,
                    },
                    responseInfo: {
                        statusCode: fetchResponse.status,
                        headers: fetchResponse.headers,
                        body: fetchResponse.data,
                        rawBody: new TextDecoder().decode(responseBytesBuffer),
                        code: code,
                        contextInfo: contextInfo,
                        requestId: requestId,
                        helpUrl: helpUrl,
                    },
                    name: 'BoxApiError',
                });
            }
            return fetchResponse;
        });
    }
    function calculateMD5Hash(data) {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * Calculate the SHA1 hash of the data
             */
            let createHash;
            // Browser environment
            if (isBrowser()) {
                let dataBuffer = typeof data === 'string' ? new TextEncoder().encode(data) : data;
                let hashBuffer = yield window.crypto.subtle.digest('SHA-1', dataBuffer);
                let hashArray = Array.from(new Uint8Array(hashBuffer));
                let hashHex = hashArray
                    .map((b) => b.toString(16).padStart(2, '0'))
                    .join('');
                return hashHex;
            }
            // Node environment
            createHash = eval('require')('crypto').createHash;
            return createHash('sha1').update(data).digest('hex');
        });
    }
    function constructBoxUAHeader() {
        const analyticsIdentifiers = {
            agent: `box-javascript-generated-sdk/${sdkVersion}`,
            env: isBrowser()
                ? navigator.userAgent
                : `Node/${process.version.replace('v', '')}`,
        };
        return Object.keys(analyticsIdentifiers)
            .map((k) => `${k}=${analyticsIdentifiers[k]}`)
            .join('; ');
    }

    class AuthorizeUserOptionals {
        constructor(fields) {
            this.headers = new AuthorizeUserHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RequestAccessTokenOptionals {
        constructor(fields) {
            this.headers = new RequestAccessTokenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RefreshAccessTokenOptionals {
        constructor(fields) {
            this.headers = new RefreshAccessTokenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RevokeAccessTokenOptionals {
        constructor(fields) {
            this.headers = new RevokeAccessTokenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AuthorizeUserHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RequestAccessTokenHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RefreshAccessTokenHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RevokeAccessTokenHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AuthorizationManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        authorizeUser(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new AuthorizeUserOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['response_type']: toString(queryParams.responseType),
                    ['client_id']: toString(queryParams.clientId),
                    ['redirect_uri']: toString(queryParams.redirectUri),
                    ['state']: toString(queryParams.state),
                    ['scope']: toString(queryParams.scope),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.oauth2Url, '/authorize'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        requestAccessToken(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new RequestAccessTokenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/oauth2/token'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializePostOAuth2Token(requestBody),
                    contentType: 'application/x-www-form-urlencoded',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeAccessToken(response.data);
            });
        }
        refreshAccessToken(requestBodyInput_1) {
            return __awaiter(this, arguments, void 0, function* (requestBodyInput, optionalsInput = {}) {
                const requestBody = new PostOAuth2TokenRefreshAccessToken({
                    grantType: requestBodyInput.grantType,
                    clientId: requestBodyInput.clientId,
                    clientSecret: requestBodyInput.clientSecret,
                    refreshToken: requestBodyInput.refreshToken,
                });
                const optionals = new RefreshAccessTokenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/oauth2/token#refresh'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializePostOAuth2TokenRefreshAccessToken(requestBody),
                    contentType: 'application/x-www-form-urlencoded',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeAccessToken(response.data);
            });
        }
        revokeAccessToken(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new RevokeAccessTokenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/oauth2/revoke'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializePostOAuth2Revoke(requestBody),
                    contentType: 'application/x-www-form-urlencoded',
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }

    class CcgConfig {
        constructor(fields) {
            this.tokenStorage = new InMemoryTokenStorage({});
            if (fields.clientId) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.enterpriseId) {
                this.enterpriseId = fields.enterpriseId;
            }
            if (fields.userId) {
                this.userId = fields.userId;
            }
            if (fields.tokenStorage) {
                this.tokenStorage = fields.tokenStorage;
            }
        }
    }
    class BoxCcgAuth {
        constructor(fields) {
            if (fields.config) {
                this.config = fields.config;
            }
            this.tokenStorage = this.config.tokenStorage;
            this.subjectId = !(this.config.userId == void 0)
                ? this.config.userId
                : this.config.enterpriseId;
            this.subjectType = !(this.config.userId == void 0)
                ? 'user'
                : 'enterprise';
        }
        refreshToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'client_credentials',
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    boxSubjectType: this.subjectType,
                    boxSubjectId: this.subjectId,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        retrieveToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    const newToken = yield this.refreshToken(networkSession);
                    return newToken;
                }
                return oldToken;
            });
        }
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        withUserSubject(userId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new CcgConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: this.config.enterpriseId,
                userId: userId,
                tokenStorage: tokenStorage,
            });
            return new BoxCcgAuth({ config: newConfig });
        }
        withEnterpriseSubject(enterpriseId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new CcgConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: enterpriseId,
                userId: void 0,
                tokenStorage: tokenStorage,
            });
            return new BoxCcgAuth({ config: newConfig });
        }
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    throw new BoxSdkError({
                        message: 'No access token is available. Make an API call to retrieve a token before calling this method.',
                    });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    scope: scopes.join(' '),
                    resource: resource,
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
        revokeToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    token: oldToken.accessToken,
                });
                yield this.tokenStorage.clear();
                return void 0;
            });
        }
    }

    class BoxDeveloperTokenAuth {
        constructor(fields) {
            this.config = {};
            if (fields.token) {
                this.token = fields.token;
            }
            if (fields.config) {
                this.config = fields.config;
            }
            this.tokenStorage = new InMemoryTokenStorage({
                token: { accessToken: this.token },
            });
        }
        retrieveToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    throw new BoxSdkError({ message: 'No access token is available.' });
                }
                return token;
            });
        }
        refreshToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                throw new BoxSdkError({
                    message: 'Developer token has expired. Please provide a new one.',
                });
            });
        }
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        revokeToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    token: token.accessToken,
                });
                yield this.tokenStorage.clear();
                return void 0;
            });
        }
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0 || token.accessToken == void 0) {
                    throw new BoxSdkError({ message: 'No access token is available.' });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    scope: scopes.join(' '),
                    resource: resource,
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
    }

    class JwtConfig {
        constructor(fields) {
            this.algorithm = 'RS256';
            this.tokenStorage = new InMemoryTokenStorage({});
            if (fields.clientId) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.jwtKeyId) {
                this.jwtKeyId = fields.jwtKeyId;
            }
            if (fields.privateKey) {
                this.privateKey = fields.privateKey;
            }
            if (fields.privateKeyPassphrase) {
                this.privateKeyPassphrase = fields.privateKeyPassphrase;
            }
            if (fields.enterpriseId) {
                this.enterpriseId = fields.enterpriseId;
            }
            if (fields.userId) {
                this.userId = fields.userId;
            }
            if (fields.algorithm) {
                this.algorithm = fields.algorithm;
            }
            if (fields.tokenStorage) {
                this.tokenStorage = fields.tokenStorage;
            }
        }
        static fromConfigJsonString(configJsonString, tokenStorage) {
            const configJson = deserializeJwtConfigFile(jsonToSerializedData(configJsonString));
            const newConfig = !(tokenStorage == void 0)
                ? new JwtConfig({
                    clientId: configJson.boxAppSettings.clientId,
                    clientSecret: configJson.boxAppSettings.clientSecret,
                    enterpriseId: configJson.enterpriseId,
                    userId: configJson.userId,
                    jwtKeyId: configJson.boxAppSettings.appAuth.publicKeyId,
                    privateKey: configJson.boxAppSettings.appAuth.privateKey,
                    privateKeyPassphrase: configJson.boxAppSettings.appAuth.passphrase,
                    tokenStorage: tokenStorage,
                })
                : new JwtConfig({
                    clientId: configJson.boxAppSettings.clientId,
                    clientSecret: configJson.boxAppSettings.clientSecret,
                    enterpriseId: configJson.enterpriseId,
                    userId: configJson.userId,
                    jwtKeyId: configJson.boxAppSettings.appAuth.publicKeyId,
                    privateKey: configJson.boxAppSettings.appAuth.privateKey,
                    privateKeyPassphrase: configJson.boxAppSettings.appAuth.passphrase,
                });
            return newConfig;
        }
        static fromConfigFile(configFilePath, tokenStorage) {
            const configJsonString = readTextFromFile(configFilePath);
            return JwtConfig.fromConfigJsonString(configJsonString, tokenStorage);
        }
    }
    class BoxJwtAuth {
        constructor(fields) {
            if (fields.config) {
                this.config = fields.config;
            }
            this.tokenStorage = this.config.tokenStorage;
            this.subjectId = !(this.config.enterpriseId == void 0)
                ? this.config.enterpriseId
                : this.config.userId;
            this.subjectType = !(this.config.enterpriseId == void 0)
                ? 'enterprise'
                : 'user';
        }
        refreshToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isBrowser()) {
                    throw new BoxSdkError({
                        message: 'JWT auth is not supported in browser environment.',
                    });
                }
                const alg = !(this.config.algorithm == void 0)
                    ? this.config.algorithm
                    : 'RS256';
                const claims = {
                    ['exp']: getEpochTimeInSeconds() + 30,
                    ['box_sub_type']: this.subjectType,
                };
                const jwtOptions = {
                    algorithm: alg,
                    audience: 'https://api.box.com/oauth2/token',
                    subject: this.subjectId,
                    issuer: this.config.clientId,
                    jwtid: getUuid(),
                    keyid: this.config.jwtKeyId,
                };
                const jwtKey = {
                    key: this.config.privateKey,
                    passphrase: this.config.privateKeyPassphrase,
                };
                const assertion = yield createJwtAssertion(claims, jwtKey, jwtOptions);
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                    assertion: assertion,
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        retrieveToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    const newToken = yield this.refreshToken(networkSession);
                    return newToken;
                }
                return oldToken;
            });
        }
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        withUserSubject(userId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new JwtConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: void 0,
                userId: userId,
                jwtKeyId: this.config.jwtKeyId,
                privateKey: this.config.privateKey,
                privateKeyPassphrase: this.config.privateKeyPassphrase,
                tokenStorage: tokenStorage,
            });
            const newAuth = new BoxJwtAuth({ config: newConfig });
            return newAuth;
        }
        withEnterpriseSubject(userId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new JwtConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: userId,
                userId: void 0,
                jwtKeyId: this.config.jwtKeyId,
                privateKey: this.config.privateKey,
                privateKeyPassphrase: this.config.privateKeyPassphrase,
                tokenStorage: tokenStorage,
            });
            const newAuth = new BoxJwtAuth({ config: newConfig });
            return newAuth;
        }
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    throw new BoxSdkError({
                        message: 'No access token is available. Make an API call to retrieve a token before calling this method.',
                    });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    resource: resource,
                    scope: scopes.join(' '),
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
        revokeToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    token: oldToken.accessToken,
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                });
                yield this.tokenStorage.clear();
                return void 0;
            });
        }
    }
    function deserializeJwtConfigAppSettingsAppAuth(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "JwtConfigAppSettingsAppAuth"',
            });
        }
        if (val.publicKeyID == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "publicKeyID" of type "JwtConfigAppSettingsAppAuth" to be defined',
            });
        }
        if (!sdIsString(val.publicKeyID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "publicKeyID" of type "JwtConfigAppSettingsAppAuth"',
            });
        }
        const publicKeyId = val.publicKeyID;
        if (val.privateKey == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "privateKey" of type "JwtConfigAppSettingsAppAuth" to be defined',
            });
        }
        if (!sdIsString(val.privateKey)) {
            throw new BoxSdkError({
                message: 'Expecting string for "privateKey" of type "JwtConfigAppSettingsAppAuth"',
            });
        }
        const privateKey = val.privateKey;
        if (val.passphrase == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "passphrase" of type "JwtConfigAppSettingsAppAuth" to be defined',
            });
        }
        if (!sdIsString(val.passphrase)) {
            throw new BoxSdkError({
                message: 'Expecting string for "passphrase" of type "JwtConfigAppSettingsAppAuth"',
            });
        }
        const passphrase = val.passphrase;
        return {
            publicKeyId: publicKeyId,
            privateKey: privateKey,
            passphrase: passphrase,
        };
    }
    function deserializeJwtConfigAppSettings(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "JwtConfigAppSettings"',
            });
        }
        if (val.clientID == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "clientID" of type "JwtConfigAppSettings" to be defined',
            });
        }
        if (!sdIsString(val.clientID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "clientID" of type "JwtConfigAppSettings"',
            });
        }
        const clientId = val.clientID;
        if (val.clientSecret == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "clientSecret" of type "JwtConfigAppSettings" to be defined',
            });
        }
        if (!sdIsString(val.clientSecret)) {
            throw new BoxSdkError({
                message: 'Expecting string for "clientSecret" of type "JwtConfigAppSettings"',
            });
        }
        const clientSecret = val.clientSecret;
        if (val.appAuth == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "appAuth" of type "JwtConfigAppSettings" to be defined',
            });
        }
        const appAuth = deserializeJwtConfigAppSettingsAppAuth(val.appAuth);
        return {
            clientId: clientId,
            clientSecret: clientSecret,
            appAuth: appAuth,
        };
    }
    function deserializeJwtConfigFile(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "JwtConfigFile"' });
        }
        if (!(val.enterpriseID == void 0) && !sdIsString(val.enterpriseID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "enterpriseID" of type "JwtConfigFile"',
            });
        }
        const enterpriseId = val.enterpriseID == void 0 ? void 0 : val.enterpriseID;
        if (!(val.userID == void 0) && !sdIsString(val.userID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "userID" of type "JwtConfigFile"',
            });
        }
        const userId = val.userID == void 0 ? void 0 : val.userID;
        if (val.boxAppSettings == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "boxAppSettings" of type "JwtConfigFile" to be defined',
            });
        }
        const boxAppSettings = deserializeJwtConfigAppSettings(val.boxAppSettings);
        return {
            enterpriseId: enterpriseId,
            userId: userId,
            boxAppSettings: boxAppSettings,
        };
    }

    class OAuthConfig {
        constructor(fields) {
            this.tokenStorage = new InMemoryTokenStorage({});
            if (fields.clientId) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.tokenStorage) {
                this.tokenStorage = fields.tokenStorage;
            }
        }
    }
    class BoxOAuth {
        constructor(fields) {
            if (fields.config) {
                this.config = fields.config;
            }
            this.tokenStorage = this.config.tokenStorage;
        }
        getAuthorizeUrl(options = {}) {
            const paramsMap = prepareParams({
                ['client_id']: !(options.clientId == void 0)
                    ? options.clientId
                    : this.config.clientId,
                ['response_type']: !(options.responseType == void 0)
                    ? options.responseType
                    : 'code',
                ['redirect_uri']: options.redirectUri,
                ['state']: options.state,
                ['scope']: options.scope,
            });
            return ''.concat('https://account.box.com/api/oauth2/authorize?', sdToUrlParams(JSON.stringify(paramsMap)));
        }
        getTokensAuthorizationCodeGrant(authorizationCode, networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'authorization_code',
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    code: authorizationCode,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        retrieveToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    throw new BoxSdkError({
                        message: 'Access and refresh tokens not available. Authenticate before making any API call first.',
                    });
                }
                return token;
            });
        }
        refreshToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                const tokenUsedForRefresh = !(oldToken == void 0)
                    ? oldToken.refreshToken
                    : void 0;
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'refresh_token',
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    refreshToken: tokenUsedForRefresh,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        revokeToken(networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    token: token.accessToken,
                });
                return void 0;
            });
        }
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0 || token.accessToken == void 0) {
                    throw new BoxSdkError({ message: 'No access token is available.' });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    scope: scopes.join(' '),
                    resource: resource,
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
    }

    function serializeUserBaseTypeField(val) {
        return val;
    }
    function deserializeUserBaseTypeField(val) {
        if (val == 'user') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize UserBaseTypeField" });
    }
    function serializeUserBase(val) {
        return { ['id']: val.id, ['type']: serializeUserBaseTypeField(val.type) };
    }
    function deserializeUserBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserBase"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserBase"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserBase" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function serializeUserMini(val) {
        const base = serializeUserBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserMini"' });
        }
        return Object.assign(Object.assign({}, base), {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['login']: val.login == void 0 ? void 0 : val.login,
        });
    }
    function deserializeUserMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserMini"' });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserMini"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserMini" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return { name: name, login: login, id: id, type: type };
    }

    function deserializeFilePathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FilePathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "FilePathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "FilePathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "FilePathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FilePathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeFileSharedLinkAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileSharedLinkAccessField",
        });
    }
    function deserializeFileSharedLinkEffectiveAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileSharedLinkEffectiveAccessField",
        });
    }
    function deserializeFileSharedLinkEffectivePermissionField(val) {
        if (val == 'can_edit') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'no_access') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileSharedLinkEffectivePermissionField",
        });
    }
    function deserializeFileSharedLinkPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileSharedLinkPermissionsField"',
            });
        }
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FileSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FileSharedLinkPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_preview == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_preview" of type "FileSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "FileSharedLinkPermissionsField"',
            });
        }
        const canPreview = val.can_preview;
        if (val.can_edit == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_edit" of type "FileSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_edit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_edit" of type "FileSharedLinkPermissionsField"',
            });
        }
        const canEdit = val.can_edit;
        return {
            canDownload: canDownload,
            canPreview: canPreview,
            canEdit: canEdit,
        };
    }
    function deserializeFileSharedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileSharedLinkField"',
            });
        }
        if (val.url == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "url" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileSharedLinkField"',
            });
        }
        const url = val.url;
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "FileSharedLinkField"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.vanity_url == void 0) && !sdIsString(val.vanity_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_url" of type "FileSharedLinkField"',
            });
        }
        const vanityUrl = val.vanity_url == void 0 ? void 0 : val.vanity_url;
        if (!(val.vanity_name == void 0) && !sdIsString(val.vanity_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_name" of type "FileSharedLinkField"',
            });
        }
        const vanityName = val.vanity_name == void 0 ? void 0 : val.vanity_name;
        const access = val.access == void 0
            ? void 0
            : deserializeFileSharedLinkAccessField(val.access);
        if (val.effective_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_access" of type "FileSharedLinkField" to be defined',
            });
        }
        const effectiveAccess = deserializeFileSharedLinkEffectiveAccessField(val.effective_access);
        if (val.effective_permission == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_permission" of type "FileSharedLinkField" to be defined',
            });
        }
        const effectivePermission = deserializeFileSharedLinkEffectivePermissionField(val.effective_permission);
        if (!(val.unshared_at == void 0) && !sdIsString(val.unshared_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "unshared_at" of type "FileSharedLinkField"',
            });
        }
        const unsharedAt = val.unshared_at == void 0 ? void 0 : dateTimeFromString(val.unshared_at);
        if (val.is_password_enabled == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "is_password_enabled" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsBoolean(val.is_password_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_password_enabled" of type "FileSharedLinkField"',
            });
        }
        const isPasswordEnabled = val.is_password_enabled;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFileSharedLinkPermissionsField(val.permissions);
        if (val.download_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "download_count" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.download_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "download_count" of type "FileSharedLinkField"',
            });
        }
        const downloadCount = val.download_count;
        if (val.preview_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "preview_count" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.preview_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "preview_count" of type "FileSharedLinkField"',
            });
        }
        const previewCount = val.preview_count;
        return {
            url: url,
            downloadUrl: downloadUrl,
            vanityUrl: vanityUrl,
            vanityName: vanityName,
            access: access,
            effectiveAccess: effectiveAccess,
            effectivePermission: effectivePermission,
            unsharedAt: unsharedAt,
            isPasswordEnabled: isPasswordEnabled,
            permissions: permissions,
            downloadCount: downloadCount,
            previewCount: previewCount,
        };
    }
    function deserializeFileItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileItemStatusField" });
    }
    function deserializeFile(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "File"' });
        }
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "File"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "File"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFilePathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "File"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "File"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "File"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "File"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "File"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "File"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFileSharedLinkField(val.shared_link);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFileItemStatusField(val.item_status);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "File"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "File"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "File"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "File" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "File"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "File"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "File" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return {
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function deserializeMetadataBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "MetadataBase"' });
        }
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "MetadataBase"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        if (!(val.$template == void 0) && !sdIsString(val.$template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$template" of type "MetadataBase"',
            });
        }
        const template = val.$template == void 0 ? void 0 : val.$template;
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "MetadataBase"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "MetadataBase"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        return {
            parent: parent,
            template: template,
            scope: scope,
            version: version,
        };
    }

    function deserializeMetadata(val) {
        return deserializeMetadataBase(val);
    }

    function deserializeFileFullPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullPermissionsField"',
            });
        }
        if (val.can_delete == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_delete" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_delete)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_delete" of type "FileFullPermissionsField"',
            });
        }
        const canDelete = val.can_delete;
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FileFullPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_invite_collaborator == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_invite_collaborator" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_invite_collaborator)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_invite_collaborator" of type "FileFullPermissionsField"',
            });
        }
        const canInviteCollaborator = val.can_invite_collaborator;
        if (val.can_rename == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_rename" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_rename)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_rename" of type "FileFullPermissionsField"',
            });
        }
        const canRename = val.can_rename;
        if (val.can_set_share_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_set_share_access" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_set_share_access)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_set_share_access" of type "FileFullPermissionsField"',
            });
        }
        const canSetShareAccess = val.can_set_share_access;
        if (val.can_share == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_share" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_share)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_share" of type "FileFullPermissionsField"',
            });
        }
        const canShare = val.can_share;
        if (!(val.can_annotate == void 0) && !sdIsBoolean(val.can_annotate)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_annotate" of type "FileFullPermissionsField"',
            });
        }
        const canAnnotate = val.can_annotate == void 0 ? void 0 : val.can_annotate;
        if (!(val.can_comment == void 0) && !sdIsBoolean(val.can_comment)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_comment" of type "FileFullPermissionsField"',
            });
        }
        const canComment = val.can_comment == void 0 ? void 0 : val.can_comment;
        if (!(val.can_preview == void 0) && !sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "FileFullPermissionsField"',
            });
        }
        const canPreview = val.can_preview == void 0 ? void 0 : val.can_preview;
        if (!(val.can_upload == void 0) && !sdIsBoolean(val.can_upload)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_upload" of type "FileFullPermissionsField"',
            });
        }
        const canUpload = val.can_upload == void 0 ? void 0 : val.can_upload;
        if (!(val.can_view_annotations_all == void 0) &&
            !sdIsBoolean(val.can_view_annotations_all)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_view_annotations_all" of type "FileFullPermissionsField"',
            });
        }
        const canViewAnnotationsAll = val.can_view_annotations_all == void 0
            ? void 0
            : val.can_view_annotations_all;
        if (!(val.can_view_annotations_self == void 0) &&
            !sdIsBoolean(val.can_view_annotations_self)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_view_annotations_self" of type "FileFullPermissionsField"',
            });
        }
        const canViewAnnotationsSelf = val.can_view_annotations_self == void 0
            ? void 0
            : val.can_view_annotations_self;
        return {
            canDelete: canDelete,
            canDownload: canDownload,
            canInviteCollaborator: canInviteCollaborator,
            canRename: canRename,
            canSetShareAccess: canSetShareAccess,
            canShare: canShare,
            canAnnotate: canAnnotate,
            canComment: canComment,
            canPreview: canPreview,
            canUpload: canUpload,
            canViewAnnotationsAll: canViewAnnotationsAll,
            canViewAnnotationsSelf: canViewAnnotationsSelf,
        };
    }
    function deserializeFileFullLockTypeField(val) {
        if (val == 'lock') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileFullLockTypeField" });
    }
    function deserializeFileFullLockAppTypeField(val) {
        if (val == 'gsuite') {
            return val;
        }
        if (val == 'office_wopi') {
            return val;
        }
        if (val == 'office_wopiplus') {
            return val;
        }
        if (val == 'other') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullLockAppTypeField",
        });
    }
    function deserializeFileFullLockField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullLockField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileFullLockField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeFileFullLockTypeField(val.type);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileFullLockField"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.expired_at == void 0) && !sdIsString(val.expired_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expired_at" of type "FileFullLockField"',
            });
        }
        const expiredAt = val.expired_at == void 0 ? void 0 : dateTimeFromString(val.expired_at);
        if (!(val.is_download_prevented == void 0) &&
            !sdIsBoolean(val.is_download_prevented)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_download_prevented" of type "FileFullLockField"',
            });
        }
        const isDownloadPrevented = val.is_download_prevented == void 0 ? void 0 : val.is_download_prevented;
        const appType = val.app_type == void 0
            ? void 0
            : deserializeFileFullLockAppTypeField(val.app_type);
        return {
            id: id,
            type: type,
            createdBy: createdBy,
            createdAt: createdAt,
            expiredAt: expiredAt,
            isDownloadPrevented: isDownloadPrevented,
            appType: appType,
        };
    }
    function deserializeFileFullExpiringEmbedLinkTokenTypeField(val) {
        if (val == 'bearer') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullExpiringEmbedLinkTokenTypeField",
        });
    }
    function deserializeFileFullExpiringEmbedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullExpiringEmbedLinkField"',
            });
        }
        if (!(val.access_token == void 0) && !sdIsString(val.access_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_token" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const accessToken = val.access_token == void 0 ? void 0 : val.access_token;
        if (!(val.expires_in == void 0) && !sdIsNumber(val.expires_in)) {
            throw new BoxSdkError({
                message: 'Expecting number for "expires_in" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const expiresIn = val.expires_in == void 0 ? void 0 : val.expires_in;
        const tokenType = val.token_type == void 0
            ? void 0
            : deserializeFileFullExpiringEmbedLinkTokenTypeField(val.token_type);
        if (!(val.restricted_to == void 0) && !sdIsList(val.restricted_to)) {
            throw new BoxSdkError({
                message: 'Expecting array for "restricted_to" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const restrictedTo = val.restricted_to == void 0
            ? void 0
            : sdIsList(val.restricted_to)
                ? val.restricted_to.map(function (itm) {
                    return deserializeFileOrFolderScope(itm);
                })
                : [];
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        return {
            accessToken: accessToken,
            expiresIn: expiresIn,
            tokenType: tokenType,
            restrictedTo: restrictedTo,
            url: url,
        };
    }
    function deserializeFileFullWatermarkInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullWatermarkInfoField"',
            });
        }
        if (!(val.is_watermarked == void 0) && !sdIsBoolean(val.is_watermarked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_watermarked" of type "FileFullWatermarkInfoField"',
            });
        }
        const isWatermarked = val.is_watermarked == void 0 ? void 0 : val.is_watermarked;
        return { isWatermarked: isWatermarked };
    }
    function deserializeFileFullAllowedInviteeRolesField(val) {
        if (val == 'editor') {
            return val;
        }
        if (val == 'viewer') {
            return val;
        }
        if (val == 'previewer') {
            return val;
        }
        if (val == 'uploader') {
            return val;
        }
        if (val == 'previewer uploader') {
            return val;
        }
        if (val == 'viewer uploader') {
            return val;
        }
        if (val == 'co-owner') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullAllowedInviteeRolesField",
        });
    }
    function deserializeFileFullMetadataField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullMetadataField"',
            });
        }
        if (!(val == void 0) && !sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting object for "extraData" of type "FileFullMetadataField"',
            });
        }
        const extraData = val == void 0
            ? void 0
            : sdIsMap(val)
                ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                    k,
                    (function (v) {
                        return sdIsMap(v)
                            ? Object.fromEntries(Object.entries(v).map(([k, v]) => [
                                k,
                                deserializeMetadata(v),
                            ]))
                            : {};
                    })(v),
                ]))
                : {};
        return { extraData: extraData };
    }
    function deserializeFileFullRepresentationsEntriesContentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesContentField"',
            });
        }
        if (!(val.url_template == void 0) && !sdIsString(val.url_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url_template" of type "FileFullRepresentationsEntriesContentField"',
            });
        }
        const urlTemplate = val.url_template == void 0 ? void 0 : val.url_template;
        return {
            urlTemplate: urlTemplate,
        };
    }
    function deserializeFileFullRepresentationsEntriesInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesInfoField"',
            });
        }
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileFullRepresentationsEntriesInfoField"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        return { url: url };
    }
    function deserializeFileFullRepresentationsEntriesPropertiesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        if (!(val.dimensions == void 0) && !sdIsString(val.dimensions)) {
            throw new BoxSdkError({
                message: 'Expecting string for "dimensions" of type "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        const dimensions = val.dimensions == void 0 ? void 0 : val.dimensions;
        if (!(val.paged == void 0) && !sdIsBoolean(val.paged)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "paged" of type "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        const paged = val.paged == void 0 ? void 0 : val.paged;
        if (!(val.thumb == void 0) && !sdIsBoolean(val.thumb)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "thumb" of type "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        const thumb = val.thumb == void 0 ? void 0 : val.thumb;
        return {
            dimensions: dimensions,
            paged: paged,
            thumb: thumb,
        };
    }
    function deserializeFileFullRepresentationsEntriesStatusStateField(val) {
        if (val == 'success') {
            return val;
        }
        if (val == 'viewable') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (val == 'none') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullRepresentationsEntriesStatusStateField",
        });
    }
    function deserializeFileFullRepresentationsEntriesStatusField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesStatusField"',
            });
        }
        const state = val.state == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesStatusStateField(val.state);
        return { state: state };
    }
    function deserializeFileFullRepresentationsEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesField"',
            });
        }
        const content = val.content == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesContentField(val.content);
        const info = val.info == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesInfoField(val.info);
        const properties = val.properties == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesPropertiesField(val.properties);
        if (!(val.representation == void 0) && !sdIsString(val.representation)) {
            throw new BoxSdkError({
                message: 'Expecting string for "representation" of type "FileFullRepresentationsEntriesField"',
            });
        }
        const representation = val.representation == void 0 ? void 0 : val.representation;
        const status = val.status == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesStatusField(val.status);
        return {
            content: content,
            info: info,
            properties: properties,
            representation: representation,
            status: status,
        };
    }
    function deserializeFileFullRepresentationsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsField"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileFullRepresentationsField"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullRepresentationsEntriesField(itm);
                })
                : [];
        return { entries: entries };
    }
    function deserializeFileFullClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullClassificationField"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileFullClassificationField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.definition == void 0) && !sdIsString(val.definition)) {
            throw new BoxSdkError({
                message: 'Expecting string for "definition" of type "FileFullClassificationField"',
            });
        }
        const definition = val.definition == void 0 ? void 0 : val.definition;
        if (!(val.color == void 0) && !sdIsString(val.color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "color" of type "FileFullClassificationField"',
            });
        }
        const color = val.color == void 0 ? void 0 : val.color;
        return {
            name: name,
            definition: definition,
            color: color,
        };
    }
    function deserializeFileFullSharedLinkPermissionOptionsField(val) {
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_edit') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullSharedLinkPermissionOptionsField",
        });
    }
    function deserializeFileFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileFull"' });
        }
        if (!(val.version_number == void 0) && !sdIsString(val.version_number)) {
            throw new BoxSdkError({
                message: 'Expecting string for "version_number" of type "FileFull"',
            });
        }
        const versionNumber = val.version_number == void 0 ? void 0 : val.version_number;
        if (!(val.comment_count == void 0) && !sdIsNumber(val.comment_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "comment_count" of type "FileFull"',
            });
        }
        const commentCount = val.comment_count == void 0 ? void 0 : val.comment_count;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFileFullPermissionsField(val.permissions);
        if (!(val.tags == void 0) && !sdIsList(val.tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "tags" of type "FileFull"',
            });
        }
        const tags = val.tags == void 0
            ? void 0
            : sdIsList(val.tags)
                ? val.tags.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "FileFull"',
                        });
                    }
                    return itm;
                })
                : [];
        const lock = val.lock == void 0 ? void 0 : deserializeFileFullLockField(val.lock);
        if (!(val.extension == void 0) && !sdIsString(val.extension)) {
            throw new BoxSdkError({
                message: 'Expecting string for "extension" of type "FileFull"',
            });
        }
        const extension = val.extension == void 0 ? void 0 : val.extension;
        if (!(val.is_package == void 0) && !sdIsBoolean(val.is_package)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_package" of type "FileFull"',
            });
        }
        const isPackage = val.is_package == void 0 ? void 0 : val.is_package;
        const expiringEmbedLink = val.expiring_embed_link == void 0
            ? void 0
            : deserializeFileFullExpiringEmbedLinkField(val.expiring_embed_link);
        const watermarkInfo = val.watermark_info == void 0
            ? void 0
            : deserializeFileFullWatermarkInfoField(val.watermark_info);
        if (!(val.is_accessible_via_shared_link == void 0) &&
            !sdIsBoolean(val.is_accessible_via_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accessible_via_shared_link" of type "FileFull"',
            });
        }
        const isAccessibleViaSharedLink = val.is_accessible_via_shared_link == void 0
            ? void 0
            : val.is_accessible_via_shared_link;
        if (!(val.allowed_invitee_roles == void 0) &&
            !sdIsList(val.allowed_invitee_roles)) {
            throw new BoxSdkError({
                message: 'Expecting array for "allowed_invitee_roles" of type "FileFull"',
            });
        }
        const allowedInviteeRoles = val.allowed_invitee_roles == void 0
            ? void 0
            : sdIsList(val.allowed_invitee_roles)
                ? val.allowed_invitee_roles.map(function (itm) {
                    return deserializeFileFullAllowedInviteeRolesField(itm);
                })
                : [];
        if (!(val.is_externally_owned == void 0) &&
            !sdIsBoolean(val.is_externally_owned)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_externally_owned" of type "FileFull"',
            });
        }
        const isExternallyOwned = val.is_externally_owned == void 0 ? void 0 : val.is_externally_owned;
        if (!(val.has_collaborations == void 0) &&
            !sdIsBoolean(val.has_collaborations)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "has_collaborations" of type "FileFull"',
            });
        }
        const hasCollaborations = val.has_collaborations == void 0 ? void 0 : val.has_collaborations;
        const metadata = val.metadata == void 0
            ? void 0
            : deserializeFileFullMetadataField(val.metadata);
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "FileFull"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        const representations = val.representations == void 0
            ? void 0
            : deserializeFileFullRepresentationsField(val.representations);
        const classification = val.classification == void 0
            ? void 0
            : deserializeFileFullClassificationField(val.classification);
        if (!(val.uploader_display_name == void 0) &&
            !sdIsString(val.uploader_display_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "uploader_display_name" of type "FileFull"',
            });
        }
        const uploaderDisplayName = val.uploader_display_name == void 0 ? void 0 : val.uploader_display_name;
        if (!(val.disposition_at == void 0) && !sdIsString(val.disposition_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "disposition_at" of type "FileFull"',
            });
        }
        const dispositionAt = val.disposition_at == void 0
            ? void 0
            : dateTimeFromString(val.disposition_at);
        if (!(val.shared_link_permission_options == void 0) &&
            !sdIsList(val.shared_link_permission_options)) {
            throw new BoxSdkError({
                message: 'Expecting array for "shared_link_permission_options" of type "FileFull"',
            });
        }
        const sharedLinkPermissionOptions = val.shared_link_permission_options == void 0
            ? void 0
            : sdIsList(val.shared_link_permission_options)
                ? val.shared_link_permission_options.map(function (itm) {
                    return deserializeFileFullSharedLinkPermissionOptionsField(itm);
                })
                : [];
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "FileFull"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "FileFull"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFilePathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "FileFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "FileFull"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "FileFull"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "FileFull"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "FileFull"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFileSharedLinkField(val.shared_link);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFileItemStatusField(val.item_status);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FileFull"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileFull"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileFull"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileFull"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileFull" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return {
            versionNumber: versionNumber,
            commentCount: commentCount,
            permissions: permissions,
            tags: tags,
            lock: lock,
            extension: extension,
            isPackage: isPackage,
            expiringEmbedLink: expiringEmbedLink,
            watermarkInfo: watermarkInfo,
            isAccessibleViaSharedLink: isAccessibleViaSharedLink,
            allowedInviteeRoles: allowedInviteeRoles,
            isExternallyOwned: isExternallyOwned,
            hasCollaborations: hasCollaborations,
            metadata: metadata,
            expiresAt: expiresAt,
            representations: representations,
            classification: classification,
            uploaderDisplayName: uploaderDisplayName,
            dispositionAt: dispositionAt,
            sharedLinkPermissionOptions: sharedLinkPermissionOptions,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            id: id,
            etag: etag,
            type: type,
        };
    }

    class GetFileByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CopyFileOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CopyFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileThumbnailByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileThumbnailByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifNoneMatch) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.xRepHints) {
                this.xRepHints = fields.xRepHints;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CopyFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileThumbnailByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FilesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileById(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                    ['x-rep-hints']: toString(headers.xRepHints),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
        updateFileById(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new UpdateFileByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateFileByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
        deleteFileById(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteFileByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        copyFile(fileId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new CopyFileOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/copy'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCopyFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
        getFileThumbnailById(fileId_1, extension_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, extension, optionalsInput = {}) {
                const optionals = new GetFileThumbnailByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['min_height']: toString(queryParams.minHeight),
                    ['min_width']: toString(queryParams.minWidth),
                    ['max_height']: toString(queryParams.maxHeight),
                    ['max_width']: toString(queryParams.maxWidth),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/thumbnail.', toString(extension)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return response.content;
            });
        }
    }
    function serializeUpdateFileByIdRequestBodyParentField(val) {
        return { ['id']: val.id == void 0 ? void 0 : val.id };
    }
    function serializeUpdateFileByIdRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateFileByIdRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
        };
    }
    function serializeUpdateFileByIdRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateFileByIdRequestBodyLockAccessField(val) {
        return val;
    }
    function serializeUpdateFileByIdRequestBodyLockField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodyLockAccessField(val.access),
            ['expires_at']: val.expiresAt == void 0 ? void 0 : dateTimeToString(val.expiresAt),
            ['is_download_prevented']: val.isDownloadPrevented == void 0 ? void 0 : val.isDownloadPrevented,
        };
    }
    function serializeUpdateFileByIdRequestBodyPermissionsCanDownloadField(val) {
        return val;
    }
    function serializeUpdateFileByIdRequestBodyPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodyPermissionsCanDownloadField(val.canDownload),
        };
    }
    function serializeUpdateFileByIdRequestBodyCollectionsField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0 ? void 0 : val.type,
        };
    }
    function serializeUpdateFileByIdRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['parent']: val.parent == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodyParentField(val.parent),
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodySharedLinkField(val.sharedLink),
            ['lock']: val.lock == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodyLockField(val.lock),
            ['disposition_at']: val.dispositionAt == void 0
                ? void 0
                : dateTimeToString(val.dispositionAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeUpdateFileByIdRequestBodyPermissionsField(val.permissions),
            ['collections']: val.collections == void 0
                ? void 0
                : val.collections.map(function (item) {
                    return serializeUpdateFileByIdRequestBodyCollectionsField(item);
                }),
            ['tags']: val.tags == void 0
                ? void 0
                : val.tags.map(function (item) {
                    return item;
                }),
        };
    }
    function serializeCopyFileRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCopyFileRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['version']: val.version == void 0 ? void 0 : val.version,
            ['parent']: serializeCopyFileRequestBodyParentField(val.parent),
        };
    }

    function deserializeTrashFileRestoredTypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFileRestoredTypeField",
        });
    }
    function deserializeTrashFileRestoredPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFileRestoredPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFileRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFileRestoredPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFileRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFileRestoredPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFileRestoredItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFileRestoredItemStatusField",
        });
    }
    function deserializeTrashFileRestored(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFileRestored"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFileRestored"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFileRestored"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TrashFileRestored" to be defined',
            });
        }
        const type = deserializeTrashFileRestoredTypeField(val.type);
        if (val.sequence_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sequence_id" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFileRestored"',
            });
        }
        const sequenceId = val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFileRestored"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.sha1 == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sha1" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "TrashFileRestored"',
            });
        }
        const sha1 = val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFileRestored"',
            });
        }
        const description = val.description;
        if (val.size == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "size" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFileRestored"',
            });
        }
        const size = val.size;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashFileRestored" to be defined',
            });
        }
        const pathCollection = deserializeTrashFileRestoredPathCollectionField(val.path_collection);
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFileRestored"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (val.modified_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_at" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFileRestored"',
            });
        }
        const modifiedAt = dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFileRestored"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : val.trashed_at;
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFileRestored"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : val.purged_at;
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFileRestored"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFileRestored"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (val.modified_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_by" of type "TrashFileRestored" to be defined',
            });
        }
        const modifiedBy = deserializeUserMini(val.modified_by);
        if (val.owned_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "owned_by" of type "TrashFileRestored" to be defined',
            });
        }
        const ownedBy = deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFileRestored"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (val.item_status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_status" of type "TrashFileRestored" to be defined',
            });
        }
        const itemStatus = deserializeTrashFileRestoredItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    function deserializeTrashFileTypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrashFileTypeField" });
    }
    function deserializeTrashFilePathCollectionEntriesTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFilePathCollectionEntriesTypeField",
        });
    }
    function deserializeTrashFilePathCollectionEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFilePathCollectionEntriesField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashFilePathCollectionEntriesTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
        };
    }
    function deserializeTrashFilePathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFilePathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFilePathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFilePathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFilePathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFilePathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTrashFilePathCollectionEntriesField(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFileItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFileItemStatusField",
        });
    }
    function deserializeTrashFile(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrashFile"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFile"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFile"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TrashFile" to be defined',
            });
        }
        const type = deserializeTrashFileTypeField(val.type);
        if (val.sequence_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sequence_id" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFile"',
            });
        }
        const sequenceId = val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFile"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.sha1 == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sha1" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "TrashFile"',
            });
        }
        const sha1 = val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFile"',
            });
        }
        const description = val.description;
        if (val.size == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "size" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFile"',
            });
        }
        const size = val.size;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashFile" to be defined',
            });
        }
        const pathCollection = deserializeTrashFilePathCollectionField(val.path_collection);
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFile"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (val.modified_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_at" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFile"',
            });
        }
        const modifiedAt = dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFile"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFile"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFile"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFile"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (val.modified_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_by" of type "TrashFile" to be defined',
            });
        }
        const modifiedBy = deserializeUserMini(val.modified_by);
        if (val.owned_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "owned_by" of type "TrashFile" to be defined',
            });
        }
        const ownedBy = deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFile"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (val.item_status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_status" of type "TrashFile" to be defined',
            });
        }
        const itemStatus = deserializeTrashFileItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    class RestoreFileFromTrashOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new RestoreFileFromTrashHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTrashedFileByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetTrashedFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTrashedFileByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTrashedFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RestoreFileFromTrashHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTrashedFileByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTrashedFileByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedFilesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        restoreFileFromTrash(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new RestoreFileFromTrashOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRestoreFileFromTrashRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTrashFileRestored(response.data);
            });
        }
        getTrashedFileById(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetTrashedFileByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/trash'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTrashFile(response.data);
            });
        }
        deleteTrashedFileById(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteTrashedFileByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/trash'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeRestoreFileFromTrashRequestBodyParentField(val) {
        return { ['id']: val.id == void 0 ? void 0 : val.id };
    }
    function serializeRestoreFileFromTrashRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['parent']: val.parent == void 0
                ? void 0
                : serializeRestoreFileFromTrashRequestBodyParentField(val.parent),
        };
    }

    class DownloadFileOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new DownloadFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DownloadFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.range) {
                this.range = fields.range;
            }
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DownloadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        downloadFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DownloadFileOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['version']: toString(queryParams.version),
                    ['access_token']: toString(queryParams.accessToken),
                });
                const headersMap = prepareParams(Object.assign({
                    ['range']: toString(headers.range),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/content'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return response.content;
            });
        }
    }

    function deserializeFiles(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Files"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Files"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Files"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFull(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    function deserializeUploadUrl(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadUrl"' });
        }
        if (!(val.upload_url == void 0) && !sdIsString(val.upload_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "upload_url" of type "UploadUrl"',
            });
        }
        const uploadUrl = val.upload_url == void 0 ? void 0 : val.upload_url;
        if (!(val.upload_token == void 0) && !sdIsString(val.upload_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "upload_token" of type "UploadUrl"',
            });
        }
        const uploadToken = val.upload_token == void 0 ? void 0 : val.upload_token;
        return { uploadUrl: uploadUrl, uploadToken: uploadToken };
    }

    class UploadFileVersionOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new UploadFileVersionHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadFileOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new UploadFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadFileVersionHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.contentMd5) {
                this.contentMd5 = fields.contentMd5;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.contentMd5) {
                this.contentMd5 = fields.contentMd5;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class PreflightFileUploadCheckHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        uploadFileVersion(fileId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UploadFileVersionOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-match']: toString(headers.ifMatch),
                    ['content-md5']: toString(headers.contentMd5),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/', toString(fileId), '/content'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    multipartData: [
                        {
                            partName: 'attributes',
                            data: serializeUploadFileVersionRequestBodyAttributesField(requestBody.attributes),
                        },
                        {
                            partName: 'file',
                            fileStream: requestBody.file,
                            fileName: requestBody.fileFileName,
                            contentType: requestBody.fileContentType,
                        },
                    ],
                    contentType: 'multipart/form-data',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFiles(response.data);
            });
        }
        uploadFile(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new UploadFileOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({ ['content-md5']: toString(headers.contentMd5) }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/content'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    multipartData: [
                        {
                            partName: 'attributes',
                            data: serializeUploadFileRequestBodyAttributesField(requestBody.attributes),
                        },
                        {
                            partName: 'file',
                            fileStream: requestBody.file,
                            fileName: requestBody.fileFileName,
                            contentType: requestBody.fileContentType,
                        },
                    ],
                    contentType: 'multipart/form-data',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFiles(response.data);
            });
        }
        preflightFileUploadCheck() {
            return __awaiter(this, arguments, void 0, function* (requestBody = {}, headersInput = new PreflightFileUploadCheckHeaders({}), cancellationToken) {
                const headers = new PreflightFileUploadCheckHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/content'), {
                    method: 'OPTIONS',
                    headers: headersMap,
                    data: serializePreflightFileUploadCheckRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUploadUrl(response.data);
            });
        }
    }
    function serializeUploadFileVersionRequestBodyAttributesField(val) {
        return {
            ['name']: val.name,
            ['content_modified_at']: val.contentModifiedAt == void 0
                ? void 0
                : dateTimeToString(val.contentModifiedAt),
        };
    }
    function serializeUploadFileRequestBodyAttributesParentField(val) {
        return { ['id']: val.id };
    }
    function serializeUploadFileRequestBodyAttributesField(val) {
        return {
            ['name']: val.name,
            ['parent']: serializeUploadFileRequestBodyAttributesParentField(val.parent),
            ['content_created_at']: val.contentCreatedAt == void 0
                ? void 0
                : dateTimeToString(val.contentCreatedAt),
            ['content_modified_at']: val.contentModifiedAt == void 0
                ? void 0
                : dateTimeToString(val.contentModifiedAt),
        };
    }
    function serializePreflightFileUploadCheckRequestBodyParentField(val) {
        return { ['id']: val.id == void 0 ? void 0 : val.id };
    }
    function serializePreflightFileUploadCheckRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['size']: val.size == void 0 ? void 0 : val.size,
            ['parent']: val.parent == void 0
                ? void 0
                : serializePreflightFileUploadCheckRequestBodyParentField(val.parent),
        };
    }

    function deserializeUploadSessionTypeField(val) {
        if (val == 'upload_session') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UploadSessionTypeField",
        });
    }
    function deserializeUploadSessionSessionEndpointsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UploadSessionSessionEndpointsField"',
            });
        }
        if (!(val.upload_part == void 0) && !sdIsString(val.upload_part)) {
            throw new BoxSdkError({
                message: 'Expecting string for "upload_part" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const uploadPart = val.upload_part == void 0 ? void 0 : val.upload_part;
        if (!(val.commit == void 0) && !sdIsString(val.commit)) {
            throw new BoxSdkError({
                message: 'Expecting string for "commit" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const commit = val.commit == void 0 ? void 0 : val.commit;
        if (!(val.abort == void 0) && !sdIsString(val.abort)) {
            throw new BoxSdkError({
                message: 'Expecting string for "abort" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const abort = val.abort == void 0 ? void 0 : val.abort;
        if (!(val.list_parts == void 0) && !sdIsString(val.list_parts)) {
            throw new BoxSdkError({
                message: 'Expecting string for "list_parts" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const listParts = val.list_parts == void 0 ? void 0 : val.list_parts;
        if (!(val.status == void 0) && !sdIsString(val.status)) {
            throw new BoxSdkError({
                message: 'Expecting string for "status" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const status = val.status == void 0 ? void 0 : val.status;
        if (!(val.log_event == void 0) && !sdIsString(val.log_event)) {
            throw new BoxSdkError({
                message: 'Expecting string for "log_event" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const logEvent = val.log_event == void 0 ? void 0 : val.log_event;
        return {
            uploadPart: uploadPart,
            commit: commit,
            abort: abort,
            listParts: listParts,
            status: status,
            logEvent: logEvent,
        };
    }
    function deserializeUploadSession(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadSession"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UploadSession"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeUploadSessionTypeField(val.type);
        if (!(val.session_expires_at == void 0) &&
            !sdIsString(val.session_expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "session_expires_at" of type "UploadSession"',
            });
        }
        const sessionExpiresAt = val.session_expires_at == void 0
            ? void 0
            : dateTimeFromString(val.session_expires_at);
        if (!(val.part_size == void 0) && !sdIsNumber(val.part_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "part_size" of type "UploadSession"',
            });
        }
        const partSize = val.part_size == void 0 ? void 0 : val.part_size;
        if (!(val.total_parts == void 0) && !sdIsNumber(val.total_parts)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_parts" of type "UploadSession"',
            });
        }
        const totalParts = val.total_parts == void 0 ? void 0 : val.total_parts;
        if (!(val.num_parts_processed == void 0) &&
            !sdIsNumber(val.num_parts_processed)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_parts_processed" of type "UploadSession"',
            });
        }
        const numPartsProcessed = val.num_parts_processed == void 0 ? void 0 : val.num_parts_processed;
        const sessionEndpoints = val.session_endpoints == void 0
            ? void 0
            : deserializeUploadSessionSessionEndpointsField(val.session_endpoints);
        return {
            id: id,
            type: type,
            sessionExpiresAt: sessionExpiresAt,
            partSize: partSize,
            totalParts: totalParts,
            numPartsProcessed: numPartsProcessed,
            sessionEndpoints: sessionEndpoints,
        };
    }

    function serializeUploadPartMini(val) {
        return {
            ['part_id']: val.partId == void 0 ? void 0 : val.partId,
            ['offset']: val.offset == void 0 ? void 0 : val.offset,
            ['size']: val.size == void 0 ? void 0 : val.size,
        };
    }

    function serializeUploadPart(val) {
        const base = serializeUploadPartMini(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadPart"' });
        }
        return Object.assign(Object.assign({}, base), { ['sha1']: val.sha1 == void 0 ? void 0 : val.sha1 });
    }
    function deserializeUploadPart(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadPart"' });
        }
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "UploadPart"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        if (!(val.part_id == void 0) && !sdIsString(val.part_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "part_id" of type "UploadPart"',
            });
        }
        const partId = val.part_id == void 0 ? void 0 : val.part_id;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "UploadPart"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "UploadPart"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        return {
            sha1: sha1,
            partId: partId,
            offset: offset,
            size: size,
        };
    }

    function deserializeUploadedPart(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadedPart"' });
        }
        const part = val.part == void 0 ? void 0 : deserializeUploadPart(val.part);
        return { part: part };
    }

    function deserializeUploadPartsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UploadPartsOrderDirectionField",
        });
    }
    function deserializeUploadPartsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UploadPartsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "UploadPartsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeUploadPartsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeUploadParts(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadParts"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "UploadParts"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "UploadParts"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "UploadParts"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "UploadParts"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeUploadPartsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "UploadParts"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeUploadPart(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class CreateFileUploadSessionOptionals {
        constructor(fields) {
            this.headers = new CreateFileUploadSessionHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileUploadSessionForExistingFileOptionals {
        constructor(fields) {
            this.headers = new CreateFileUploadSessionForExistingFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileUploadSessionByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileUploadSessionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadFilePartOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileUploadSessionByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileUploadSessionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileUploadSessionPartsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileUploadSessionPartsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileUploadSessionCommitOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileUploadSessionHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileUploadSessionForExistingFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileUploadSessionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadFilePartHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.digest) {
                this.digest = fields.digest;
            }
            if (fields.contentRange) {
                this.contentRange = fields.contentRange;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileUploadSessionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileUploadSessionPartsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileUploadSessionCommitHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.digest) {
                this.digest = fields.digest;
            }
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.ifNoneMatch) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ChunkedUploadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        createFileUploadSession(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateFileUploadSessionOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileUploadSessionRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUploadSession(response.data);
            });
        }
        createFileUploadSessionForExistingFile(fileId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new CreateFileUploadSessionForExistingFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/', toString(fileId), '/upload_sessions'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileUploadSessionForExistingFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUploadSession(response.data);
            });
        }
        getFileUploadSessionById(uploadSessionId_1) {
            return __awaiter(this, arguments, void 0, function* (uploadSessionId, optionalsInput = {}) {
                const optionals = new GetFileUploadSessionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUploadSession(response.data);
            });
        }
        uploadFilePart(uploadSessionId_1, requestBody_1, headersInput_1) {
            return __awaiter(this, arguments, void 0, function* (uploadSessionId, requestBody, headersInput, optionalsInput = {}) {
                const headers = new UploadFilePartHeaders({
                    digest: headersInput.digest,
                    contentRange: headersInput.contentRange,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new UploadFilePartOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({
                    ['digest']: toString(headers.digest),
                    ['content-range']: toString(headers.contentRange),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId)), {
                    method: 'PUT',
                    headers: headersMap,
                    fileStream: requestBody,
                    contentType: 'application/octet-stream',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUploadedPart(response.data);
            });
        }
        deleteFileUploadSessionById(uploadSessionId_1) {
            return __awaiter(this, arguments, void 0, function* (uploadSessionId, optionalsInput = {}) {
                const optionals = new DeleteFileUploadSessionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getFileUploadSessionParts(uploadSessionId_1) {
            return __awaiter(this, arguments, void 0, function* (uploadSessionId, optionalsInput = {}) {
                const optionals = new GetFileUploadSessionPartsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId), '/parts'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUploadParts(response.data);
            });
        }
        createFileUploadSessionCommit(uploadSessionId_1, requestBody_1, headersInput_1) {
            return __awaiter(this, arguments, void 0, function* (uploadSessionId, requestBody, headersInput, optionalsInput = {}) {
                const headers = new CreateFileUploadSessionCommitHeaders({
                    digest: headersInput.digest,
                    ifMatch: headersInput.ifMatch,
                    ifNoneMatch: headersInput.ifNoneMatch,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new CreateFileUploadSessionCommitOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({
                    ['digest']: toString(headers.digest),
                    ['if-match']: toString(headers.ifMatch),
                    ['if-none-match']: toString(headers.ifNoneMatch),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId), '/commit'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileUploadSessionCommitRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFiles(response.data);
            });
        }
        reducer(acc, chunk) {
            return __awaiter(this, void 0, void 0, function* () {
                const lastIndex = acc.lastIndex;
                const parts = acc.parts;
                const chunkBuffer = yield readByteStream(chunk);
                const hash = new Hash({ algorithm: 'sha1' });
                hash.updateHash(chunkBuffer);
                const sha1 = yield hash.digestHash('base64');
                const digest = ''.concat('sha=', sha1);
                const chunkSize = bufferLength(chunkBuffer);
                const bytesStart = lastIndex + 1;
                const bytesEnd = lastIndex + chunkSize;
                const contentRange = ''.concat('bytes ', toString(bytesStart), '-', toString(bytesEnd), '/', toString(acc.fileSize));
                const uploadedPart = yield this.uploadFilePart(acc.uploadSessionId, generateByteStreamFromBuffer(chunkBuffer), {
                    digest: digest,
                    contentRange: contentRange,
                });
                const part = uploadedPart.part;
                const partSha1 = hexToBase64(part.sha1);
                if (!(partSha1 == sha1)) {
                    throw new Error('Assertion failed');
                }
                if (!(part.size == chunkSize)) {
                    throw new Error('Assertion failed');
                }
                if (!(part.offset == bytesStart)) {
                    throw new Error('Assertion failed');
                }
                acc.fileHash.updateHash(chunkBuffer);
                return {
                    lastIndex: bytesEnd,
                    parts: parts.concat([part]),
                    fileSize: acc.fileSize,
                    uploadSessionId: acc.uploadSessionId,
                    fileHash: acc.fileHash,
                };
            });
        }
        uploadBigFile(file, fileName, fileSize, parentFolderId, cancellationToken) {
            return __awaiter(this, void 0, void 0, function* () {
                const uploadSession = yield this.createFileUploadSession({
                    fileName: fileName,
                    fileSize: fileSize,
                    folderId: parentFolderId,
                }, {
                    headers: new CreateFileUploadSessionHeaders({}),
                    cancellationToken: cancellationToken,
                });
                const uploadSessionId = uploadSession.id;
                const partSize = uploadSession.partSize;
                const totalParts = uploadSession.totalParts;
                if (!(partSize * totalParts >= fileSize)) {
                    throw new Error('Assertion failed');
                }
                if (!(uploadSession.numPartsProcessed == 0)) {
                    throw new Error('Assertion failed');
                }
                const fileHash = new Hash({ algorithm: 'sha1' });
                const chunksIterator = iterateChunks(file, partSize, fileSize);
                const results = yield reduceIterator(chunksIterator, this.reducer.bind(this), {
                    lastIndex: -1,
                    parts: [],
                    fileSize: fileSize,
                    uploadSessionId: uploadSessionId,
                    fileHash: fileHash,
                });
                const parts = results.parts;
                const processedSessionParts = yield this.getFileUploadSessionParts(uploadSessionId, {
                    queryParams: {},
                    headers: new GetFileUploadSessionPartsHeaders({}),
                    cancellationToken: cancellationToken,
                });
                if (!(processedSessionParts.totalCount == totalParts)) {
                    throw new Error('Assertion failed');
                }
                const processedSession = yield this.getFileUploadSessionById(uploadSessionId, {
                    headers: new GetFileUploadSessionByIdHeaders({}),
                    cancellationToken: cancellationToken,
                });
                yield new Promise((resolve) => setTimeout(resolve, 5000));
                if (!(processedSession.numPartsProcessed == totalParts)) {
                    console.log(processedSession);
                    console.log('Assertion failed');
                }
                const sha1 = yield fileHash.digestHash('base64');
                const digest = ''.concat('sha=', sha1);
                const committedSession = yield this.createFileUploadSessionCommit(uploadSessionId, { parts: parts }, { digest: digest }, {
                    cancellationToken: cancellationToken,
                });
                console.log(yield this.getFileUploadSessionById(uploadSessionId, {
                    headers: new GetFileUploadSessionByIdHeaders({}),
                    cancellationToken: cancellationToken,
                }));
                return committedSession.entries[0];
            });
        }
    }
    function serializeCreateFileUploadSessionRequestBody(val) {
        return {
            ['folder_id']: val.folderId,
            ['file_size']: val.fileSize,
            ['file_name']: val.fileName,
        };
    }
    function serializeCreateFileUploadSessionForExistingFileRequestBody(val) {
        return {
            ['file_size']: val.fileSize,
            ['file_name']: val.fileName == void 0 ? void 0 : val.fileName,
        };
    }
    function serializeCreateFileUploadSessionCommitRequestBody(val) {
        return {
            ['parts']: val.parts.map(function (item) {
                return serializeUploadPart(item);
            }),
        };
    }

    function deserializeWebLinkBaseTypeField(val) {
        if (val == 'web_link') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WebLinkBaseTypeField" });
    }

    function deserializeWebLinkPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebLinkPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "WebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "WebLinkPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "WebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "WebLinkPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeWebLinkSharedLinkAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkSharedLinkAccessField",
        });
    }
    function deserializeWebLinkSharedLinkEffectiveAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkSharedLinkEffectiveAccessField",
        });
    }
    function deserializeWebLinkSharedLinkEffectivePermissionField(val) {
        if (val == 'can_edit') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'no_access') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkSharedLinkEffectivePermissionField",
        });
    }
    function deserializeWebLinkSharedLinkPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebLinkSharedLinkPermissionsField"',
            });
        }
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "WebLinkSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "WebLinkSharedLinkPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_preview == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_preview" of type "WebLinkSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "WebLinkSharedLinkPermissionsField"',
            });
        }
        const canPreview = val.can_preview;
        if (val.can_edit == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_edit" of type "WebLinkSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_edit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_edit" of type "WebLinkSharedLinkPermissionsField"',
            });
        }
        const canEdit = val.can_edit;
        return {
            canDownload: canDownload,
            canPreview: canPreview,
            canEdit: canEdit,
        };
    }
    function deserializeWebLinkSharedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebLinkSharedLinkField"',
            });
        }
        if (val.url == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "url" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "WebLinkSharedLinkField"',
            });
        }
        const url = val.url;
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "WebLinkSharedLinkField"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.vanity_url == void 0) && !sdIsString(val.vanity_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_url" of type "WebLinkSharedLinkField"',
            });
        }
        const vanityUrl = val.vanity_url == void 0 ? void 0 : val.vanity_url;
        if (!(val.vanity_name == void 0) && !sdIsString(val.vanity_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_name" of type "WebLinkSharedLinkField"',
            });
        }
        const vanityName = val.vanity_name == void 0 ? void 0 : val.vanity_name;
        const access = val.access == void 0
            ? void 0
            : deserializeWebLinkSharedLinkAccessField(val.access);
        if (val.effective_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_access" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        const effectiveAccess = deserializeWebLinkSharedLinkEffectiveAccessField(val.effective_access);
        if (val.effective_permission == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_permission" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        const effectivePermission = deserializeWebLinkSharedLinkEffectivePermissionField(val.effective_permission);
        if (!(val.unshared_at == void 0) && !sdIsString(val.unshared_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "unshared_at" of type "WebLinkSharedLinkField"',
            });
        }
        const unsharedAt = val.unshared_at == void 0 ? void 0 : dateTimeFromString(val.unshared_at);
        if (val.is_password_enabled == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "is_password_enabled" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsBoolean(val.is_password_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_password_enabled" of type "WebLinkSharedLinkField"',
            });
        }
        const isPasswordEnabled = val.is_password_enabled;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeWebLinkSharedLinkPermissionsField(val.permissions);
        if (val.download_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "download_count" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.download_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "download_count" of type "WebLinkSharedLinkField"',
            });
        }
        const downloadCount = val.download_count;
        if (val.preview_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "preview_count" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.preview_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "preview_count" of type "WebLinkSharedLinkField"',
            });
        }
        const previewCount = val.preview_count;
        return {
            url: url,
            downloadUrl: downloadUrl,
            vanityUrl: vanityUrl,
            vanityName: vanityName,
            access: access,
            effectiveAccess: effectiveAccess,
            effectivePermission: effectivePermission,
            unsharedAt: unsharedAt,
            isPasswordEnabled: isPasswordEnabled,
            permissions: permissions,
            downloadCount: downloadCount,
            previewCount: previewCount,
        };
    }
    function deserializeWebLinkItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkItemStatusField",
        });
    }
    function deserializeWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "WebLink"' });
        }
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "WebLink"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeWebLinkPathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "WebLink"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "WebLink"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "WebLink"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "WebLink"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeWebLinkSharedLinkField(val.shared_link);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeWebLinkItemStatusField(val.item_status);
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "WebLink"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "WebLink"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "WebLink"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "WebLink" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WebLink"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "WebLink" to be defined',
            });
        }
        const type = deserializeWebLinkBaseTypeField(val.type);
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "WebLink"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        return {
            parent: parent,
            description: description,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            itemStatus: itemStatus,
            url: url,
            sequenceId: sequenceId,
            name: name,
            id: id,
            type: type,
            etag: etag,
        };
    }

    function deserializeFileFullOrFolderMiniOrWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullOrFolderMiniOrWebLink"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileFull(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderMini(val);
        }
        if (val.type == 'web_link') {
            return deserializeWebLink(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullOrFolderMiniOrWebLink",
        });
    }

    function deserializeItemsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ItemsOrderDirectionField",
        });
    }
    function deserializeItemsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "ItemsOrderField"' });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "ItemsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeItemsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeItems(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Items"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Items"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Items"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Items"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Items"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Items"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Items"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeItemsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Items"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullOrFolderMiniOrWebLink(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            totalCount: totalCount,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    function deserializeFolderPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "FolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "FolderPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "FolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FolderPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeFolderSharedLinkAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderSharedLinkAccessField",
        });
    }
    function deserializeFolderSharedLinkEffectiveAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderSharedLinkEffectiveAccessField",
        });
    }
    function deserializeFolderSharedLinkEffectivePermissionField(val) {
        if (val == 'can_edit') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'no_access') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderSharedLinkEffectivePermissionField",
        });
    }
    function deserializeFolderSharedLinkPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderSharedLinkPermissionsField"',
            });
        }
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FolderSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FolderSharedLinkPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_preview == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_preview" of type "FolderSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "FolderSharedLinkPermissionsField"',
            });
        }
        const canPreview = val.can_preview;
        if (val.can_edit == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_edit" of type "FolderSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_edit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_edit" of type "FolderSharedLinkPermissionsField"',
            });
        }
        const canEdit = val.can_edit;
        return {
            canDownload: canDownload,
            canPreview: canPreview,
            canEdit: canEdit,
        };
    }
    function deserializeFolderSharedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderSharedLinkField"',
            });
        }
        if (val.url == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "url" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FolderSharedLinkField"',
            });
        }
        const url = val.url;
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "FolderSharedLinkField"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.vanity_url == void 0) && !sdIsString(val.vanity_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_url" of type "FolderSharedLinkField"',
            });
        }
        const vanityUrl = val.vanity_url == void 0 ? void 0 : val.vanity_url;
        if (!(val.vanity_name == void 0) && !sdIsString(val.vanity_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_name" of type "FolderSharedLinkField"',
            });
        }
        const vanityName = val.vanity_name == void 0 ? void 0 : val.vanity_name;
        const access = val.access == void 0
            ? void 0
            : deserializeFolderSharedLinkAccessField(val.access);
        if (val.effective_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_access" of type "FolderSharedLinkField" to be defined',
            });
        }
        const effectiveAccess = deserializeFolderSharedLinkEffectiveAccessField(val.effective_access);
        if (val.effective_permission == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_permission" of type "FolderSharedLinkField" to be defined',
            });
        }
        const effectivePermission = deserializeFolderSharedLinkEffectivePermissionField(val.effective_permission);
        if (!(val.unshared_at == void 0) && !sdIsString(val.unshared_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "unshared_at" of type "FolderSharedLinkField"',
            });
        }
        const unsharedAt = val.unshared_at == void 0 ? void 0 : dateTimeFromString(val.unshared_at);
        if (val.is_password_enabled == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "is_password_enabled" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsBoolean(val.is_password_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_password_enabled" of type "FolderSharedLinkField"',
            });
        }
        const isPasswordEnabled = val.is_password_enabled;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFolderSharedLinkPermissionsField(val.permissions);
        if (val.download_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "download_count" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.download_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "download_count" of type "FolderSharedLinkField"',
            });
        }
        const downloadCount = val.download_count;
        if (val.preview_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "preview_count" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.preview_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "preview_count" of type "FolderSharedLinkField"',
            });
        }
        const previewCount = val.preview_count;
        return {
            url: url,
            downloadUrl: downloadUrl,
            vanityUrl: vanityUrl,
            vanityName: vanityName,
            access: access,
            effectiveAccess: effectiveAccess,
            effectivePermission: effectivePermission,
            unsharedAt: unsharedAt,
            isPasswordEnabled: isPasswordEnabled,
            permissions: permissions,
            downloadCount: downloadCount,
            previewCount: previewCount,
        };
    }
    function deserializeFolderFolderUploadEmailAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFolderUploadEmailAccessField",
        });
    }
    function deserializeFolderFolderUploadEmailField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFolderUploadEmailField"',
            });
        }
        const access = val.access == void 0
            ? void 0
            : deserializeFolderFolderUploadEmailAccessField(val.access);
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "FolderFolderUploadEmailField"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        return {
            access: access,
            email: email,
        };
    }
    function deserializeFolderItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FolderItemStatusField" });
    }
    function deserializeFolder(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Folder"' });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Folder"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "Folder"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "Folder"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "Folder"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFolderPathCollectionField(val.path_collection);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "Folder"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "Folder"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "Folder"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "Folder"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFolderSharedLinkField(val.shared_link);
        const folderUploadEmail = val.folder_upload_email == void 0
            ? void 0
            : deserializeFolderFolderUploadEmailField(val.folder_upload_email);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFolderItemStatusField(val.item_status);
        const itemCollection = val.item_collection == void 0
            ? void 0
            : deserializeItems(val.item_collection);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "Folder"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "Folder"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "Folder" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Folder"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "Folder"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "Folder" to be defined',
            });
        }
        const type = deserializeFolderBaseTypeField(val.type);
        return {
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
            itemCollection: itemCollection,
            sequenceId: sequenceId,
            name: name,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function deserializeFileOrFolderOrWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileOrFolderOrWebLink"',
            });
        }
        if (val.type == 'file') {
            return deserializeFile(val);
        }
        if (val.type == 'folder') {
            return deserializeFolder(val);
        }
        if (val.type == 'web_link') {
            return deserializeWebLink(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize FileOrFolderOrWebLink" });
    }

    function deserializeGroupBaseTypeField(val) {
        if (val == 'group') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize GroupBaseTypeField" });
    }

    function deserializeGroupMiniGroupTypeField(val) {
        if (val == 'managed_group') {
            return val;
        }
        if (val == 'all_users_group') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMiniGroupTypeField",
        });
    }
    function deserializeGroupMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "GroupMini"' });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "GroupMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const groupType = val.group_type == void 0
            ? void 0
            : deserializeGroupMiniGroupTypeField(val.group_type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "GroupMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "GroupMini" to be defined',
            });
        }
        const type = deserializeGroupBaseTypeField(val.type);
        return {
            name: name,
            groupType: groupType,
            id: id,
            type: type,
        };
    }

    function deserializeUserCollaborations(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserCollaborations"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserCollaborations"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserCollaborations"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserCollaborations" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserCollaborations"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserCollaborations" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function deserializeGroupMiniOrUserCollaborations(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupMiniOrUserCollaborations"',
            });
        }
        if (val.type == 'group') {
            return deserializeGroupMini(val);
        }
        if (val.type == 'user') {
            return deserializeUserCollaborations(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMiniOrUserCollaborations",
        });
    }

    function deserializeTermsOfServiceBaseTypeField(val) {
        if (val == 'terms_of_service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceBaseTypeField",
        });
    }
    function deserializeTermsOfServiceBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceBase"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TermsOfServiceBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfServiceBase"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TermsOfServiceBase" to be defined',
            });
        }
        const type = deserializeTermsOfServiceBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeCollaborationTypeField(val) {
        if (val == 'collaboration') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationTypeField",
        });
    }
    function deserializeCollaborationRoleField(val) {
        if (val == 'editor') {
            return val;
        }
        if (val == 'viewer') {
            return val;
        }
        if (val == 'previewer') {
            return val;
        }
        if (val == 'uploader') {
            return val;
        }
        if (val == 'previewer uploader') {
            return val;
        }
        if (val == 'viewer uploader') {
            return val;
        }
        if (val == 'co-owner') {
            return val;
        }
        if (val == 'owner') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationRoleField",
        });
    }
    function deserializeCollaborationStatusField(val) {
        if (val == 'accepted') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (val == 'rejected') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationStatusField",
        });
    }
    function deserializeCollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField"',
            });
        }
        if (!(val.is_accepted == void 0) && !sdIsBoolean(val.is_accepted)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accepted" of type "CollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField"',
            });
        }
        const isAccepted = val.is_accepted == void 0 ? void 0 : val.is_accepted;
        const termsOfService = val.terms_of_service == void 0
            ? void 0
            : deserializeTermsOfServiceBase(val.terms_of_service);
        return {
            isAccepted: isAccepted,
            termsOfService: termsOfService,
        };
    }
    function deserializeCollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        if (!(val.enterprise_has_strong_password_required_for_external_users == void 0) &&
            !sdIsBoolean(val.enterprise_has_strong_password_required_for_external_users)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "enterprise_has_strong_password_required_for_external_users" of type "CollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        const enterpriseHasStrongPasswordRequiredForExternalUsers = val.enterprise_has_strong_password_required_for_external_users == void 0
            ? void 0
            : val.enterprise_has_strong_password_required_for_external_users;
        if (!(val.user_has_strong_password == void 0) &&
            !sdIsBoolean(val.user_has_strong_password)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "user_has_strong_password" of type "CollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        const userHasStrongPassword = val.user_has_strong_password == void 0
            ? void 0
            : val.user_has_strong_password;
        return {
            enterpriseHasStrongPasswordRequiredForExternalUsers: enterpriseHasStrongPasswordRequiredForExternalUsers,
            userHasStrongPassword: userHasStrongPassword,
        };
    }
    function deserializeCollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        if (!(val.enterprise_has_two_factor_auth_enabled == void 0) &&
            !sdIsBoolean(val.enterprise_has_two_factor_auth_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "enterprise_has_two_factor_auth_enabled" of type "CollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        const enterpriseHasTwoFactorAuthEnabled = val.enterprise_has_two_factor_auth_enabled == void 0
            ? void 0
            : val.enterprise_has_two_factor_auth_enabled;
        if (!(val.user_has_two_factor_authentication_enabled == void 0) &&
            !sdIsBoolean(val.user_has_two_factor_authentication_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "user_has_two_factor_authentication_enabled" of type "CollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        const userHasTwoFactorAuthenticationEnabled = val.user_has_two_factor_authentication_enabled == void 0
            ? void 0
            : val.user_has_two_factor_authentication_enabled;
        return {
            enterpriseHasTwoFactorAuthEnabled: enterpriseHasTwoFactorAuthEnabled,
            userHasTwoFactorAuthenticationEnabled: userHasTwoFactorAuthenticationEnabled,
        };
    }
    function deserializeCollaborationAcceptanceRequirementsStatusField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusField"',
            });
        }
        const termsOfServiceRequirement = val.terms_of_service_requirement == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField(val.terms_of_service_requirement);
        const strongPasswordRequirement = val.strong_password_requirement == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField(val.strong_password_requirement);
        const twoFactorAuthenticationRequirement = val.two_factor_authentication_requirement == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField(val.two_factor_authentication_requirement);
        return {
            termsOfServiceRequirement: termsOfServiceRequirement,
            strongPasswordRequirement: strongPasswordRequirement,
            twoFactorAuthenticationRequirement: twoFactorAuthenticationRequirement,
        };
    }
    function deserializeCollaboration(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collaboration"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "Collaboration" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Collaboration"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "Collaboration" to be defined',
            });
        }
        const type = deserializeCollaborationTypeField(val.type);
        const item = val.item == void 0 ? void 0 : deserializeFileOrFolderOrWebLink(val.item);
        const accessibleBy = val.accessible_by == void 0
            ? void 0
            : deserializeGroupMiniOrUserCollaborations(val.accessible_by);
        if (!(val.invite_email == void 0) && !sdIsString(val.invite_email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "invite_email" of type "Collaboration"',
            });
        }
        const inviteEmail = val.invite_email == void 0 ? void 0 : val.invite_email;
        const role = val.role == void 0 ? void 0 : deserializeCollaborationRoleField(val.role);
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "Collaboration"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        if (!(val.is_access_only == void 0) && !sdIsBoolean(val.is_access_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_access_only" of type "Collaboration"',
            });
        }
        const isAccessOnly = val.is_access_only == void 0 ? void 0 : val.is_access_only;
        const status = val.status == void 0
            ? void 0
            : deserializeCollaborationStatusField(val.status);
        if (!(val.acknowledged_at == void 0) && !sdIsString(val.acknowledged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "acknowledged_at" of type "Collaboration"',
            });
        }
        const acknowledgedAt = val.acknowledged_at == void 0
            ? void 0
            : dateTimeFromString(val.acknowledged_at);
        const createdBy = val.created_by == void 0
            ? void 0
            : deserializeUserCollaborations(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Collaboration"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "Collaboration"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        const acceptanceRequirementsStatus = val.acceptance_requirements_status == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusField(val.acceptance_requirements_status);
        return {
            id: id,
            type: type,
            item: item,
            accessibleBy: accessibleBy,
            inviteEmail: inviteEmail,
            role: role,
            expiresAt: expiresAt,
            isAccessOnly: isAccessOnly,
            status: status,
            acknowledgedAt: acknowledgedAt,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            acceptanceRequirementsStatus: acceptanceRequirementsStatus,
        };
    }

    function deserializeCollaborationsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationsOrderDirectionField",
        });
    }
    function deserializeCollaborationsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "CollaborationsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeCollaborationsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeCollaborations(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collaborations"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Collaborations"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Collaborations"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Collaborations"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Collaborations"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Collaborations"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Collaborations"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeCollaborationsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Collaborations"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollaboration(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            totalCount: totalCount,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetFileCollaborationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderCollaborationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFolderCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationsOptionals {
        constructor(fields) {
            this.headers = new GetCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupCollaborationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileCollaborationsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFolderCollaborationsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollaborationsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupCollaborationsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ListCollaborationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileCollaborations(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileCollaborationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/collaborations'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborations(response.data);
            });
        }
        getFolderCollaborations(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderCollaborationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/collaborations'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborations(response.data);
            });
        }
        getCollaborations(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetCollaborationsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['status']: toString(queryParams.status),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborations(response.data);
            });
        }
        getGroupCollaborations(groupId_1) {
            return __awaiter(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new GetGroupCollaborationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId), '/collaborations'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborations(response.data);
            });
        }
    }

    function deserializeCommentBaseTypeField(val) {
        if (val == 'comment') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize CommentBaseTypeField" });
    }

    function deserializeCommentItemField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CommentItemField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CommentItemField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "CommentItemField"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        return { id: id, type: type };
    }

    function deserializeCommentFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "CommentFull"' });
        }
        if (!(val.tagged_message == void 0) && !sdIsString(val.tagged_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "tagged_message" of type "CommentFull"',
            });
        }
        const taggedMessage = val.tagged_message == void 0 ? void 0 : val.tagged_message;
        if (!(val.is_reply_comment == void 0) && !sdIsBoolean(val.is_reply_comment)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_reply_comment" of type "CommentFull"',
            });
        }
        const isReplyComment = val.is_reply_comment == void 0 ? void 0 : val.is_reply_comment;
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "CommentFull"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "CommentFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "CommentFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        const item = val.item == void 0 ? void 0 : deserializeCommentItemField(val.item);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CommentFull"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeCommentBaseTypeField(val.type);
        return {
            taggedMessage: taggedMessage,
            isReplyComment: isReplyComment,
            message: message,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            item: item,
            id: id,
            type: type,
        };
    }

    function deserializeCommentsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CommentsOrderDirectionField",
        });
    }
    function deserializeCommentsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CommentsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "CommentsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeCommentsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeComments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Comments"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Comments"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Comments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Comments"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Comments"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeCommentsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Comments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCommentFull(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetFileCommentsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileCommentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCommentByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetCommentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateCommentByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateCommentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCommentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCommentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateCommentOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateCommentHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileCommentsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCommentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateCommentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCommentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCommentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CommentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileComments(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileCommentsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/comments'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeComments(response.data);
            });
        }
        getCommentById(commentId_1) {
            return __awaiter(this, arguments, void 0, function* (commentId, optionalsInput = {}) {
                const optionals = new GetCommentByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments/', toString(commentId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCommentFull(response.data);
            });
        }
        updateCommentById(commentId_1) {
            return __awaiter(this, arguments, void 0, function* (commentId, optionalsInput = {}) {
                const optionals = new UpdateCommentByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments/', toString(commentId)), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateCommentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCommentFull(response.data);
            });
        }
        deleteCommentById(commentId_1) {
            return __awaiter(this, arguments, void 0, function* (commentId, optionalsInput = {}) {
                const optionals = new DeleteCommentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments/', toString(commentId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        createComment(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCommentOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateCommentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCommentFull(response.data);
            });
        }
    }
    function serializeUpdateCommentByIdRequestBody(val) {
        return { ['message']: val.message == void 0 ? void 0 : val.message };
    }
    function serializeCreateCommentRequestBodyItemTypeField(val) {
        return val;
    }
    function serializeCreateCommentRequestBodyItemField(val) {
        return {
            ['id']: val.id,
            ['type']: serializeCreateCommentRequestBodyItemTypeField(val.type),
        };
    }
    function serializeCreateCommentRequestBody(val) {
        return {
            ['message']: val.message,
            ['tagged_message']: val.taggedMessage == void 0 ? void 0 : val.taggedMessage,
            ['item']: serializeCreateCommentRequestBodyItemField(val.item),
        };
    }

    function deserializeTaskAssignmentTypeField(val) {
        if (val == 'task_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TaskAssignmentTypeField",
        });
    }
    function deserializeTaskAssignmentResolutionStateField(val) {
        if (val == 'completed') {
            return val;
        }
        if (val == 'incomplete') {
            return val;
        }
        if (val == 'approved') {
            return val;
        }
        if (val == 'rejected') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TaskAssignmentResolutionStateField",
        });
    }
    function deserializeTaskAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TaskAssignment"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TaskAssignment"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeTaskAssignmentTypeField(val.type);
        const item = val.item == void 0 ? void 0 : deserializeFileMini(val.item);
        const assignedTo = val.assigned_to == void 0 ? void 0 : deserializeUserMini(val.assigned_to);
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "TaskAssignment"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        if (!(val.completed_at == void 0) && !sdIsString(val.completed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "completed_at" of type "TaskAssignment"',
            });
        }
        const completedAt = val.completed_at == void 0 ? void 0 : dateTimeFromString(val.completed_at);
        if (!(val.assigned_at == void 0) && !sdIsString(val.assigned_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "assigned_at" of type "TaskAssignment"',
            });
        }
        const assignedAt = val.assigned_at == void 0 ? void 0 : dateTimeFromString(val.assigned_at);
        if (!(val.reminded_at == void 0) && !sdIsString(val.reminded_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "reminded_at" of type "TaskAssignment"',
            });
        }
        const remindedAt = val.reminded_at == void 0 ? void 0 : dateTimeFromString(val.reminded_at);
        const resolutionState = val.resolution_state == void 0
            ? void 0
            : deserializeTaskAssignmentResolutionStateField(val.resolution_state);
        const assignedBy = val.assigned_by == void 0 ? void 0 : deserializeUserMini(val.assigned_by);
        return {
            id: id,
            type: type,
            item: item,
            assignedTo: assignedTo,
            message: message,
            completedAt: completedAt,
            assignedAt: assignedAt,
            remindedAt: remindedAt,
            resolutionState: resolutionState,
            assignedBy: assignedBy,
        };
    }

    function deserializeTaskAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TaskAssignments"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TaskAssignments"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TaskAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTaskAssignment(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    function deserializeTaskTypeField(val) {
        if (val == 'task') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TaskTypeField" });
    }
    function deserializeTaskActionField(val) {
        if (val == 'review') {
            return val;
        }
        if (val == 'complete') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TaskActionField" });
    }
    function deserializeTaskCompletionRuleField(val) {
        if (val == 'all_assignees') {
            return val;
        }
        if (val == 'any_assignee') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TaskCompletionRuleField",
        });
    }
    function deserializeTask(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Task"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Task"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeTaskTypeField(val.type);
        const item = val.item == void 0 ? void 0 : deserializeFileMini(val.item);
        if (!(val.due_at == void 0) && !sdIsString(val.due_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "due_at" of type "Task"',
            });
        }
        const dueAt = val.due_at == void 0 ? void 0 : dateTimeFromString(val.due_at);
        const action = val.action == void 0 ? void 0 : deserializeTaskActionField(val.action);
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "Task"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        const taskAssignmentCollection = val.task_assignment_collection == void 0
            ? void 0
            : deserializeTaskAssignments(val.task_assignment_collection);
        if (!(val.is_completed == void 0) && !sdIsBoolean(val.is_completed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_completed" of type "Task"',
            });
        }
        const isCompleted = val.is_completed == void 0 ? void 0 : val.is_completed;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Task"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const completionRule = val.completion_rule == void 0
            ? void 0
            : deserializeTaskCompletionRuleField(val.completion_rule);
        return {
            id: id,
            type: type,
            item: item,
            dueAt: dueAt,
            action: action,
            message: message,
            taskAssignmentCollection: taskAssignmentCollection,
            isCompleted: isCompleted,
            createdBy: createdBy,
            createdAt: createdAt,
            completionRule: completionRule,
        };
    }

    function deserializeTasks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Tasks"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Tasks"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Tasks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTask(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    class GetFileTasksOptionals {
        constructor(fields) {
            this.headers = new GetFileTasksHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateTaskOptionals {
        constructor(fields) {
            this.headers = new CreateTaskHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTaskByIdOptionals {
        constructor(fields) {
            this.headers = new GetTaskByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTaskByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateTaskByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTaskByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTaskByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileTasksHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTaskHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTaskByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTaskByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTaskByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TasksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileTasks(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileTasksOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/tasks'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTasks(response.data);
            });
        }
        createTask(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTaskOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTaskRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTask(response.data);
            });
        }
        getTaskById(taskId_1) {
            return __awaiter(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new GetTaskByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTask(response.data);
            });
        }
        updateTaskById(taskId_1) {
            return __awaiter(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new UpdateTaskByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTaskByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTask(response.data);
            });
        }
        deleteTaskById(taskId_1) {
            return __awaiter(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new DeleteTaskByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateTaskRequestBodyItemTypeField(val) {
        return val;
    }
    function serializeCreateTaskRequestBodyItemField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializeCreateTaskRequestBodyItemTypeField(val.type),
        };
    }
    function serializeCreateTaskRequestBodyActionField(val) {
        return val;
    }
    function serializeCreateTaskRequestBodyCompletionRuleField(val) {
        return val;
    }
    function serializeCreateTaskRequestBody(val) {
        return {
            ['item']: serializeCreateTaskRequestBodyItemField(val.item),
            ['action']: val.action == void 0
                ? void 0
                : serializeCreateTaskRequestBodyActionField(val.action),
            ['message']: val.message == void 0 ? void 0 : val.message,
            ['due_at']: val.dueAt == void 0 ? void 0 : dateTimeToString(val.dueAt),
            ['completion_rule']: val.completionRule == void 0
                ? void 0
                : serializeCreateTaskRequestBodyCompletionRuleField(val.completionRule),
        };
    }
    function serializeUpdateTaskByIdRequestBodyActionField(val) {
        return val;
    }
    function serializeUpdateTaskByIdRequestBodyCompletionRuleField(val) {
        return val;
    }
    function serializeUpdateTaskByIdRequestBody(val) {
        return {
            ['action']: val.action == void 0
                ? void 0
                : serializeUpdateTaskByIdRequestBodyActionField(val.action),
            ['message']: val.message == void 0 ? void 0 : val.message,
            ['due_at']: val.dueAt == void 0 ? void 0 : dateTimeToString(val.dueAt),
            ['completion_rule']: val.completionRule == void 0
                ? void 0
                : serializeUpdateTaskByIdRequestBodyCompletionRuleField(val.completionRule),
        };
    }

    function deserializeFileVersionFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileVersionFull"' });
        }
        if (!(val.version_number == void 0) && !sdIsString(val.version_number)) {
            throw new BoxSdkError({
                message: 'Expecting string for "version_number" of type "FileVersionFull"',
            });
        }
        const versionNumber = val.version_number == void 0 ? void 0 : val.version_number;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileVersionFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "FileVersionFull"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileVersionFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "FileVersionFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "FileVersionFull"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        const trashedBy = val.trashed_by == void 0 ? void 0 : deserializeUserMini(val.trashed_by);
        if (!(val.restored_at == void 0) && !sdIsString(val.restored_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "restored_at" of type "FileVersionFull"',
            });
        }
        const restoredAt = val.restored_at == void 0 ? void 0 : dateTimeFromString(val.restored_at);
        const restoredBy = val.restored_by == void 0 ? void 0 : deserializeUserMini(val.restored_by);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "FileVersionFull"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.uploader_display_name == void 0) &&
            !sdIsString(val.uploader_display_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "uploader_display_name" of type "FileVersionFull"',
            });
        }
        const uploaderDisplayName = val.uploader_display_name == void 0 ? void 0 : val.uploader_display_name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileVersionFull"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileVersionFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionFull"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileVersionFull" to be defined',
            });
        }
        const type = deserializeFileVersionBaseTypeField(val.type);
        return {
            versionNumber: versionNumber,
            name: name,
            size: size,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            trashedBy: trashedBy,
            restoredAt: restoredAt,
            restoredBy: restoredBy,
            purgedAt: purgedAt,
            uploaderDisplayName: uploaderDisplayName,
            sha1: sha1,
            id: id,
            type: type,
        };
    }

    function deserializeFileVersionsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionsOrderDirectionField",
        });
    }
    function deserializeFileVersionsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "FileVersionsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeFileVersionsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeFileVersions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileVersions"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "FileVersions"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FileVersions"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "FileVersions"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "FileVersions"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeFileVersionsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileVersions"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileVersionFull(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetFileVersionsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileVersionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileVersionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileVersionByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateFileVersionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileVersionByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileVersionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class PromoteFileVersionOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new PromoteFileVersionHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileVersionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileVersionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileVersionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class PromoteFileVersionHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileVersionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileVersions(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileVersionsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersions(response.data);
            });
        }
        getFileVersionById(fileId_1, fileVersionId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, fileVersionId, optionalsInput = {}) {
                const optionals = new GetFileVersionByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/', toString(fileVersionId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersionFull(response.data);
            });
        }
        updateFileVersionById(fileId_1, fileVersionId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, fileVersionId, optionalsInput = {}) {
                const optionals = new UpdateFileVersionByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/', toString(fileVersionId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateFileVersionByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersionFull(response.data);
            });
        }
        deleteFileVersionById(fileId_1, fileVersionId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, fileVersionId, optionalsInput = {}) {
                const optionals = new DeleteFileVersionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/', toString(fileVersionId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        promoteFileVersion(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new PromoteFileVersionOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/current'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializePromoteFileVersionRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersionFull(response.data);
            });
        }
    }
    function serializeUpdateFileVersionByIdRequestBody(val) {
        return { ['trashed_at']: val.trashedAt == void 0 ? void 0 : val.trashedAt };
    }
    function serializePromoteFileVersionRequestBodyTypeField(val) {
        return val;
    }
    function serializePromoteFileVersionRequestBody(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializePromoteFileVersionRequestBodyTypeField(val.type),
        };
    }

    function deserializeMetadatas(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Metadatas"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Metadatas"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeMetadata(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Metadatas"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        return { entries: entries, limit: limit };
    }

    function deserializeMetadataFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "MetadataFull"' });
        }
        if (!(val.$canEdit == void 0) && !sdIsBoolean(val.$canEdit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "$canEdit" of type "MetadataFull"',
            });
        }
        const canEdit = val.$canEdit == void 0 ? void 0 : val.$canEdit;
        if (!(val.$id == void 0) && !sdIsString(val.$id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$id" of type "MetadataFull"',
            });
        }
        const id = val.$id == void 0 ? void 0 : val.$id;
        if (!(val.$type == void 0) && !sdIsString(val.$type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$type" of type "MetadataFull"',
            });
        }
        const type = val.$type == void 0 ? void 0 : val.$type;
        if (!(val.$typeVersion == void 0) && !sdIsNumber(val.$typeVersion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$typeVersion" of type "MetadataFull"',
            });
        }
        const typeVersion = val.$typeVersion == void 0 ? void 0 : val.$typeVersion;
        if (!(val == void 0) && !sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting object for "extraData" of type "MetadataFull"',
            });
        }
        const extraData = val == void 0
            ? void 0
            : sdIsMap(val)
                ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                    k,
                    (function (v) {
                        return v;
                    })(v),
                ]))
                : {};
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "MetadataFull"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        if (!(val.$template == void 0) && !sdIsString(val.$template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$template" of type "MetadataFull"',
            });
        }
        const template = val.$template == void 0 ? void 0 : val.$template;
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "MetadataFull"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "MetadataFull"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        return {
            canEdit: canEdit,
            id: id,
            type: type,
            typeVersion: typeVersion,
            extraData: extraData,
            parent: parent,
            template: template,
            scope: scope,
            version: version,
        };
    }

    class GetFileMetadataOptionals {
        constructor(fields) {
            this.headers = new GetFileMetadataHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new CreateFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileMetadataHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileMetadataManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileMetadata(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileMetadataOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadatas(response.data);
            });
        }
        getFileMetadataById(fileId_1, scope_1, templateKey_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, scope, templateKey, optionalsInput = {}) {
                const optionals = new GetFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataFull(response.data);
            });
        }
        createFileMetadataById(fileId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new CreateFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileMetadataByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataFull(response.data);
            });
        }
        updateFileMetadataById(fileId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateFileMetadataByIdRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataFull(response.data);
            });
        }
        deleteFileMetadataById(fileId_1, scope_1, templateKey_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, scope, templateKey, optionalsInput = {}) {
                const optionals = new DeleteFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateFileMetadataByIdRequestBody(val) {
        return Object.fromEntries(Object.entries(val).map(([k, v]) => [
            k,
            (function (v) {
                return v;
            })(v),
        ]));
    }
    function serializeUpdateFileMetadataByIdRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateFileMetadataByIdRequestBody(val) {
        return {
            ['op']: val.op == void 0
                ? void 0
                : serializeUpdateFileMetadataByIdRequestBodyOpField(val.op),
            ['path']: val.path == void 0 ? void 0 : val.path,
            ['value']: val.value == void 0 ? void 0 : val.value,
            ['from']: val.from == void 0 ? void 0 : val.from,
        };
    }

    function deserializeClassificationTemplateField(val) {
        if (val == 'securityClassification-6VMVochwUWo') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateField",
        });
    }
    function deserializeClassification(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Classification"' });
        }
        if (!(val.Box__Security__Classification__Key == void 0) &&
            !sdIsString(val.Box__Security__Classification__Key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "Box__Security__Classification__Key" of type "Classification"',
            });
        }
        const boxSecurityClassificationKey = val.Box__Security__Classification__Key == void 0
            ? void 0
            : val.Box__Security__Classification__Key;
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "Classification"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        const template = val.$template == void 0
            ? void 0
            : deserializeClassificationTemplateField(val.$template);
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "Classification"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "Classification"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        if (!(val.$type == void 0) && !sdIsString(val.$type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$type" of type "Classification"',
            });
        }
        const type = val.$type == void 0 ? void 0 : val.$type;
        if (!(val.$typeVersion == void 0) && !sdIsNumber(val.$typeVersion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$typeVersion" of type "Classification"',
            });
        }
        const typeVersion = val.$typeVersion == void 0 ? void 0 : val.$typeVersion;
        if (!(val.$canEdit == void 0) && !sdIsBoolean(val.$canEdit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "$canEdit" of type "Classification"',
            });
        }
        const canEdit = val.$canEdit == void 0 ? void 0 : val.$canEdit;
        return {
            boxSecurityClassificationKey: boxSecurityClassificationKey,
            parent: parent,
            template: template,
            scope: scope,
            version: version,
            type: type,
            typeVersion: typeVersion,
            canEdit: canEdit,
        };
    }

    class GetClassificationOnFileOptionals {
        constructor(fields) {
            this.headers = new GetClassificationOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddClassificationToFileOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new AddClassificationToFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateClassificationOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateClassificationOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteClassificationFromFileOptionals {
        constructor(fields) {
            this.headers = new DeleteClassificationFromFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetClassificationOnFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddClassificationToFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateClassificationOnFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteClassificationFromFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileClassificationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getClassificationOnFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetClassificationOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassification(response.data);
            });
        }
        addClassificationToFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new AddClassificationToFileOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAddClassificationToFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassification(response.data);
            });
        }
        updateClassificationOnFile(fileId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateClassificationOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateClassificationOnFileRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassification(response.data);
            });
        }
        deleteClassificationFromFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteClassificationFromFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeAddClassificationToFileRequestBody(val) {
        return {
            ['Box__Security__Classification__Key']: val.boxSecurityClassificationKey == void 0
                ? void 0
                : val.boxSecurityClassificationKey,
        };
    }
    function serializeUpdateClassificationOnFileRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFileRequestBodyPathField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFileRequestBody(val) {
        return {
            ['op']: serializeUpdateClassificationOnFileRequestBodyOpField(val.op),
            ['path']: serializeUpdateClassificationOnFileRequestBodyPathField(val.path),
            ['value']: val.value,
        };
    }

    function serializeKeywordSkillCardTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardTypeField",
        });
    }
    function serializeKeywordSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardSkillCardTypeField(val) {
        if (val == 'keyword') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardSkillCardTypeField",
        });
    }
    function serializeKeywordSkillCardSkillCardTitleField(val) {
        return {
            ['code']: val.code == void 0 ? void 0 : val.code,
            ['message']: val.message,
        };
    }
    function deserializeKeywordSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "KeywordSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "KeywordSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "KeywordSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeKeywordSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardSkillTypeField",
        });
    }
    function serializeKeywordSkillCardSkillField(val) {
        return {
            ['type']: serializeKeywordSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeKeywordSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "KeywordSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeKeywordSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "KeywordSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "KeywordSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeKeywordSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardInvocationTypeField",
        });
    }
    function serializeKeywordSkillCardInvocationField(val) {
        return {
            ['type']: serializeKeywordSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeKeywordSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "KeywordSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeKeywordSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "KeywordSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "KeywordSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeKeywordSkillCardEntriesField(val) {
        return { ['text']: val.text == void 0 ? void 0 : val.text };
    }
    function deserializeKeywordSkillCardEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardEntriesField"',
            });
        }
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "KeywordSkillCardEntriesField"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        return { text: text };
    }
    function serializeKeywordSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0 ? void 0 : dateTimeToString(val.createdAt),
            ['type']: serializeKeywordSkillCardTypeField(val.type),
            ['skill_card_type']: serializeKeywordSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? void 0
                : serializeKeywordSkillCardSkillCardTitleField(val.skillCardTitle),
            ['skill']: serializeKeywordSkillCardSkillField(val.skill),
            ['invocation']: serializeKeywordSkillCardInvocationField(val.invocation),
            ['entries']: val.entries.map(function (item) {
                return serializeKeywordSkillCardEntriesField(item);
            }),
        };
    }
    function deserializeKeywordSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCard"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "KeywordSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "KeywordSkillCard" to be defined',
            });
        }
        const type = deserializeKeywordSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "KeywordSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeKeywordSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeKeywordSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "KeywordSkillCard" to be defined',
            });
        }
        const skill = deserializeKeywordSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "KeywordSkillCard" to be defined',
            });
        }
        const invocation = deserializeKeywordSkillCardInvocationField(val.invocation);
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "KeywordSkillCard" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "KeywordSkillCard"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeKeywordSkillCardEntriesField(itm);
            })
            : [];
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            skill: skill,
            invocation: invocation,
            entries: entries,
        };
    }

    function serializeStatusSkillCardTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardTypeField",
        });
    }
    function serializeStatusSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardSkillCardTypeField(val) {
        if (val == 'status') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardSkillCardTypeField",
        });
    }
    function serializeStatusSkillCardSkillCardTitleField(val) {
        return {
            ['code']: val.code == void 0 ? void 0 : val.code,
            ['message']: val.message,
        };
    }
    function deserializeStatusSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "StatusSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "StatusSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "StatusSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeStatusSkillCardStatusCodeField(val) {
        return val;
    }
    function deserializeStatusSkillCardStatusCodeField(val) {
        if (val == 'invoked') {
            return val;
        }
        if (val == 'processing') {
            return val;
        }
        if (val == 'success') {
            return val;
        }
        if (val == 'transient_failure') {
            return val;
        }
        if (val == 'permanent_failure') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardStatusCodeField",
        });
    }
    function serializeStatusSkillCardStatusField(val) {
        return {
            ['code']: serializeStatusSkillCardStatusCodeField(val.code),
            ['message']: val.message == void 0 ? void 0 : val.message,
        };
    }
    function deserializeStatusSkillCardStatusField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardStatusField"',
            });
        }
        if (val.code == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "code" of type "StatusSkillCardStatusField" to be defined',
            });
        }
        const code = deserializeStatusSkillCardStatusCodeField(val.code);
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "StatusSkillCardStatusField"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        return { code: code, message: message };
    }
    function serializeStatusSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardSkillTypeField",
        });
    }
    function serializeStatusSkillCardSkillField(val) {
        return {
            ['type']: serializeStatusSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeStatusSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StatusSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeStatusSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StatusSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StatusSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeStatusSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardInvocationTypeField",
        });
    }
    function serializeStatusSkillCardInvocationField(val) {
        return {
            ['type']: serializeStatusSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeStatusSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StatusSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeStatusSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StatusSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StatusSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeStatusSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0 ? void 0 : dateTimeToString(val.createdAt),
            ['type']: serializeStatusSkillCardTypeField(val.type),
            ['skill_card_type']: serializeStatusSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? void 0
                : serializeStatusSkillCardSkillCardTitleField(val.skillCardTitle),
            ['status']: serializeStatusSkillCardStatusField(val.status),
            ['skill']: serializeStatusSkillCardSkillField(val.skill),
            ['invocation']: serializeStatusSkillCardInvocationField(val.invocation),
        };
    }
    function deserializeStatusSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "StatusSkillCard"' });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "StatusSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StatusSkillCard" to be defined',
            });
        }
        const type = deserializeStatusSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "StatusSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeStatusSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeStatusSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "status" of type "StatusSkillCard" to be defined',
            });
        }
        const status = deserializeStatusSkillCardStatusField(val.status);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "StatusSkillCard" to be defined',
            });
        }
        const skill = deserializeStatusSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "StatusSkillCard" to be defined',
            });
        }
        const invocation = deserializeStatusSkillCardInvocationField(val.invocation);
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            status: status,
            skill: skill,
            invocation: invocation,
        };
    }

    function serializeTimelineSkillCardTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardTypeField",
        });
    }
    function serializeTimelineSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardSkillCardTypeField(val) {
        if (val == 'timeline') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardSkillCardTypeField",
        });
    }
    function serializeTimelineSkillCardSkillCardTitleField(val) {
        return {
            ['code']: val.code == void 0 ? void 0 : val.code,
            ['message']: val.message,
        };
    }
    function deserializeTimelineSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "TimelineSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "TimelineSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "TimelineSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeTimelineSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardSkillTypeField",
        });
    }
    function serializeTimelineSkillCardSkillField(val) {
        return {
            ['type']: serializeTimelineSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTimelineSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TimelineSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeTimelineSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TimelineSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TimelineSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTimelineSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardInvocationTypeField",
        });
    }
    function serializeTimelineSkillCardInvocationField(val) {
        return {
            ['type']: serializeTimelineSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTimelineSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TimelineSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeTimelineSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TimelineSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TimelineSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTimelineSkillCardEntriesAppearsField(val) {
        return {
            ['start']: val.start == void 0 ? void 0 : val.start,
            ['end']: val.end == void 0 ? void 0 : val.end,
        };
    }
    function deserializeTimelineSkillCardEntriesAppearsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardEntriesAppearsField"',
            });
        }
        if (!(val.start == void 0) && !sdIsNumber(val.start)) {
            throw new BoxSdkError({
                message: 'Expecting number for "start" of type "TimelineSkillCardEntriesAppearsField"',
            });
        }
        const start = val.start == void 0 ? void 0 : val.start;
        if (!(val.end == void 0) && !sdIsNumber(val.end)) {
            throw new BoxSdkError({
                message: 'Expecting number for "end" of type "TimelineSkillCardEntriesAppearsField"',
            });
        }
        const end = val.end == void 0 ? void 0 : val.end;
        return {
            start: start,
            end: end,
        };
    }
    function serializeTimelineSkillCardEntriesField(val) {
        return {
            ['text']: val.text == void 0 ? void 0 : val.text,
            ['appears']: val.appears == void 0
                ? void 0
                : val.appears.map(function (item) {
                    return serializeTimelineSkillCardEntriesAppearsField(item);
                }),
            ['image_url']: val.imageUrl == void 0 ? void 0 : val.imageUrl,
        };
    }
    function deserializeTimelineSkillCardEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardEntriesField"',
            });
        }
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "TimelineSkillCardEntriesField"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        if (!(val.appears == void 0) && !sdIsList(val.appears)) {
            throw new BoxSdkError({
                message: 'Expecting array for "appears" of type "TimelineSkillCardEntriesField"',
            });
        }
        const appears = val.appears == void 0
            ? void 0
            : sdIsList(val.appears)
                ? val.appears.map(function (itm) {
                    return deserializeTimelineSkillCardEntriesAppearsField(itm);
                })
                : [];
        if (!(val.image_url == void 0) && !sdIsString(val.image_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "image_url" of type "TimelineSkillCardEntriesField"',
            });
        }
        const imageUrl = val.image_url == void 0 ? void 0 : val.image_url;
        return {
            text: text,
            appears: appears,
            imageUrl: imageUrl,
        };
    }
    function serializeTimelineSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0 ? void 0 : dateTimeToString(val.createdAt),
            ['type']: serializeTimelineSkillCardTypeField(val.type),
            ['skill_card_type']: serializeTimelineSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? void 0
                : serializeTimelineSkillCardSkillCardTitleField(val.skillCardTitle),
            ['skill']: serializeTimelineSkillCardSkillField(val.skill),
            ['invocation']: serializeTimelineSkillCardInvocationField(val.invocation),
            ['duration']: val.duration == void 0 ? void 0 : val.duration,
            ['entries']: val.entries.map(function (item) {
                return serializeTimelineSkillCardEntriesField(item);
            }),
        };
    }
    function deserializeTimelineSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCard"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TimelineSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TimelineSkillCard" to be defined',
            });
        }
        const type = deserializeTimelineSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "TimelineSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeTimelineSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeTimelineSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "TimelineSkillCard" to be defined',
            });
        }
        const skill = deserializeTimelineSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "TimelineSkillCard" to be defined',
            });
        }
        const invocation = deserializeTimelineSkillCardInvocationField(val.invocation);
        if (!(val.duration == void 0) && !sdIsNumber(val.duration)) {
            throw new BoxSdkError({
                message: 'Expecting number for "duration" of type "TimelineSkillCard"',
            });
        }
        const duration = val.duration == void 0 ? void 0 : val.duration;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TimelineSkillCard" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TimelineSkillCard"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTimelineSkillCardEntriesField(itm);
            })
            : [];
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            skill: skill,
            invocation: invocation,
            duration: duration,
            entries: entries,
        };
    }

    function serializeTranscriptSkillCardTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardTypeField",
        });
    }
    function serializeTranscriptSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardSkillCardTypeField(val) {
        if (val == 'transcript') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardSkillCardTypeField",
        });
    }
    function serializeTranscriptSkillCardSkillCardTitleField(val) {
        return {
            ['code']: val.code == void 0 ? void 0 : val.code,
            ['message']: val.message,
        };
    }
    function deserializeTranscriptSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "TranscriptSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "TranscriptSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "TranscriptSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeTranscriptSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardSkillTypeField",
        });
    }
    function serializeTranscriptSkillCardSkillField(val) {
        return {
            ['type']: serializeTranscriptSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTranscriptSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TranscriptSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeTranscriptSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TranscriptSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TranscriptSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTranscriptSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardInvocationTypeField",
        });
    }
    function serializeTranscriptSkillCardInvocationField(val) {
        return {
            ['type']: serializeTranscriptSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTranscriptSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TranscriptSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeTranscriptSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TranscriptSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TranscriptSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTranscriptSkillCardEntriesAppearsField(val) {
        return { ['start']: val.start == void 0 ? void 0 : val.start };
    }
    function deserializeTranscriptSkillCardEntriesAppearsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardEntriesAppearsField"',
            });
        }
        if (!(val.start == void 0) && !sdIsNumber(val.start)) {
            throw new BoxSdkError({
                message: 'Expecting number for "start" of type "TranscriptSkillCardEntriesAppearsField"',
            });
        }
        const start = val.start == void 0 ? void 0 : val.start;
        return { start: start };
    }
    function serializeTranscriptSkillCardEntriesField(val) {
        return {
            ['text']: val.text == void 0 ? void 0 : val.text,
            ['appears']: val.appears == void 0
                ? void 0
                : val.appears.map(function (item) {
                    return serializeTranscriptSkillCardEntriesAppearsField(item);
                }),
        };
    }
    function deserializeTranscriptSkillCardEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardEntriesField"',
            });
        }
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "TranscriptSkillCardEntriesField"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        if (!(val.appears == void 0) && !sdIsList(val.appears)) {
            throw new BoxSdkError({
                message: 'Expecting array for "appears" of type "TranscriptSkillCardEntriesField"',
            });
        }
        const appears = val.appears == void 0
            ? void 0
            : sdIsList(val.appears)
                ? val.appears.map(function (itm) {
                    return deserializeTranscriptSkillCardEntriesAppearsField(itm);
                })
                : [];
        return {
            text: text,
            appears: appears,
        };
    }
    function serializeTranscriptSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0 ? void 0 : dateTimeToString(val.createdAt),
            ['type']: serializeTranscriptSkillCardTypeField(val.type),
            ['skill_card_type']: serializeTranscriptSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? void 0
                : serializeTranscriptSkillCardSkillCardTitleField(val.skillCardTitle),
            ['skill']: serializeTranscriptSkillCardSkillField(val.skill),
            ['invocation']: serializeTranscriptSkillCardInvocationField(val.invocation),
            ['duration']: val.duration == void 0 ? void 0 : val.duration,
            ['entries']: val.entries.map(function (item) {
                return serializeTranscriptSkillCardEntriesField(item);
            }),
        };
    }
    function deserializeTranscriptSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCard"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TranscriptSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TranscriptSkillCard" to be defined',
            });
        }
        const type = deserializeTranscriptSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "TranscriptSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeTranscriptSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeTranscriptSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "TranscriptSkillCard" to be defined',
            });
        }
        const skill = deserializeTranscriptSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "TranscriptSkillCard" to be defined',
            });
        }
        const invocation = deserializeTranscriptSkillCardInvocationField(val.invocation);
        if (!(val.duration == void 0) && !sdIsNumber(val.duration)) {
            throw new BoxSdkError({
                message: 'Expecting number for "duration" of type "TranscriptSkillCard"',
            });
        }
        const duration = val.duration == void 0 ? void 0 : val.duration;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TranscriptSkillCard" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TranscriptSkillCard"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTranscriptSkillCardEntriesField(itm);
            })
            : [];
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            skill: skill,
            invocation: invocation,
            duration: duration,
            entries: entries,
        };
    }

    function serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(val) {
        if (val.skillCardType == 'keyword') {
            return serializeKeywordSkillCard(val);
        }
        if (val.skillCardType == 'status') {
            return serializeStatusSkillCard(val);
        }
        if (val.skillCardType == 'timeline') {
            return serializeTimelineSkillCard(val);
        }
        if (val.skillCardType == 'transcript') {
            return serializeTranscriptSkillCard(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }
    function deserializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard"',
            });
        }
        if (val.skill_card_type == 'keyword') {
            return deserializeKeywordSkillCard(val);
        }
        if (val.skill_card_type == 'status') {
            return deserializeStatusSkillCard(val);
        }
        if (val.skill_card_type == 'timeline') {
            return deserializeTimelineSkillCard(val);
        }
        if (val.skill_card_type == 'transcript') {
            return deserializeTranscriptSkillCard(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard",
        });
    }

    function deserializeSkillCardsMetadata(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SkillCardsMetadata"',
            });
        }
        if (!(val.$canEdit == void 0) && !sdIsBoolean(val.$canEdit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "$canEdit" of type "SkillCardsMetadata"',
            });
        }
        const canEdit = val.$canEdit == void 0 ? void 0 : val.$canEdit;
        if (!(val.$id == void 0) && !sdIsString(val.$id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$id" of type "SkillCardsMetadata"',
            });
        }
        const id = val.$id == void 0 ? void 0 : val.$id;
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "SkillCardsMetadata"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "SkillCardsMetadata"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$template == void 0) && !sdIsString(val.$template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$template" of type "SkillCardsMetadata"',
            });
        }
        const template = val.$template == void 0 ? void 0 : val.$template;
        if (!(val.$type == void 0) && !sdIsString(val.$type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$type" of type "SkillCardsMetadata"',
            });
        }
        const type = val.$type == void 0 ? void 0 : val.$type;
        if (!(val.$typeVersion == void 0) && !sdIsNumber(val.$typeVersion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$typeVersion" of type "SkillCardsMetadata"',
            });
        }
        const typeVersion = val.$typeVersion == void 0 ? void 0 : val.$typeVersion;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "SkillCardsMetadata"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        if (!(val.cards == void 0) && !sdIsList(val.cards)) {
            throw new BoxSdkError({
                message: 'Expecting array for "cards" of type "SkillCardsMetadata"',
            });
        }
        const cards = val.cards == void 0
            ? void 0
            : sdIsList(val.cards)
                ? val.cards.map(function (itm) {
                    return deserializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(itm);
                })
                : [];
        return {
            canEdit: canEdit,
            id: id,
            parent: parent,
            scope: scope,
            template: template,
            type: type,
            typeVersion: typeVersion,
            version: version,
            cards: cards,
        };
    }

    class GetBoxSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new GetBoxSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateBoxSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new CreateBoxSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateBoxSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateBoxSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteBoxSkillCardsFromFileOptionals {
        constructor(fields) {
            this.headers = new DeleteBoxSkillCardsFromFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateAllSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateAllSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetBoxSkillCardsOnFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateBoxSkillCardsOnFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateBoxSkillCardsOnFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteBoxSkillCardsFromFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateAllSkillCardsOnFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SkillsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getBoxSkillCardsOnFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetBoxSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSkillCardsMetadata(response.data);
            });
        }
        createBoxSkillCardsOnFile(fileId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new CreateBoxSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateBoxSkillCardsOnFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSkillCardsMetadata(response.data);
            });
        }
        updateBoxSkillCardsOnFile(fileId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateBoxSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateBoxSkillCardsOnFileRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSkillCardsMetadata(response.data);
            });
        }
        deleteBoxSkillCardsFromFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteBoxSkillCardsFromFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        updateAllSkillCardsOnFile(skillId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (skillId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateAllSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/skill_invocations/', toString(skillId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateAllSkillCardsOnFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateBoxSkillCardsOnFileRequestBody(val) {
        return {
            ['cards']: val.cards.map(function (item) {
                return serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(item);
            }),
        };
    }
    function serializeUpdateBoxSkillCardsOnFileRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateBoxSkillCardsOnFileRequestBody(val) {
        return {
            ['op']: val.op == void 0
                ? void 0
                : serializeUpdateBoxSkillCardsOnFileRequestBodyOpField(val.op),
            ['path']: val.path == void 0 ? void 0 : val.path,
            ['value']: val.value == void 0
                ? void 0
                : serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(val.value),
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyMetadataField(val) {
        return {
            ['cards']: val.cards == void 0
                ? void 0
                : val.cards.map(function (item) {
                    return serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(item);
                }),
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileTypeField(val) {
        return val;
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileField(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeUpdateAllSkillCardsOnFileRequestBodyFileTypeField(val.type),
            ['id']: val.id == void 0 ? void 0 : val.id,
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionTypeField(val) {
        return val;
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionField(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionTypeField(val.type),
            ['id']: val.id == void 0 ? void 0 : val.id,
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyUsageField(val) {
        return {
            ['unit']: val.unit == void 0 ? void 0 : val.unit,
            ['value']: val.value == void 0 ? void 0 : val.value,
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBody(val) {
        return {
            ['status']: serializeUpdateAllSkillCardsOnFileRequestBodyStatusField(val.status),
            ['metadata']: serializeUpdateAllSkillCardsOnFileRequestBodyMetadataField(val.metadata),
            ['file']: serializeUpdateAllSkillCardsOnFileRequestBodyFileField(val.file),
            ['file_version']: val.fileVersion == void 0
                ? void 0
                : serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionField(val.fileVersion),
            ['usage']: val.usage == void 0
                ? void 0
                : serializeUpdateAllSkillCardsOnFileRequestBodyUsageField(val.usage),
        };
    }

    function deserializeWatermarkWatermarkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WatermarkWatermarkField"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "WatermarkWatermarkField"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "WatermarkWatermarkField"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }
    function deserializeWatermark(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Watermark"' });
        }
        const watermark = val.watermark == void 0
            ? void 0
            : deserializeWatermarkWatermarkField(val.watermark);
        return { watermark: watermark };
    }

    class GetFileWatermarkOptionals {
        constructor(fields) {
            this.headers = new GetFileWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileWatermarkOptionals {
        constructor(fields) {
            this.headers = new UpdateFileWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileWatermarkOptionals {
        constructor(fields) {
            this.headers = new DeleteFileWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileWatermarkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileWatermarkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileWatermarkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileWatermarksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileWatermark(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/watermark'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWatermark(response.data);
            });
        }
        updateFileWatermark(fileId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFileWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/watermark'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateFileWatermarkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWatermark(response.data);
            });
        }
        deleteFileWatermark(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteFileWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/watermark'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeUpdateFileWatermarkRequestBodyWatermarkImprintField(val) {
        return val;
    }
    function serializeUpdateFileWatermarkRequestBodyWatermarkField(val) {
        return {
            ['imprint']: serializeUpdateFileWatermarkRequestBodyWatermarkImprintField(val.imprint),
        };
    }
    function serializeUpdateFileWatermarkRequestBody(val) {
        return {
            ['watermark']: serializeUpdateFileWatermarkRequestBodyWatermarkField(val.watermark),
        };
    }

    function deserializeFileRequestTypeField(val) {
        if (val == 'file_request') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileRequestTypeField" });
    }
    function deserializeFileRequestStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'inactive') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileRequestStatusField",
        });
    }
    function deserializeFileRequest(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileRequest"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileRequest" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileRequest"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileRequest" to be defined',
            });
        }
        const type = deserializeFileRequestTypeField(val.type);
        if (!(val.title == void 0) && !sdIsString(val.title)) {
            throw new BoxSdkError({
                message: 'Expecting string for "title" of type "FileRequest"',
            });
        }
        const title = val.title == void 0 ? void 0 : val.title;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "FileRequest"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const status = val.status == void 0
            ? void 0
            : deserializeFileRequestStatusField(val.status);
        if (!(val.is_email_required == void 0) &&
            !sdIsBoolean(val.is_email_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_email_required" of type "FileRequest"',
            });
        }
        const isEmailRequired = val.is_email_required == void 0 ? void 0 : val.is_email_required;
        if (!(val.is_description_required == void 0) &&
            !sdIsBoolean(val.is_description_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_description_required" of type "FileRequest"',
            });
        }
        const isDescriptionRequired = val.is_description_required == void 0
            ? void 0
            : val.is_description_required;
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "FileRequest"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        if (val.folder == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "folder" of type "FileRequest" to be defined',
            });
        }
        const folder = deserializeFolderMini(val.folder);
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileRequest"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileRequest"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "FileRequest" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileRequest"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserMini(val.updated_by);
        if (val.updated_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "updated_at" of type "FileRequest" to be defined',
            });
        }
        if (!sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "FileRequest"',
            });
        }
        const updatedAt = dateTimeFromString(val.updated_at);
        return {
            id: id,
            type: type,
            title: title,
            description: description,
            status: status,
            isEmailRequired: isEmailRequired,
            isDescriptionRequired: isDescriptionRequired,
            expiresAt: expiresAt,
            folder: folder,
            url: url,
            etag: etag,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedBy: updatedBy,
            updatedAt: updatedAt,
        };
    }

    function serializeFileRequestUpdateRequestStatusField(val) {
        return val;
    }
    function serializeFileRequestUpdateRequest(val) {
        return {
            ['title']: val.title == void 0 ? void 0 : val.title,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['status']: val.status == void 0
                ? void 0
                : serializeFileRequestUpdateRequestStatusField(val.status),
            ['is_email_required']: val.isEmailRequired == void 0 ? void 0 : val.isEmailRequired,
            ['is_description_required']: val.isDescriptionRequired == void 0 ? void 0 : val.isDescriptionRequired,
            ['expires_at']: val.expiresAt == void 0 ? void 0 : dateTimeToString(val.expiresAt),
        };
    }

    function serializeFileRequestCopyRequestFolderTypeField(val) {
        return val;
    }
    function serializeFileRequestCopyRequestFolderField(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeFileRequestCopyRequestFolderTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeFileRequestCopyRequest(val) {
        const base = serializeFileRequestUpdateRequest(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileRequestCopyRequest"',
            });
        }
        return Object.assign(Object.assign({}, base), { ['folder']: serializeFileRequestCopyRequestFolderField(val.folder) });
    }

    class GetFileRequestByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileRequestByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateFileRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileRequestByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileRequestCopyOptionals {
        constructor(fields) {
            this.headers = new CreateFileRequestCopyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileRequestByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileRequestByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileRequestByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileRequestCopyHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileRequestsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileRequestById(fileRequestId_1) {
            return __awaiter(this, arguments, void 0, function* (fileRequestId, optionalsInput = {}) {
                const optionals = new GetFileRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileRequest(response.data);
            });
        }
        updateFileRequestById(fileRequestId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileRequestId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFileRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeFileRequestUpdateRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileRequest(response.data);
            });
        }
        deleteFileRequestById(fileRequestId_1) {
            return __awaiter(this, arguments, void 0, function* (fileRequestId, optionalsInput = {}) {
                const optionals = new DeleteFileRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        createFileRequestCopy(fileRequestId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (fileRequestId, requestBody, optionalsInput = {}) {
                const optionals = new CreateFileRequestCopyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId), '/copy'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeFileRequestCopyRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileRequest(response.data);
            });
        }
    }

    function deserializeFolderFullSyncStateField(val) {
        if (val == 'synced') {
            return val;
        }
        if (val == 'not_synced') {
            return val;
        }
        if (val == 'partially_synced') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFullSyncStateField",
        });
    }
    function deserializeFolderFullPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullPermissionsField"',
            });
        }
        if (val.can_delete == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_delete" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_delete)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_delete" of type "FolderFullPermissionsField"',
            });
        }
        const canDelete = val.can_delete;
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FolderFullPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_invite_collaborator == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_invite_collaborator" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_invite_collaborator)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_invite_collaborator" of type "FolderFullPermissionsField"',
            });
        }
        const canInviteCollaborator = val.can_invite_collaborator;
        if (val.can_rename == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_rename" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_rename)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_rename" of type "FolderFullPermissionsField"',
            });
        }
        const canRename = val.can_rename;
        if (val.can_set_share_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_set_share_access" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_set_share_access)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_set_share_access" of type "FolderFullPermissionsField"',
            });
        }
        const canSetShareAccess = val.can_set_share_access;
        if (val.can_share == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_share" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_share)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_share" of type "FolderFullPermissionsField"',
            });
        }
        const canShare = val.can_share;
        if (!(val.can_upload == void 0) && !sdIsBoolean(val.can_upload)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_upload" of type "FolderFullPermissionsField"',
            });
        }
        const canUpload = val.can_upload == void 0 ? void 0 : val.can_upload;
        return {
            canDelete: canDelete,
            canDownload: canDownload,
            canInviteCollaborator: canInviteCollaborator,
            canRename: canRename,
            canSetShareAccess: canSetShareAccess,
            canShare: canShare,
            canUpload: canUpload,
        };
    }
    function deserializeFolderFullMetadataField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullMetadataField"',
            });
        }
        if (!(val == void 0) && !sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting object for "extraData" of type "FolderFullMetadataField"',
            });
        }
        const extraData = val == void 0
            ? void 0
            : sdIsMap(val)
                ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                    k,
                    (function (v) {
                        return sdIsMap(v)
                            ? Object.fromEntries(Object.entries(v).map(([k, v]) => [
                                k,
                                deserializeMetadata(v),
                            ]))
                            : {};
                    })(v),
                ]))
                : {};
        return { extraData: extraData };
    }
    function deserializeFolderFullAllowedSharedLinkAccessLevelsField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFullAllowedSharedLinkAccessLevelsField",
        });
    }
    function deserializeFolderFullAllowedInviteeRolesField(val) {
        if (val == 'editor') {
            return val;
        }
        if (val == 'viewer') {
            return val;
        }
        if (val == 'previewer') {
            return val;
        }
        if (val == 'uploader') {
            return val;
        }
        if (val == 'previewer uploader') {
            return val;
        }
        if (val == 'viewer uploader') {
            return val;
        }
        if (val == 'co-owner') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFullAllowedInviteeRolesField",
        });
    }
    function deserializeFolderFullWatermarkInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullWatermarkInfoField"',
            });
        }
        if (!(val.is_watermarked == void 0) && !sdIsBoolean(val.is_watermarked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_watermarked" of type "FolderFullWatermarkInfoField"',
            });
        }
        const isWatermarked = val.is_watermarked == void 0 ? void 0 : val.is_watermarked;
        return {
            isWatermarked: isWatermarked,
        };
    }
    function deserializeFolderFullClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullClassificationField"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FolderFullClassificationField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.definition == void 0) && !sdIsString(val.definition)) {
            throw new BoxSdkError({
                message: 'Expecting string for "definition" of type "FolderFullClassificationField"',
            });
        }
        const definition = val.definition == void 0 ? void 0 : val.definition;
        if (!(val.color == void 0) && !sdIsString(val.color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "color" of type "FolderFullClassificationField"',
            });
        }
        const color = val.color == void 0 ? void 0 : val.color;
        return {
            name: name,
            definition: definition,
            color: color,
        };
    }
    function deserializeFolderFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderFull"' });
        }
        const syncState = val.sync_state == void 0
            ? void 0
            : deserializeFolderFullSyncStateField(val.sync_state);
        if (!(val.has_collaborations == void 0) &&
            !sdIsBoolean(val.has_collaborations)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "has_collaborations" of type "FolderFull"',
            });
        }
        const hasCollaborations = val.has_collaborations == void 0 ? void 0 : val.has_collaborations;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFolderFullPermissionsField(val.permissions);
        if (!(val.tags == void 0) && !sdIsList(val.tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "tags" of type "FolderFull"',
            });
        }
        const tags = val.tags == void 0
            ? void 0
            : sdIsList(val.tags)
                ? val.tags.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "FolderFull"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.can_non_owners_invite == void 0) &&
            !sdIsBoolean(val.can_non_owners_invite)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_non_owners_invite" of type "FolderFull"',
            });
        }
        const canNonOwnersInvite = val.can_non_owners_invite == void 0 ? void 0 : val.can_non_owners_invite;
        if (!(val.is_externally_owned == void 0) &&
            !sdIsBoolean(val.is_externally_owned)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_externally_owned" of type "FolderFull"',
            });
        }
        const isExternallyOwned = val.is_externally_owned == void 0 ? void 0 : val.is_externally_owned;
        const metadata = val.metadata == void 0
            ? void 0
            : deserializeFolderFullMetadataField(val.metadata);
        if (!(val.is_collaboration_restricted_to_enterprise == void 0) &&
            !sdIsBoolean(val.is_collaboration_restricted_to_enterprise)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_collaboration_restricted_to_enterprise" of type "FolderFull"',
            });
        }
        const isCollaborationRestrictedToEnterprise = val.is_collaboration_restricted_to_enterprise == void 0
            ? void 0
            : val.is_collaboration_restricted_to_enterprise;
        if (!(val.allowed_shared_link_access_levels == void 0) &&
            !sdIsList(val.allowed_shared_link_access_levels)) {
            throw new BoxSdkError({
                message: 'Expecting array for "allowed_shared_link_access_levels" of type "FolderFull"',
            });
        }
        const allowedSharedLinkAccessLevels = val.allowed_shared_link_access_levels == void 0
            ? void 0
            : sdIsList(val.allowed_shared_link_access_levels)
                ? val.allowed_shared_link_access_levels.map(function (itm) {
                    return deserializeFolderFullAllowedSharedLinkAccessLevelsField(itm);
                })
                : [];
        if (!(val.allowed_invitee_roles == void 0) &&
            !sdIsList(val.allowed_invitee_roles)) {
            throw new BoxSdkError({
                message: 'Expecting array for "allowed_invitee_roles" of type "FolderFull"',
            });
        }
        const allowedInviteeRoles = val.allowed_invitee_roles == void 0
            ? void 0
            : sdIsList(val.allowed_invitee_roles)
                ? val.allowed_invitee_roles.map(function (itm) {
                    return deserializeFolderFullAllowedInviteeRolesField(itm);
                })
                : [];
        const watermarkInfo = val.watermark_info == void 0
            ? void 0
            : deserializeFolderFullWatermarkInfoField(val.watermark_info);
        if (!(val.is_accessible_via_shared_link == void 0) &&
            !sdIsBoolean(val.is_accessible_via_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accessible_via_shared_link" of type "FolderFull"',
            });
        }
        const isAccessibleViaSharedLink = val.is_accessible_via_shared_link == void 0
            ? void 0
            : val.is_accessible_via_shared_link;
        if (!(val.can_non_owners_view_collaborators == void 0) &&
            !sdIsBoolean(val.can_non_owners_view_collaborators)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_non_owners_view_collaborators" of type "FolderFull"',
            });
        }
        const canNonOwnersViewCollaborators = val.can_non_owners_view_collaborators == void 0
            ? void 0
            : val.can_non_owners_view_collaborators;
        const classification = val.classification == void 0
            ? void 0
            : deserializeFolderFullClassificationField(val.classification);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FolderFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "FolderFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "FolderFull"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "FolderFull"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFolderPathCollectionField(val.path_collection);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "FolderFull"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "FolderFull"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "FolderFull"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "FolderFull"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFolderSharedLinkField(val.shared_link);
        const folderUploadEmail = val.folder_upload_email == void 0
            ? void 0
            : deserializeFolderFolderUploadEmailField(val.folder_upload_email);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFolderItemStatusField(val.item_status);
        const itemCollection = val.item_collection == void 0
            ? void 0
            : deserializeItems(val.item_collection);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FolderFull"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FolderFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FolderFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderFull"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FolderFull"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FolderFull" to be defined',
            });
        }
        const type = deserializeFolderBaseTypeField(val.type);
        return {
            syncState: syncState,
            hasCollaborations: hasCollaborations,
            permissions: permissions,
            tags: tags,
            canNonOwnersInvite: canNonOwnersInvite,
            isExternallyOwned: isExternallyOwned,
            metadata: metadata,
            isCollaborationRestrictedToEnterprise: isCollaborationRestrictedToEnterprise,
            allowedSharedLinkAccessLevels: allowedSharedLinkAccessLevels,
            allowedInviteeRoles: allowedInviteeRoles,
            watermarkInfo: watermarkInfo,
            isAccessibleViaSharedLink: isAccessibleViaSharedLink,
            canNonOwnersViewCollaborators: canNonOwnersViewCollaborators,
            classification: classification,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
            itemCollection: itemCollection,
            sequenceId: sequenceId,
            name: name,
            id: id,
            etag: etag,
            type: type,
        };
    }

    class GetFolderByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFolderByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new DeleteFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderItemsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFolderItemsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFolderOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CopyFolderOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CopyFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifNoneMatch) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFolderByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifMatch) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFolderItemsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CopyFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FoldersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFolderById(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
        updateFolderById(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new UpdateFolderByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateFolderByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
        deleteFolderById(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteFolderByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['recursive']: toString(queryParams.recursive),
                });
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)), {
                    method: 'DELETE',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getFolderItems(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderItemsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['usemarker']: toString(queryParams.usemarker),
                    ['marker']: toString(queryParams.marker),
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                });
                const headersMap = prepareParams(Object.assign({ ['boxapi']: toString(headers.boxapi) }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/items'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeItems(response.data);
            });
        }
        createFolder(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateFolderOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
        copyFolder(folderId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, requestBody, optionalsInput = {}) {
                const optionals = new CopyFolderOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/copy'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCopyFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
    }
    function serializeUpdateFolderByIdRequestBodySyncStateField(val) {
        return val;
    }
    function serializeUpdateFolderByIdRequestBodyParentField(val) {
        return { ['id']: val.id == void 0 ? void 0 : val.id };
    }
    function serializeUpdateFolderByIdRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateFolderByIdRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
        };
    }
    function serializeUpdateFolderByIdRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateFolderByIdRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeUpdateFolderByIdRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateFolderByIdRequestBodyFolderUploadEmailAccessField(val) {
        return val;
    }
    function serializeUpdateFolderByIdRequestBodyFolderUploadEmailField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateFolderByIdRequestBodyFolderUploadEmailAccessField(val.access),
        };
    }
    function serializeUpdateFolderByIdRequestBodyCollectionsField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0 ? void 0 : val.type,
        };
    }
    function serializeUpdateFolderByIdRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['sync_state']: val.syncState == void 0
                ? void 0
                : serializeUpdateFolderByIdRequestBodySyncStateField(val.syncState),
            ['can_non_owners_invite']: val.canNonOwnersInvite == void 0 ? void 0 : val.canNonOwnersInvite,
            ['parent']: val.parent == void 0
                ? void 0
                : serializeUpdateFolderByIdRequestBodyParentField(val.parent),
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeUpdateFolderByIdRequestBodySharedLinkField(val.sharedLink),
            ['folder_upload_email']: val.folderUploadEmail == void 0
                ? void 0
                : serializeUpdateFolderByIdRequestBodyFolderUploadEmailField(val.folderUploadEmail),
            ['tags']: val.tags == void 0
                ? void 0
                : val.tags.map(function (item) {
                    return item;
                }),
            ['is_collaboration_restricted_to_enterprise']: val.isCollaborationRestrictedToEnterprise == void 0
                ? void 0
                : val.isCollaborationRestrictedToEnterprise,
            ['collections']: val.collections == void 0
                ? void 0
                : val.collections.map(function (item) {
                    return serializeUpdateFolderByIdRequestBodyCollectionsField(item);
                }),
            ['can_non_owners_view_collaborators']: val.canNonOwnersViewCollaborators == void 0
                ? void 0
                : val.canNonOwnersViewCollaborators,
        };
    }
    function serializeCreateFolderRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateFolderRequestBodyFolderUploadEmailAccessField(val) {
        return val;
    }
    function serializeCreateFolderRequestBodyFolderUploadEmailField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeCreateFolderRequestBodyFolderUploadEmailAccessField(val.access),
        };
    }
    function serializeCreateFolderRequestBodySyncStateField(val) {
        return val;
    }
    function serializeCreateFolderRequestBody(val) {
        return {
            ['name']: val.name,
            ['parent']: serializeCreateFolderRequestBodyParentField(val.parent),
            ['folder_upload_email']: val.folderUploadEmail == void 0
                ? void 0
                : serializeCreateFolderRequestBodyFolderUploadEmailField(val.folderUploadEmail),
            ['sync_state']: val.syncState == void 0
                ? void 0
                : serializeCreateFolderRequestBodySyncStateField(val.syncState),
        };
    }
    function serializeCopyFolderRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCopyFolderRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['parent']: serializeCopyFolderRequestBodyParentField(val.parent),
        };
    }

    function deserializeTrashFolderRestoredTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderRestoredTypeField",
        });
    }
    function deserializeTrashFolderRestoredPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderRestoredPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFolderRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFolderRestoredPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFolderRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFolderRestoredPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFolderRestoredItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderRestoredItemStatusField",
        });
    }
    function deserializeTrashFolderRestored(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderRestored"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFolderRestored"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFolderRestored"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        const type = val.type == void 0
            ? void 0
            : deserializeTrashFolderRestoredTypeField(val.type);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFolderRestored"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFolderRestored"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFolderRestored"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFolderRestored"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFolderRestored"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFolderRestored"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeTrashFolderRestoredPathCollectionField(val.path_collection);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFolderRestored"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : val.trashed_at;
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFolderRestored"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : val.purged_at;
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFolderRestored"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFolderRestored"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFolderRestored"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        if (!(val.folder_upload_email == void 0) &&
            !sdIsString(val.folder_upload_email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_upload_email" of type "TrashFolderRestored"',
            });
        }
        const folderUploadEmail = val.folder_upload_email == void 0 ? void 0 : val.folder_upload_email;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeTrashFolderRestoredItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    function deserializeTrashFolderTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrashFolderTypeField" });
    }
    function deserializeTrashFolderPathCollectionEntriesTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderPathCollectionEntriesTypeField",
        });
    }
    function deserializeTrashFolderPathCollectionEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderPathCollectionEntriesField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashFolderPathCollectionEntriesTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
        };
    }
    function deserializeTrashFolderPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFolderPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFolderPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTrashFolderPathCollectionEntriesField(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFolderItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderItemStatusField",
        });
    }
    function deserializeTrashFolder(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrashFolder"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFolder"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFolder"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TrashFolder" to be defined',
            });
        }
        const type = deserializeTrashFolderTypeField(val.type);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFolder"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (val.name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "name" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFolder"',
            });
        }
        const name = val.name;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFolder"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFolder"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFolder"',
            });
        }
        const description = val.description;
        if (val.size == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "size" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFolder"',
            });
        }
        const size = val.size;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashFolder" to be defined',
            });
        }
        const pathCollection = deserializeTrashFolderPathCollectionField(val.path_collection);
        if (val.created_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_by" of type "TrashFolder" to be defined',
            });
        }
        const createdBy = deserializeUserMini(val.created_by);
        if (val.modified_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_by" of type "TrashFolder" to be defined',
            });
        }
        const modifiedBy = deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFolder"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFolder"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFolder"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFolder"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        if (val.owned_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "owned_by" of type "TrashFolder" to be defined',
            });
        }
        const ownedBy = deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFolder"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        if (!(val.folder_upload_email == void 0) &&
            !sdIsString(val.folder_upload_email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_upload_email" of type "TrashFolder"',
            });
        }
        const folderUploadEmail = val.folder_upload_email == void 0 ? void 0 : val.folder_upload_email;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (val.item_status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_status" of type "TrashFolder" to be defined',
            });
        }
        const itemStatus = deserializeTrashFolderItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    class RestoreFolderFromTrashOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new RestoreFolderFromTrashHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTrashedFolderByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetTrashedFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTrashedFolderByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTrashedFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RestoreFolderFromTrashHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTrashedFolderByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTrashedFolderByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedFoldersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        restoreFolderFromTrash(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new RestoreFolderFromTrashOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRestoreFolderFromTrashRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTrashFolderRestored(response.data);
            });
        }
        getTrashedFolderById(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetTrashedFolderByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/trash'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTrashFolder(response.data);
            });
        }
        deleteTrashedFolderById(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteTrashedFolderByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/trash'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeRestoreFolderFromTrashRequestBodyParentField(val) {
        return { ['id']: val.id == void 0 ? void 0 : val.id };
    }
    function serializeRestoreFolderFromTrashRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['parent']: val.parent == void 0
                ? void 0
                : serializeRestoreFolderFromTrashRequestBodyParentField(val.parent),
        };
    }

    class GetFolderMetadataOptionals {
        constructor(fields) {
            this.headers = new GetFolderMetadataHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new GetFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new CreateFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderMetadataHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFolderMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFolderMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFolderMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderMetadataByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderMetadataManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFolderMetadata(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderMetadataOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadatas(response.data);
            });
        }
        getFolderMetadataById(folderId_1, scope_1, templateKey_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, scope, templateKey, optionalsInput = {}) {
                const optionals = new GetFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataFull(response.data);
            });
        }
        createFolderMetadataById(folderId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new CreateFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFolderMetadataByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataFull(response.data);
            });
        }
        updateFolderMetadataById(folderId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateFolderMetadataByIdRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataFull(response.data);
            });
        }
        deleteFolderMetadataById(folderId_1, scope_1, templateKey_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, scope, templateKey, optionalsInput = {}) {
                const optionals = new DeleteFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateFolderMetadataByIdRequestBody(val) {
        return Object.fromEntries(Object.entries(val).map(([k, v]) => [
            k,
            (function (v) {
                return v;
            })(v),
        ]));
    }
    function serializeUpdateFolderMetadataByIdRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateFolderMetadataByIdRequestBody(val) {
        return {
            ['op']: val.op == void 0
                ? void 0
                : serializeUpdateFolderMetadataByIdRequestBodyOpField(val.op),
            ['path']: val.path == void 0 ? void 0 : val.path,
            ['value']: val.value == void 0 ? void 0 : val.value,
            ['from']: val.from == void 0 ? void 0 : val.from,
        };
    }

    class GetClassificationOnFolderOptionals {
        constructor(fields) {
            this.headers = new GetClassificationOnFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddClassificationToFolderOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new AddClassificationToFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateClassificationOnFolderOptionals {
        constructor(fields) {
            this.headers = new UpdateClassificationOnFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteClassificationFromFolderOptionals {
        constructor(fields) {
            this.headers = new DeleteClassificationFromFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetClassificationOnFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddClassificationToFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateClassificationOnFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteClassificationFromFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderClassificationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getClassificationOnFolder(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetClassificationOnFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassification(response.data);
            });
        }
        addClassificationToFolder(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new AddClassificationToFolderOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAddClassificationToFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassification(response.data);
            });
        }
        updateClassificationOnFolder(folderId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateClassificationOnFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateClassificationOnFolderRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassification(response.data);
            });
        }
        deleteClassificationFromFolder(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteClassificationFromFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeAddClassificationToFolderRequestBody(val) {
        return {
            ['Box__Security__Classification__Key']: val.boxSecurityClassificationKey == void 0
                ? void 0
                : val.boxSecurityClassificationKey,
        };
    }
    function serializeUpdateClassificationOnFolderRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFolderRequestBodyPathField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFolderRequestBody(val) {
        return {
            ['op']: serializeUpdateClassificationOnFolderRequestBodyOpField(val.op),
            ['path']: serializeUpdateClassificationOnFolderRequestBodyPathField(val.path),
            ['value']: val.value,
        };
    }

    class GetTrashedItemsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedItemsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getTrashedItems() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetTrashedItemsHeaders({}), cancellationToken) {
                const headers = new GetTrashedItemsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                    ['usemarker']: toString(queryParams.usemarker),
                    ['marker']: toString(queryParams.marker),
                    ['direction']: toString(queryParams.direction),
                    ['sort']: toString(queryParams.sort),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/trash/items'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeItems(response.data);
            });
        }
    }

    class GetFolderWatermarkOptionals {
        constructor(fields) {
            this.headers = new GetFolderWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFolderWatermarkOptionals {
        constructor(fields) {
            this.headers = new UpdateFolderWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderWatermarkOptionals {
        constructor(fields) {
            this.headers = new DeleteFolderWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderWatermarkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFolderWatermarkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderWatermarkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderWatermarksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFolderWatermark(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/watermark'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWatermark(response.data);
            });
        }
        updateFolderWatermark(folderId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFolderWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/watermark'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateFolderWatermarkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWatermark(response.data);
            });
        }
        deleteFolderWatermark(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteFolderWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/watermark'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeUpdateFolderWatermarkRequestBodyWatermarkImprintField(val) {
        return val;
    }
    function serializeUpdateFolderWatermarkRequestBodyWatermarkField(val) {
        return {
            ['imprint']: serializeUpdateFolderWatermarkRequestBodyWatermarkImprintField(val.imprint),
        };
    }
    function serializeUpdateFolderWatermarkRequestBody(val) {
        return {
            ['watermark']: serializeUpdateFolderWatermarkRequestBodyWatermarkField(val.watermark),
        };
    }

    function deserializeFolderLockLockedOperationsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderLockLockedOperationsField"',
            });
        }
        if (val.move == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "move" of type "FolderLockLockedOperationsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.move)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "move" of type "FolderLockLockedOperationsField"',
            });
        }
        const move = val.move;
        if (val.delete == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "delete" of type "FolderLockLockedOperationsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.delete)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "delete" of type "FolderLockLockedOperationsField"',
            });
        }
        const _delete = val.delete;
        return {
            move: move,
            delete: _delete,
        };
    }
    function deserializeFolderLock(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderLock"' });
        }
        const folder = val.folder == void 0 ? void 0 : deserializeFolderMini(val.folder);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderLock"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "FolderLock"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FolderLock"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const lockedOperations = val.locked_operations == void 0
            ? void 0
            : deserializeFolderLockLockedOperationsField(val.locked_operations);
        if (!(val.lock_type == void 0) && !sdIsString(val.lock_type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "lock_type" of type "FolderLock"',
            });
        }
        const lockType = val.lock_type == void 0 ? void 0 : val.lock_type;
        return {
            folder: folder,
            id: id,
            type: type,
            createdBy: createdBy,
            createdAt: createdAt,
            lockedOperations: lockedOperations,
            lockType: lockType,
        };
    }

    function deserializeFolderLocks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderLocks"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FolderLocks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFolderLock(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsString(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting string for "limit" of type "FolderLocks"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FolderLocks"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    class GetFolderLocksOptionals {
        constructor(fields) {
            this.headers = new GetFolderLocksHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFolderLockOptionals {
        constructor(fields) {
            this.headers = new CreateFolderLockHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderLockByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFolderLockByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderLocksHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFolderLockHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderLockByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderLocksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFolderLocks(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetFolderLocksOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['folder_id']: toString(queryParams.folderId),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folder_locks'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderLocks(response.data);
            });
        }
        createFolderLock(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateFolderLockOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folder_locks'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFolderLockRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderLock(response.data);
            });
        }
        deleteFolderLockById(folderLockId_1) {
            return __awaiter(this, arguments, void 0, function* (folderLockId, optionalsInput = {}) {
                const optionals = new DeleteFolderLockByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folder_locks/', toString(folderLockId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateFolderLockRequestBodyLockedOperationsField(val) {
        return { ['move']: val.move, ['delete']: val.delete };
    }
    function serializeCreateFolderLockRequestBodyFolderField(val) {
        return { ['type']: val.type, ['id']: val.id };
    }
    function serializeCreateFolderLockRequestBody(val) {
        return {
            ['locked_operations']: val.lockedOperations == void 0
                ? void 0
                : serializeCreateFolderLockRequestBodyLockedOperationsField(val.lockedOperations),
            ['folder']: serializeCreateFolderLockRequestBodyFolderField(val.folder),
        };
    }

    function deserializeMetadataTemplateTypeField(val) {
        if (val == 'metadata_template') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataTemplateTypeField",
        });
    }
    function deserializeMetadataTemplateFieldsTypeField(val) {
        if (val == 'string') {
            return val;
        }
        if (val == 'float') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'enum') {
            return val;
        }
        if (val == 'multiSelect') {
            return val;
        }
        if (val == 'integer') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataTemplateFieldsTypeField",
        });
    }
    function deserializeMetadataTemplateFieldsOptionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplateFieldsOptionsField"',
            });
        }
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "MetadataTemplateFieldsOptionsField" to be defined',
            });
        }
        if (!sdIsString(val.key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "key" of type "MetadataTemplateFieldsOptionsField"',
            });
        }
        const key = val.key;
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataTemplateFieldsOptionsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return { key: key, id: id };
    }
    function deserializeMetadataTemplateFieldsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplateFieldsField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "MetadataTemplateFieldsField" to be defined',
            });
        }
        const type = deserializeMetadataTemplateFieldsTypeField(val.type);
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "MetadataTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsString(val.key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "key" of type "MetadataTemplateFieldsField"',
            });
        }
        const key = val.key;
        if (val.displayName == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "displayName" of type "MetadataTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsString(val.displayName)) {
            throw new BoxSdkError({
                message: 'Expecting string for "displayName" of type "MetadataTemplateFieldsField"',
            });
        }
        const displayName = val.displayName;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "MetadataTemplateFieldsField"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "MetadataTemplateFieldsField"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (!(val.options == void 0) && !sdIsList(val.options)) {
            throw new BoxSdkError({
                message: 'Expecting array for "options" of type "MetadataTemplateFieldsField"',
            });
        }
        const options = val.options == void 0
            ? void 0
            : sdIsList(val.options)
                ? val.options.map(function (itm) {
                    return deserializeMetadataTemplateFieldsOptionsField(itm);
                })
                : [];
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataTemplateFieldsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return {
            type: type,
            key: key,
            displayName: displayName,
            description: description,
            hidden: hidden,
            options: options,
            id: id,
        };
    }
    function deserializeMetadataTemplate(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplate"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "MetadataTemplate" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataTemplate"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "MetadataTemplate" to be defined',
            });
        }
        const type = deserializeMetadataTemplateTypeField(val.type);
        if (!(val.scope == void 0) && !sdIsString(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "scope" of type "MetadataTemplate"',
            });
        }
        const scope = val.scope == void 0 ? void 0 : val.scope;
        if (!(val.templateKey == void 0) && !sdIsString(val.templateKey)) {
            throw new BoxSdkError({
                message: 'Expecting string for "templateKey" of type "MetadataTemplate"',
            });
        }
        const templateKey = val.templateKey == void 0 ? void 0 : val.templateKey;
        if (!(val.displayName == void 0) && !sdIsString(val.displayName)) {
            throw new BoxSdkError({
                message: 'Expecting string for "displayName" of type "MetadataTemplate"',
            });
        }
        const displayName = val.displayName == void 0 ? void 0 : val.displayName;
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "MetadataTemplate"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (!(val.fields == void 0) && !sdIsList(val.fields)) {
            throw new BoxSdkError({
                message: 'Expecting array for "fields" of type "MetadataTemplate"',
            });
        }
        const fields = val.fields == void 0
            ? void 0
            : sdIsList(val.fields)
                ? val.fields.map(function (itm) {
                    return deserializeMetadataTemplateFieldsField(itm);
                })
                : [];
        if (!(val.copyInstanceOnItemCopy == void 0) &&
            !sdIsBoolean(val.copyInstanceOnItemCopy)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "copyInstanceOnItemCopy" of type "MetadataTemplate"',
            });
        }
        const copyInstanceOnItemCopy = val.copyInstanceOnItemCopy == void 0 ? void 0 : val.copyInstanceOnItemCopy;
        return {
            id: id,
            type: type,
            scope: scope,
            templateKey: templateKey,
            displayName: displayName,
            hidden: hidden,
            fields: fields,
            copyInstanceOnItemCopy: copyInstanceOnItemCopy,
        };
    }

    function deserializeMetadataTemplates(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplates"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "MetadataTemplates"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "MetadataTemplates"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "MetadataTemplates"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "MetadataTemplates"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeMetadataTemplate(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetMetadataTemplatesByInstanceIdOptionals {
        constructor(fields) {
            this.headers = new GetMetadataTemplatesByInstanceIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new GetMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new UpdateMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new DeleteMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataTemplateByIdOptionals {
        constructor(fields) {
            this.headers = new GetMetadataTemplateByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new CreateMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataTemplatesByInstanceIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetMetadataTemplateHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateMetadataTemplateHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteMetadataTemplateHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetMetadataTemplateByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGlobalMetadataTemplatesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetEnterpriseMetadataTemplatesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateMetadataTemplateHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class MetadataTemplatesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getMetadataTemplatesByInstanceId(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetMetadataTemplatesByInstanceIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['metadata_instance_id']: toString(queryParams.metadataInstanceId),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataTemplates(response.data);
            });
        }
        getMetadataTemplate(scope_1, templateKey_1) {
            return __awaiter(this, arguments, void 0, function* (scope, templateKey, optionalsInput = {}) {
                const optionals = new GetMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(scope), '/', toString(templateKey), '/schema'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataTemplate(response.data);
            });
        }
        updateMetadataTemplate(scope_1, templateKey_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new UpdateMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(scope), '/', toString(templateKey), '/schema'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateMetadataTemplateRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataTemplate(response.data);
            });
        }
        deleteMetadataTemplate(scope_1, templateKey_1) {
            return __awaiter(this, arguments, void 0, function* (scope, templateKey, optionalsInput = {}) {
                const optionals = new DeleteMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(scope), '/', toString(templateKey), '/schema'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getMetadataTemplateById(templateId_1) {
            return __awaiter(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new GetMetadataTemplateByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(templateId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataTemplate(response.data);
            });
        }
        getGlobalMetadataTemplates() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetGlobalMetadataTemplatesHeaders({}), cancellationToken) {
                const headers = new GetGlobalMetadataTemplatesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/global'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataTemplates(response.data);
            });
        }
        getEnterpriseMetadataTemplates() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetEnterpriseMetadataTemplatesHeaders({}), cancellationToken) {
                const headers = new GetEnterpriseMetadataTemplatesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataTemplates(response.data);
            });
        }
        createMetadataTemplate(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/schema'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateMetadataTemplateRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataTemplate(response.data);
            });
        }
    }
    function serializeUpdateMetadataTemplateRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateMetadataTemplateRequestBody(val) {
        return {
            ['op']: serializeUpdateMetadataTemplateRequestBodyOpField(val.op),
            ['data']: val.data == void 0
                ? void 0
                : Object.fromEntries(Object.entries(val.data).map(([k, v]) => [
                    k,
                    (function (v) {
                        return v;
                    })(v),
                ])),
            ['fieldKey']: val.fieldKey == void 0 ? void 0 : val.fieldKey,
            ['fieldKeys']: val.fieldKeys == void 0
                ? void 0
                : val.fieldKeys.map(function (item) {
                    return item;
                }),
            ['enumOptionKey']: val.enumOptionKey == void 0 ? void 0 : val.enumOptionKey,
            ['enumOptionKeys']: val.enumOptionKeys == void 0
                ? void 0
                : val.enumOptionKeys.map(function (item) {
                    return item;
                }),
            ['multiSelectOptionKey']: val.multiSelectOptionKey == void 0 ? void 0 : val.multiSelectOptionKey,
            ['multiSelectOptionKeys']: val.multiSelectOptionKeys == void 0
                ? void 0
                : val.multiSelectOptionKeys.map(function (item) {
                    return item;
                }),
        };
    }
    function serializeCreateMetadataTemplateRequestBodyFieldsTypeField(val) {
        return val;
    }
    function serializeCreateMetadataTemplateRequestBodyFieldsOptionsField(val) {
        return { ['key']: val.key };
    }
    function serializeCreateMetadataTemplateRequestBodyFieldsField(val) {
        return {
            ['type']: serializeCreateMetadataTemplateRequestBodyFieldsTypeField(val.type),
            ['key']: val.key,
            ['displayName']: val.displayName,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['hidden']: val.hidden == void 0 ? void 0 : val.hidden,
            ['options']: val.options == void 0
                ? void 0
                : val.options.map(function (item) {
                    return serializeCreateMetadataTemplateRequestBodyFieldsOptionsField(item);
                }),
        };
    }
    function serializeCreateMetadataTemplateRequestBody(val) {
        return {
            ['scope']: val.scope,
            ['templateKey']: val.templateKey == void 0 ? void 0 : val.templateKey,
            ['displayName']: val.displayName,
            ['hidden']: val.hidden == void 0 ? void 0 : val.hidden,
            ['fields']: val.fields == void 0
                ? void 0
                : val.fields.map(function (item) {
                    return serializeCreateMetadataTemplateRequestBodyFieldsField(item);
                }),
            ['copyInstanceOnItemCopy']: val.copyInstanceOnItemCopy == void 0
                ? void 0
                : val.copyInstanceOnItemCopy,
        };
    }

    function deserializeClassificationTemplateTypeField(val) {
        if (val == 'metadata_template') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateTypeField",
        });
    }
    function deserializeClassificationTemplateTemplateKeyField(val) {
        if (val == 'securityClassification-6VMVochwUWo') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateTemplateKeyField",
        });
    }
    function deserializeClassificationTemplateDisplayNameField(val) {
        if (val == 'Classification') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateDisplayNameField",
        });
    }
    function deserializeClassificationTemplateFieldsTypeField(val) {
        if (val == 'enum') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateFieldsTypeField",
        });
    }
    function deserializeClassificationTemplateFieldsKeyField(val) {
        if (val == 'Box__Security__Classification__Key') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateFieldsKeyField",
        });
    }
    function deserializeClassificationTemplateFieldsDisplayNameField(val) {
        if (val == 'Classification') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateFieldsDisplayNameField",
        });
    }
    function deserializeClassificationTemplateFieldsOptionsStaticConfigClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsOptionsStaticConfigClassificationField"',
            });
        }
        if (!(val.classificationDefinition == void 0) &&
            !sdIsString(val.classificationDefinition)) {
            throw new BoxSdkError({
                message: 'Expecting string for "classificationDefinition" of type "ClassificationTemplateFieldsOptionsStaticConfigClassificationField"',
            });
        }
        const classificationDefinition = val.classificationDefinition == void 0
            ? void 0
            : val.classificationDefinition;
        if (!(val.colorID == void 0) && !sdIsNumber(val.colorID)) {
            throw new BoxSdkError({
                message: 'Expecting number for "colorID" of type "ClassificationTemplateFieldsOptionsStaticConfigClassificationField"',
            });
        }
        const colorId = val.colorID == void 0 ? void 0 : val.colorID;
        return {
            classificationDefinition: classificationDefinition,
            colorId: colorId,
        };
    }
    function deserializeClassificationTemplateFieldsOptionsStaticConfigField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsOptionsStaticConfigField"',
            });
        }
        const classification = val.classification == void 0
            ? void 0
            : deserializeClassificationTemplateFieldsOptionsStaticConfigClassificationField(val.classification);
        return {
            classification: classification,
        };
    }
    function deserializeClassificationTemplateFieldsOptionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsOptionsField"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ClassificationTemplateFieldsOptionsField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ClassificationTemplateFieldsOptionsField"',
            });
        }
        const id = val.id;
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "ClassificationTemplateFieldsOptionsField" to be defined',
            });
        }
        if (!sdIsString(val.key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "key" of type "ClassificationTemplateFieldsOptionsField"',
            });
        }
        const key = val.key;
        const staticConfig = val.staticConfig == void 0
            ? void 0
            : deserializeClassificationTemplateFieldsOptionsStaticConfigField(val.staticConfig);
        return {
            id: id,
            key: key,
            staticConfig: staticConfig,
        };
    }
    function deserializeClassificationTemplateFieldsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsField"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ClassificationTemplateFieldsField"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        const type = deserializeClassificationTemplateFieldsTypeField(val.type);
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        const key = deserializeClassificationTemplateFieldsKeyField(val.key);
        if (val.displayName == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "displayName" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        const displayName = deserializeClassificationTemplateFieldsDisplayNameField(val.displayName);
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "ClassificationTemplateFieldsField"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (val.options == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "options" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsList(val.options)) {
            throw new BoxSdkError({
                message: 'Expecting array for "options" of type "ClassificationTemplateFieldsField"',
            });
        }
        const options = sdIsList(val.options)
            ? val.options.map(function (itm) {
                return deserializeClassificationTemplateFieldsOptionsField(itm);
            })
            : [];
        return {
            id: id,
            type: type,
            key: key,
            displayName: displayName,
            hidden: hidden,
            options: options,
        };
    }
    function deserializeClassificationTemplate(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplate"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ClassificationTemplate" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ClassificationTemplate"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ClassificationTemplate" to be defined',
            });
        }
        const type = deserializeClassificationTemplateTypeField(val.type);
        if (val.scope == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "scope" of type "ClassificationTemplate" to be defined',
            });
        }
        if (!sdIsString(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "scope" of type "ClassificationTemplate"',
            });
        }
        const scope = val.scope;
        if (val.templateKey == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "templateKey" of type "ClassificationTemplate" to be defined',
            });
        }
        const templateKey = deserializeClassificationTemplateTemplateKeyField(val.templateKey);
        if (val.displayName == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "displayName" of type "ClassificationTemplate" to be defined',
            });
        }
        const displayName = deserializeClassificationTemplateDisplayNameField(val.displayName);
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "ClassificationTemplate"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (!(val.copyInstanceOnItemCopy == void 0) &&
            !sdIsBoolean(val.copyInstanceOnItemCopy)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "copyInstanceOnItemCopy" of type "ClassificationTemplate"',
            });
        }
        const copyInstanceOnItemCopy = val.copyInstanceOnItemCopy == void 0 ? void 0 : val.copyInstanceOnItemCopy;
        if (val.fields == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "fields" of type "ClassificationTemplate" to be defined',
            });
        }
        if (!sdIsList(val.fields)) {
            throw new BoxSdkError({
                message: 'Expecting array for "fields" of type "ClassificationTemplate"',
            });
        }
        const fields = sdIsList(val.fields)
            ? val.fields.map(function (itm) {
                return deserializeClassificationTemplateFieldsField(itm);
            })
            : [];
        return {
            id: id,
            type: type,
            scope: scope,
            templateKey: templateKey,
            displayName: displayName,
            hidden: hidden,
            copyInstanceOnItemCopy: copyInstanceOnItemCopy,
            fields: fields,
        };
    }

    class AddClassificationOptionals {
        constructor(fields) {
            this.headers = new AddClassificationHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateClassificationOptionals {
        constructor(fields) {
            this.headers = new UpdateClassificationHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateClassificationTemplateOptionals {
        constructor(fields) {
            this.headers = new CreateClassificationTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetClassificationTemplateHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddClassificationHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateClassificationHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateClassificationTemplateRequestBody {
        constructor(fields) {
            this.scope = 'enterprise';
            this.templateKey = 'securityClassification-6VMVochwUWo';
            this.displayName = 'Classification';
            if (fields.scope) {
                this.scope = fields.scope;
            }
            if (fields.templateKey) {
                this.templateKey = fields.templateKey;
            }
            if (fields.displayName) {
                this.displayName = fields.displayName;
            }
            if (fields.hidden) {
                this.hidden = fields.hidden;
            }
            if (fields.copyInstanceOnItemCopy) {
                this.copyInstanceOnItemCopy = fields.copyInstanceOnItemCopy;
            }
            if (fields.fields) {
                this.fields = fields.fields;
            }
        }
    }
    class CreateClassificationTemplateHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ClassificationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getClassificationTemplate() {
            return __awaiter(this, arguments, void 0, function* (headersInput = new GetClassificationTemplateHeaders({}), cancellationToken) {
                const headers = new GetClassificationTemplateHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassificationTemplate(response.data);
            });
        }
        addClassification(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new AddClassificationOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#add'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeAddClassificationRequestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassificationTemplate(response.data);
            });
        }
        updateClassification(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new UpdateClassificationOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#update'), {
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateClassificationRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassificationTemplate(response.data);
            });
        }
        createClassificationTemplate(requestBodyInput_1) {
            return __awaiter(this, arguments, void 0, function* (requestBodyInput, optionalsInput = {}) {
                const requestBody = new CreateClassificationTemplateRequestBody({
                    scope: requestBodyInput.scope,
                    templateKey: requestBodyInput.templateKey,
                    displayName: requestBodyInput.displayName,
                    hidden: requestBodyInput.hidden,
                    copyInstanceOnItemCopy: requestBodyInput.copyInstanceOnItemCopy,
                    fields: requestBodyInput.fields,
                });
                const optionals = new CreateClassificationTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/schema#classifications'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateClassificationTemplateRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeClassificationTemplate(response.data);
            });
        }
    }
    function serializeAddClassificationRequestBodyOpField(val) {
        return val;
    }
    function serializeAddClassificationRequestBodyFieldKeyField(val) {
        return val;
    }
    function serializeAddClassificationRequestBodyDataStaticConfigClassificationField(val) {
        return {
            ['classificationDefinition']: val.classificationDefinition == void 0
                ? void 0
                : val.classificationDefinition,
            ['colorID']: val.colorId == void 0 ? void 0 : val.colorId,
        };
    }
    function serializeAddClassificationRequestBodyDataStaticConfigField(val) {
        return {
            ['classification']: val.classification == void 0
                ? void 0
                : serializeAddClassificationRequestBodyDataStaticConfigClassificationField(val.classification),
        };
    }
    function serializeAddClassificationRequestBodyDataField(val) {
        return {
            ['key']: val.key,
            ['staticConfig']: val.staticConfig == void 0
                ? void 0
                : serializeAddClassificationRequestBodyDataStaticConfigField(val.staticConfig),
        };
    }
    function serializeAddClassificationRequestBody(val) {
        return {
            ['op']: serializeAddClassificationRequestBodyOpField(val.op),
            ['fieldKey']: serializeAddClassificationRequestBodyFieldKeyField(val.fieldKey),
            ['data']: serializeAddClassificationRequestBodyDataField(val.data),
        };
    }
    function serializeUpdateClassificationRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateClassificationRequestBodyFieldKeyField(val) {
        return val;
    }
    function serializeUpdateClassificationRequestBodyDataStaticConfigClassificationField(val) {
        return {
            ['classificationDefinition']: val.classificationDefinition == void 0
                ? void 0
                : val.classificationDefinition,
            ['colorID']: val.colorId == void 0 ? void 0 : val.colorId,
        };
    }
    function serializeUpdateClassificationRequestBodyDataStaticConfigField(val) {
        return {
            ['classification']: val.classification == void 0
                ? void 0
                : serializeUpdateClassificationRequestBodyDataStaticConfigClassificationField(val.classification),
        };
    }
    function serializeUpdateClassificationRequestBodyDataField(val) {
        return {
            ['key']: val.key,
            ['staticConfig']: val.staticConfig == void 0
                ? void 0
                : serializeUpdateClassificationRequestBodyDataStaticConfigField(val.staticConfig),
        };
    }
    function serializeUpdateClassificationRequestBody(val) {
        return {
            ['op']: serializeUpdateClassificationRequestBodyOpField(val.op),
            ['fieldKey']: serializeUpdateClassificationRequestBodyFieldKeyField(val.fieldKey),
            ['enumOptionKey']: val.enumOptionKey,
            ['data']: serializeUpdateClassificationRequestBodyDataField(val.data),
        };
    }
    function serializeCreateClassificationTemplateRequestBodyScopeField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyTemplateKeyField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyDisplayNameField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsTypeField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsKeyField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsDisplayNameField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigClassificationField(val) {
        return {
            ['classificationDefinition']: val.classificationDefinition == void 0
                ? void 0
                : val.classificationDefinition,
            ['colorID']: val.colorId == void 0 ? void 0 : val.colorId,
        };
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigField(val) {
        return {
            ['classification']: val.classification == void 0
                ? void 0
                : serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigClassificationField(val.classification),
        };
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsOptionsField(val) {
        return {
            ['key']: val.key,
            ['staticConfig']: val.staticConfig == void 0
                ? void 0
                : serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigField(val.staticConfig),
        };
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsField(val) {
        return {
            ['type']: serializeCreateClassificationTemplateRequestBodyFieldsTypeField(val.type),
            ['key']: serializeCreateClassificationTemplateRequestBodyFieldsKeyField(val.key),
            ['displayName']: serializeCreateClassificationTemplateRequestBodyFieldsDisplayNameField(val.displayName),
            ['hidden']: val.hidden == void 0 ? void 0 : val.hidden,
            ['options']: val.options.map(function (item) {
                return serializeCreateClassificationTemplateRequestBodyFieldsOptionsField(item);
            }),
        };
    }
    function serializeCreateClassificationTemplateRequestBody(val) {
        return {
            ['scope']: serializeCreateClassificationTemplateRequestBodyScopeField(val.scope),
            ['templateKey']: serializeCreateClassificationTemplateRequestBodyTemplateKeyField(val.templateKey),
            ['displayName']: serializeCreateClassificationTemplateRequestBodyDisplayNameField(val.displayName),
            ['hidden']: val.hidden == void 0 ? void 0 : val.hidden,
            ['copyInstanceOnItemCopy']: val.copyInstanceOnItemCopy == void 0
                ? void 0
                : val.copyInstanceOnItemCopy,
            ['fields']: val.fields.map(function (item) {
                return serializeCreateClassificationTemplateRequestBodyFieldsField(item);
            }),
        };
    }

    function deserializeMetadataCascadePolicyTypeField(val) {
        if (val == 'metadata_cascade_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataCascadePolicyTypeField",
        });
    }
    function deserializeMetadataCascadePolicyOwnerEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataCascadePolicyOwnerEnterpriseTypeField",
        });
    }
    function deserializeMetadataCascadePolicyOwnerEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicyOwnerEnterpriseField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeMetadataCascadePolicyOwnerEnterpriseTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataCascadePolicyOwnerEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return {
            type: type,
            id: id,
        };
    }
    function deserializeMetadataCascadePolicyParentTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataCascadePolicyParentTypeField",
        });
    }
    function deserializeMetadataCascadePolicyParentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicyParentField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeMetadataCascadePolicyParentTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataCascadePolicyParentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return { type: type, id: id };
    }
    function deserializeMetadataCascadePolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicy"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "MetadataCascadePolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataCascadePolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "MetadataCascadePolicy" to be defined',
            });
        }
        const type = deserializeMetadataCascadePolicyTypeField(val.type);
        const ownerEnterprise = val.owner_enterprise == void 0
            ? void 0
            : deserializeMetadataCascadePolicyOwnerEnterpriseField(val.owner_enterprise);
        const parent = val.parent == void 0
            ? void 0
            : deserializeMetadataCascadePolicyParentField(val.parent);
        if (!(val.scope == void 0) && !sdIsString(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "scope" of type "MetadataCascadePolicy"',
            });
        }
        const scope = val.scope == void 0 ? void 0 : val.scope;
        if (!(val.templateKey == void 0) && !sdIsString(val.templateKey)) {
            throw new BoxSdkError({
                message: 'Expecting string for "templateKey" of type "MetadataCascadePolicy"',
            });
        }
        const templateKey = val.templateKey == void 0 ? void 0 : val.templateKey;
        return {
            id: id,
            type: type,
            ownerEnterprise: ownerEnterprise,
            parent: parent,
            scope: scope,
            templateKey: templateKey,
        };
    }

    function deserializeMetadataCascadePolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicies"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "MetadataCascadePolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "MetadataCascadePolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "MetadataCascadePolicies"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "MetadataCascadePolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeMetadataCascadePolicy(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetMetadataCascadePoliciesOptionals {
        constructor(fields) {
            this.headers = new GetMetadataCascadePoliciesHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateMetadataCascadePolicyOptionals {
        constructor(fields) {
            this.headers = new CreateMetadataCascadePolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataCascadePolicyByIdOptionals {
        constructor(fields) {
            this.headers = new GetMetadataCascadePolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteMetadataCascadePolicyByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteMetadataCascadePolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class ApplyMetadataCascadePolicyOptionals {
        constructor(fields) {
            this.headers = new ApplyMetadataCascadePolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataCascadePoliciesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateMetadataCascadePolicyHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetMetadataCascadePolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteMetadataCascadePolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ApplyMetadataCascadePolicyHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class MetadataCascadePoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getMetadataCascadePolicies(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetMetadataCascadePoliciesOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['folder_id']: toString(queryParams.folderId),
                    ['owner_enterprise_id']: toString(queryParams.ownerEnterpriseId),
                    ['marker']: toString(queryParams.marker),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataCascadePolicies(response.data);
            });
        }
        createMetadataCascadePolicy(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateMetadataCascadePolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateMetadataCascadePolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataCascadePolicy(response.data);
            });
        }
        getMetadataCascadePolicyById(metadataCascadePolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (metadataCascadePolicyId, optionalsInput = {}) {
                const optionals = new GetMetadataCascadePolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies/', toString(metadataCascadePolicyId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataCascadePolicy(response.data);
            });
        }
        deleteMetadataCascadePolicyById(metadataCascadePolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (metadataCascadePolicyId, optionalsInput = {}) {
                const optionals = new DeleteMetadataCascadePolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies/', toString(metadataCascadePolicyId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        applyMetadataCascadePolicy(metadataCascadePolicyId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (metadataCascadePolicyId, requestBody, optionalsInput = {}) {
                const optionals = new ApplyMetadataCascadePolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies/', toString(metadataCascadePolicyId), '/apply'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeApplyMetadataCascadePolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateMetadataCascadePolicyRequestBodyScopeField(val) {
        return val;
    }
    function serializeCreateMetadataCascadePolicyRequestBody(val) {
        return {
            ['folder_id']: val.folderId,
            ['scope']: serializeCreateMetadataCascadePolicyRequestBodyScopeField(val.scope),
            ['templateKey']: val.templateKey,
        };
    }
    function serializeApplyMetadataCascadePolicyRequestBodyConflictResolutionField(val) {
        return val;
    }
    function serializeApplyMetadataCascadePolicyRequestBody(val) {
        return {
            ['conflict_resolution']: serializeApplyMetadataCascadePolicyRequestBodyConflictResolutionField(val.conflictResolution),
        };
    }

    function deserializeFileOrFolder(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileOrFolder"' });
        }
        if (val.type == 'file') {
            return deserializeFile(val);
        }
        if (val.type == 'folder') {
            return deserializeFolder(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize FileOrFolder" });
    }

    function deserializeMetadataQueryResults(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataQueryResults"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "MetadataQueryResults"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileOrFolder(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "MetadataQueryResults"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "MetadataQueryResults"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    function serializeMetadataQueryOrderByDirectionField(val) {
        return val;
    }
    function serializeMetadataQueryOrderByField(val) {
        return {
            ['field_key']: val.fieldKey == void 0 ? void 0 : val.fieldKey,
            ['direction']: val.direction == void 0
                ? void 0
                : serializeMetadataQueryOrderByDirectionField(val.direction),
        };
    }
    function serializeMetadataQuery(val) {
        return {
            ['from']: val.from,
            ['query']: val.query == void 0 ? void 0 : val.query,
            ['query_params']: val.queryParams == void 0 ? void 0 : val.queryParams,
            ['ancestor_folder_id']: val.ancestorFolderId,
            ['order_by']: val.orderBy == void 0
                ? void 0
                : val.orderBy.map(function (item) {
                    return serializeMetadataQueryOrderByField(item);
                }),
            ['limit']: val.limit == void 0 ? void 0 : val.limit,
            ['marker']: val.marker == void 0 ? void 0 : val.marker,
            ['fields']: val.fields == void 0
                ? void 0
                : val.fields.map(function (item) {
                    return item;
                }),
        };
    }

    function deserializeFileFullOrFolderFullOrWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullOrFolderFullOrWebLink"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileFull(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderFull(val);
        }
        if (val.type == 'web_link') {
            return deserializeWebLink(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullOrFolderFullOrWebLink",
        });
    }

    function deserializeSearchResultsTypeField(val) {
        if (val == 'search_results_items') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SearchResultsTypeField",
        });
    }
    function deserializeSearchResults(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SearchResults"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "SearchResults"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SearchResults"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "SearchResults"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "SearchResults" to be defined',
            });
        }
        const type = deserializeSearchResultsTypeField(val.type);
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SearchResults"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullOrFolderFullOrWebLink(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            type: type,
            entries: entries,
        };
    }

    function deserializeSearchResultWithSharedLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SearchResultWithSharedLink"',
            });
        }
        if (!(val.accessible_via_shared_link == void 0) &&
            !sdIsString(val.accessible_via_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "accessible_via_shared_link" of type "SearchResultWithSharedLink"',
            });
        }
        const accessibleViaSharedLink = val.accessible_via_shared_link == void 0
            ? void 0
            : val.accessible_via_shared_link;
        const item = val.item == void 0
            ? void 0
            : deserializeFileFullOrFolderFullOrWebLink(val.item);
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "SearchResultWithSharedLink"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        return {
            accessibleViaSharedLink: accessibleViaSharedLink,
            item: item,
            type: type,
        };
    }

    function deserializeSearchResultsWithSharedLinksTypeField(val) {
        if (val == 'search_results_with_shared_links') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SearchResultsWithSharedLinksTypeField",
        });
    }
    function deserializeSearchResultsWithSharedLinks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SearchResultsWithSharedLinks"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "SearchResultsWithSharedLinks"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SearchResultsWithSharedLinks"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "SearchResultsWithSharedLinks"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "SearchResultsWithSharedLinks" to be defined',
            });
        }
        const type = deserializeSearchResultsWithSharedLinksTypeField(val.type);
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SearchResultsWithSharedLinks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeSearchResultWithSharedLink(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            type: type,
            entries: entries,
        };
    }

    function deserializeSearchResultsOrSearchResultsWithSharedLinks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SearchResultsOrSearchResultsWithSharedLinks"',
            });
        }
        if (val.type == 'search_results_items') {
            return deserializeSearchResults(val);
        }
        if (val.type == 'search_results_with_shared_links') {
            return deserializeSearchResultsWithSharedLinks(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize SearchResultsOrSearchResultsWithSharedLinks",
        });
    }

    function serializeMetadataFieldFilterDateRange(val) {
        return {
            ['lt']: val.lt == void 0 ? void 0 : dateTimeToString(val.lt),
            ['gt']: val.gt == void 0 ? void 0 : dateTimeToString(val.gt),
        };
    }

    function serializeMetadataFieldFilterFloatRange(val) {
        return {
            ['lt']: val.lt == void 0 ? void 0 : val.lt,
            ['gt']: val.gt == void 0 ? void 0 : val.gt,
        };
    }

    function serializeMetadataFieldFilterDateRangeOrMetadataFieldFilterFloatRangeOrArrayOfStringOrNumberOrString(val) {
        if (sdIsString(val)) {
            return val;
        }
        if (sdIsNumber(val)) {
            return val;
        }
        if (sdIsList(val)) {
            return val;
        }
        try {
            return serializeMetadataFieldFilterDateRange(val);
        }
        catch (error) {
        }
        finally {
        }
        try {
            return serializeMetadataFieldFilterFloatRange(val);
        }
        catch (error) {
        }
        finally {
        }
        throw new BoxSdkError({
            message: "Can't serialize MetadataFieldFilterDateRangeOrMetadataFieldFilterFloatRangeOrArrayOfStringOrNumberOrString",
        });
    }

    function serializeMetadataFilterScopeField(val) {
        return val;
    }
    function serializeMetadataFilter(val) {
        return {
            ['scope']: val.scope == void 0
                ? void 0
                : serializeMetadataFilterScopeField(val.scope),
            ['templateKey']: val.templateKey == void 0 ? void 0 : val.templateKey,
            ['filters']: val.filters == void 0
                ? void 0
                : Object.fromEntries(Object.entries(val.filters).map(([k, v]) => [
                    k,
                    serializeMetadataFieldFilterDateRangeOrMetadataFieldFilterFloatRangeOrArrayOfStringOrNumberOrString(v),
                ])),
        };
    }

    class SearchByMetadataQueryOptionals {
        constructor(fields) {
            this.headers = new SearchByMetadataQueryHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class SearchByMetadataQueryHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SearchForContentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SearchManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        searchByMetadataQuery(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new SearchByMetadataQueryOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_queries/execute_read'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeMetadataQuery(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeMetadataQueryResults(response.data);
            });
        }
        searchForContent() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new SearchForContentHeaders({}), cancellationToken) {
                const headers = new SearchForContentHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['query']: toString(queryParams.query),
                    ['scope']: toString(queryParams.scope),
                    ['file_extensions']: queryParams.fileExtensions
                        ? queryParams.fileExtensions.map(toString).join(',')
                        : undefined,
                    ['created_at_range']: queryParams.createdAtRange
                        ? queryParams.createdAtRange.map(toString).join(',')
                        : undefined,
                    ['updated_at_range']: queryParams.updatedAtRange
                        ? queryParams.updatedAtRange.map(toString).join(',')
                        : undefined,
                    ['size_range']: queryParams.sizeRange
                        ? queryParams.sizeRange.map(toString).join(',')
                        : undefined,
                    ['owner_user_ids']: queryParams.ownerUserIds
                        ? queryParams.ownerUserIds.map(toString).join(',')
                        : undefined,
                    ['recent_updater_user_ids']: queryParams.recentUpdaterUserIds
                        ? queryParams.recentUpdaterUserIds.map(toString).join(',')
                        : undefined,
                    ['ancestor_folder_ids']: queryParams.ancestorFolderIds
                        ? queryParams.ancestorFolderIds.map(toString).join(',')
                        : undefined,
                    ['content_types']: queryParams.contentTypes
                        ? queryParams.contentTypes.map(toString).join(',')
                        : undefined,
                    ['type']: toString(queryParams.type),
                    ['trash_content']: toString(queryParams.trashContent),
                    ['mdfilters']: queryParams.mdfilters
                        ? sdToJson(queryParams.mdfilters.map(serializeMetadataFilter))
                        : undefined,
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                    ['limit']: toString(queryParams.limit),
                    ['include_recent_shared_links']: toString(queryParams.includeRecentSharedLinks),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['deleted_user_ids']: queryParams.deletedUserIds
                        ? queryParams.deletedUserIds.map(toString).join(',')
                        : undefined,
                    ['deleted_at_range']: queryParams.deletedAtRange
                        ? queryParams.deletedAtRange.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/search'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSearchResultsOrSearchResultsWithSharedLinks(response.data);
            });
        }
    }

    class GetCollaborationByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetCollaborationByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateCollaborationByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateCollaborationByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCollaborationByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCollaborationByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateCollaborationOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateCollaborationHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateCollaborationByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCollaborationByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCollaborationHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UserCollaborationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getCollaborationById(collaborationId_1) {
            return __awaiter(this, arguments, void 0, function* (collaborationId, optionalsInput = {}) {
                const optionals = new GetCollaborationByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations/', toString(collaborationId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaboration(response.data);
            });
        }
        updateCollaborationById(collaborationId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (collaborationId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateCollaborationByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations/', toString(collaborationId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateCollaborationByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaboration(response.data);
            });
        }
        deleteCollaborationById(collaborationId_1) {
            return __awaiter(this, arguments, void 0, function* (collaborationId, optionalsInput = {}) {
                const optionals = new DeleteCollaborationByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations/', toString(collaborationId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        createCollaboration(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCollaborationOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['notify']: toString(queryParams.notify),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateCollaborationRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaboration(response.data);
            });
        }
    }
    function serializeUpdateCollaborationByIdRequestBodyRoleField(val) {
        return val;
    }
    function serializeUpdateCollaborationByIdRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateCollaborationByIdRequestBody(val) {
        return {
            ['role']: serializeUpdateCollaborationByIdRequestBodyRoleField(val.role),
            ['status']: val.status == void 0
                ? void 0
                : serializeUpdateCollaborationByIdRequestBodyStatusField(val.status),
            ['expires_at']: val.expiresAt == void 0 ? void 0 : dateTimeToString(val.expiresAt),
            ['can_view_path']: val.canViewPath == void 0 ? void 0 : val.canViewPath,
        };
    }
    function serializeCreateCollaborationRequestBodyItemTypeField(val) {
        return val;
    }
    function serializeCreateCollaborationRequestBodyItemField(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeCreateCollaborationRequestBodyItemTypeField(val.type),
            ['id']: val.id == void 0 ? void 0 : val.id,
        };
    }
    function serializeCreateCollaborationRequestBodyAccessibleByTypeField(val) {
        return val;
    }
    function serializeCreateCollaborationRequestBodyAccessibleByField(val) {
        return {
            ['type']: serializeCreateCollaborationRequestBodyAccessibleByTypeField(val.type),
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['login']: val.login == void 0 ? void 0 : val.login,
        };
    }
    function serializeCreateCollaborationRequestBodyRoleField(val) {
        return val;
    }
    function serializeCreateCollaborationRequestBody(val) {
        return {
            ['item']: serializeCreateCollaborationRequestBodyItemField(val.item),
            ['accessible_by']: serializeCreateCollaborationRequestBodyAccessibleByField(val.accessibleBy),
            ['role']: serializeCreateCollaborationRequestBodyRoleField(val.role),
            ['is_access_only']: val.isAccessOnly == void 0 ? void 0 : val.isAccessOnly,
            ['can_view_path']: val.canViewPath == void 0 ? void 0 : val.canViewPath,
            ['expires_at']: val.expiresAt == void 0 ? void 0 : dateTimeToString(val.expiresAt),
        };
    }

    class GetTaskAssignmentsOptionals {
        constructor(fields) {
            this.headers = new GetTaskAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateTaskAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateTaskAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTaskAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetTaskAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTaskAssignmentByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateTaskAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTaskAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTaskAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTaskAssignmentsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTaskAssignmentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTaskAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTaskAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTaskAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TaskAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getTaskAssignments(taskId_1) {
            return __awaiter(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new GetTaskAssignmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId), '/assignments'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTaskAssignments(response.data);
            });
        }
        createTaskAssignment(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTaskAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTaskAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTaskAssignment(response.data);
            });
        }
        getTaskAssignmentById(taskAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (taskAssignmentId, optionalsInput = {}) {
                const optionals = new GetTaskAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments/', toString(taskAssignmentId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTaskAssignment(response.data);
            });
        }
        updateTaskAssignmentById(taskAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (taskAssignmentId, optionalsInput = {}) {
                const optionals = new UpdateTaskAssignmentByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments/', toString(taskAssignmentId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTaskAssignmentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTaskAssignment(response.data);
            });
        }
        deleteTaskAssignmentById(taskAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (taskAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteTaskAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments/', toString(taskAssignmentId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateTaskAssignmentRequestBodyTaskTypeField(val) {
        return val;
    }
    function serializeCreateTaskAssignmentRequestBodyTaskField(val) {
        return {
            ['id']: val.id,
            ['type']: serializeCreateTaskAssignmentRequestBodyTaskTypeField(val.type),
        };
    }
    function serializeCreateTaskAssignmentRequestBodyAssignToField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['login']: val.login == void 0 ? void 0 : val.login,
        };
    }
    function serializeCreateTaskAssignmentRequestBody(val) {
        return {
            ['task']: serializeCreateTaskAssignmentRequestBodyTaskField(val.task),
            ['assign_to']: serializeCreateTaskAssignmentRequestBodyAssignToField(val.assignTo),
        };
    }
    function serializeUpdateTaskAssignmentByIdRequestBodyResolutionStateField(val) {
        return val;
    }
    function serializeUpdateTaskAssignmentByIdRequestBody(val) {
        return {
            ['message']: val.message == void 0 ? void 0 : val.message,
            ['resolution_state']: val.resolutionState == void 0
                ? void 0
                : serializeUpdateTaskAssignmentByIdRequestBodyResolutionStateField(val.resolutionState),
        };
    }

    class FindFileForSharedLinkOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSharedLinkForFileOptionals {
        constructor(fields) {
            this.headers = new GetSharedLinkForFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddShareLinkToFileOptionals {
        constructor(fields) {
            this.headers = new AddShareLinkToFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSharedLinkOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateSharedLinkOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RemoveSharedLinkFromFileOptionals {
        constructor(fields) {
            this.headers = new RemoveSharedLinkFromFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class FindFileForSharedLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifNoneMatch) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSharedLinkForFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddShareLinkToFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSharedLinkOnFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RemoveSharedLinkFromFileHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SharedLinksFilesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        findFileForSharedLink() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput, optionalsInput = {}) {
                const headers = new FindFileForSharedLinkHeaders({
                    ifNoneMatch: headersInput.ifNoneMatch,
                    boxapi: headersInput.boxapi,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new FindFileForSharedLinkOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shared_items'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
        getSharedLinkForFile(fileId_1, queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, queryParams, optionalsInput = {}) {
                const optionals = new GetSharedLinkForFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#get_shared_link'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
        addShareLinkToFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new AddShareLinkToFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#add_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeAddShareLinkToFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
        updateSharedLinkOnFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new UpdateSharedLinkOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#update_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateSharedLinkOnFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
        removeSharedLinkFromFile(fileId_1) {
            return __awaiter(this, arguments, void 0, function* (fileId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new RemoveSharedLinkFromFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#remove_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRemoveSharedLinkFromFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileFull(response.data);
            });
        }
    }
    function serializeAddShareLinkToFileRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeAddShareLinkToFileRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
            ['can_preview']: val.canPreview == void 0 ? void 0 : val.canPreview,
            ['can_edit']: val.canEdit == void 0 ? void 0 : val.canEdit,
        };
    }
    function serializeAddShareLinkToFileRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeAddShareLinkToFileRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeAddShareLinkToFileRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeAddShareLinkToFileRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeAddShareLinkToFileRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeUpdateSharedLinkOnFileRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateSharedLinkOnFileRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
            ['can_preview']: val.canPreview == void 0 ? void 0 : val.canPreview,
            ['can_edit']: val.canEdit == void 0 ? void 0 : val.canEdit,
        };
    }
    function serializeUpdateSharedLinkOnFileRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateSharedLinkOnFileRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeUpdateSharedLinkOnFileRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateSharedLinkOnFileRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeUpdateSharedLinkOnFileRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeRemoveSharedLinkFromFileRequestBodySharedLinkField(val) {
        return {};
    }
    function serializeRemoveSharedLinkFromFileRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeRemoveSharedLinkFromFileRequestBodySharedLinkField(val.sharedLink),
        };
    }

    class FindFolderForSharedLinkOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSharedLinkForFolderOptionals {
        constructor(fields) {
            this.headers = new GetSharedLinkForFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddShareLinkToFolderOptionals {
        constructor(fields) {
            this.headers = new AddShareLinkToFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSharedLinkOnFolderOptionals {
        constructor(fields) {
            this.headers = new UpdateSharedLinkOnFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RemoveSharedLinkFromFolderOptionals {
        constructor(fields) {
            this.headers = new RemoveSharedLinkFromFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class FindFolderForSharedLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifNoneMatch) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSharedLinkForFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddShareLinkToFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSharedLinkOnFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RemoveSharedLinkFromFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SharedLinksFoldersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        findFolderForSharedLink() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput, optionalsInput = {}) {
                const headers = new FindFolderForSharedLinkHeaders({
                    ifNoneMatch: headersInput.ifNoneMatch,
                    boxapi: headersInput.boxapi,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new FindFolderForSharedLinkOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shared_items#folders'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
        getSharedLinkForFolder(folderId_1, queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, queryParams, optionalsInput = {}) {
                const optionals = new GetSharedLinkForFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#get_shared_link'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
        addShareLinkToFolder(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new AddShareLinkToFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#add_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeAddShareLinkToFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
        updateSharedLinkOnFolder(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new UpdateSharedLinkOnFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#update_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateSharedLinkOnFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
        removeSharedLinkFromFolder(folderId_1) {
            return __awaiter(this, arguments, void 0, function* (folderId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new RemoveSharedLinkFromFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#remove_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRemoveSharedLinkFromFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
    }
    function serializeAddShareLinkToFolderRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeAddShareLinkToFolderRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
            ['can_preview']: val.canPreview == void 0 ? void 0 : val.canPreview,
            ['can_edit']: val.canEdit == void 0 ? void 0 : val.canEdit,
        };
    }
    function serializeAddShareLinkToFolderRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeAddShareLinkToFolderRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeAddShareLinkToFolderRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeAddShareLinkToFolderRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeAddShareLinkToFolderRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeUpdateSharedLinkOnFolderRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateSharedLinkOnFolderRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
            ['can_preview']: val.canPreview == void 0 ? void 0 : val.canPreview,
            ['can_edit']: val.canEdit == void 0 ? void 0 : val.canEdit,
        };
    }
    function serializeUpdateSharedLinkOnFolderRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateSharedLinkOnFolderRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeUpdateSharedLinkOnFolderRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateSharedLinkOnFolderRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeUpdateSharedLinkOnFolderRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeRemoveSharedLinkFromFolderRequestBodySharedLinkField(val) {
        return {};
    }
    function serializeRemoveSharedLinkFromFolderRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeRemoveSharedLinkFromFolderRequestBodySharedLinkField(val.sharedLink),
        };
    }

    class CreateWebLinkOptionals {
        constructor(fields) {
            this.headers = new CreateWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetWebLinkByIdOptionals {
        constructor(fields) {
            this.headers = new GetWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateWebLinkByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteWebLinkByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateWebLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetWebLinkByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateWebLinkByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteWebLinkByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class WebLinksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        createWebLink(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
        getWebLinkById(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new GetWebLinkByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['boxapi']: toString(headers.boxapi) }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
        updateWebLinkById(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new UpdateWebLinkByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateWebLinkByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
        deleteWebLinkById(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new DeleteWebLinkByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateWebLinkRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateWebLinkRequestBody(val) {
        return {
            ['url']: val.url,
            ['parent']: serializeCreateWebLinkRequestBodyParentField(val.parent),
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['description']: val.description == void 0 ? void 0 : val.description,
        };
    }
    function serializeUpdateWebLinkByIdRequestBodyParentField(val) {
        return { ['id']: val.id == void 0 ? void 0 : val.id };
    }
    function serializeUpdateWebLinkByIdRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateWebLinkByIdRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateWebLinkByIdRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
        };
    }
    function serializeUpdateWebLinkByIdRequestBody(val) {
        return {
            ['url']: val.url == void 0 ? void 0 : val.url,
            ['parent']: val.parent == void 0
                ? void 0
                : serializeUpdateWebLinkByIdRequestBodyParentField(val.parent),
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeUpdateWebLinkByIdRequestBodySharedLinkField(val.sharedLink),
        };
    }

    function deserializeTrashWebLinkRestoredTypeField(val) {
        if (val == 'web_link') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkRestoredTypeField",
        });
    }
    function deserializeTrashWebLinkRestoredPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkRestoredPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashWebLinkRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashWebLinkRestoredPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashWebLinkRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashWebLinkRestoredPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashWebLinkRestoredItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkRestoredItemStatusField",
        });
    }
    function deserializeTrashWebLinkRestored(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkRestored"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashWebLinkRestoredTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashWebLinkRestored"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (val.sequence_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sequence_id" of type "TrashWebLinkRestored" to be defined',
            });
        }
        if (!sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashWebLinkRestored"',
            });
        }
        const sequenceId = val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashWebLinkRestored"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashWebLinkRestored"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "TrashWebLinkRestored"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashWebLinkRestored"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashWebLinkRestored" to be defined',
            });
        }
        const pathCollection = deserializeTrashWebLinkRestoredPathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashWebLinkRestored"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashWebLinkRestored"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashWebLinkRestored"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : val.trashed_at;
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashWebLinkRestored"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : val.purged_at;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashWebLinkRestored"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeTrashWebLinkRestoredItemStatusField(val.item_status);
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
            url: url,
            parent: parent,
            description: description,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            itemStatus: itemStatus,
        };
    }

    function deserializeTrashWebLinkTypeField(val) {
        if (val == 'web_link') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrashWebLinkTypeField" });
    }
    function deserializeTrashWebLinkPathCollectionEntriesTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkPathCollectionEntriesTypeField",
        });
    }
    function deserializeTrashWebLinkPathCollectionEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashWebLinkPathCollectionEntriesTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
        };
    }
    function deserializeTrashWebLinkPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashWebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashWebLinkPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashWebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashWebLinkPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTrashWebLinkPathCollectionEntriesField(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashWebLinkItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkItemStatusField",
        });
    }
    function deserializeTrashWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrashWebLink"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeTrashWebLinkTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashWebLink"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashWebLink"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashWebLink"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashWebLink"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "TrashWebLink"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashWebLink"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeTrashWebLinkPathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashWebLink"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashWebLink"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashWebLink"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashWebLink"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashWebLink"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeTrashWebLinkItemStatusField(val.item_status);
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
            url: url,
            parent: parent,
            description: description,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            itemStatus: itemStatus,
        };
    }

    class RestoreWeblinkFromTrashOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new RestoreWeblinkFromTrashHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTrashedWebLinkByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetTrashedWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTrashedWebLinkByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTrashedWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RestoreWeblinkFromTrashHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTrashedWebLinkByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTrashedWebLinkByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedWebLinksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        restoreWeblinkFromTrash(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new RestoreWeblinkFromTrashOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRestoreWeblinkFromTrashRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTrashWebLinkRestored(response.data);
            });
        }
        getTrashedWebLinkById(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new GetTrashedWebLinkByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '/trash'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTrashWebLink(response.data);
            });
        }
        deleteTrashedWebLinkById(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new DeleteTrashedWebLinkByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '/trash'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeRestoreWeblinkFromTrashRequestBodyParentField(val) {
        return { ['id']: val.id == void 0 ? void 0 : val.id };
    }
    function serializeRestoreWeblinkFromTrashRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['parent']: val.parent == void 0
                ? void 0
                : serializeRestoreWeblinkFromTrashRequestBodyParentField(val.parent),
        };
    }

    class FindWebLinkForSharedLinkOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSharedLinkForWebLinkOptionals {
        constructor(fields) {
            this.headers = new GetSharedLinkForWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddShareLinkToWebLinkOptionals {
        constructor(fields) {
            this.headers = new AddShareLinkToWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSharedLinkOnWebLinkOptionals {
        constructor(fields) {
            this.headers = new UpdateSharedLinkOnWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RemoveSharedLinkFromWebLinkOptionals {
        constructor(fields) {
            this.headers = new RemoveSharedLinkFromWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class FindWebLinkForSharedLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.ifNoneMatch) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSharedLinkForWebLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddShareLinkToWebLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSharedLinkOnWebLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RemoveSharedLinkFromWebLinkHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SharedLinksWebLinksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        findWebLinkForSharedLink() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput, optionalsInput = {}) {
                const headers = new FindWebLinkForSharedLinkHeaders({
                    ifNoneMatch: headersInput.ifNoneMatch,
                    boxapi: headersInput.boxapi,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new FindWebLinkForSharedLinkOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shared_items#web_links'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
        getSharedLinkForWebLink(webLinkId_1, queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, queryParams, optionalsInput = {}) {
                const optionals = new GetSharedLinkForWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#get_shared_link'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
        addShareLinkToWebLink(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new AddShareLinkToWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#add_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeAddShareLinkToWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
        updateSharedLinkOnWebLink(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new UpdateSharedLinkOnWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#update_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateSharedLinkOnWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
        removeSharedLinkFromWebLink(webLinkId_1) {
            return __awaiter(this, arguments, void 0, function* (webLinkId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new RemoveSharedLinkFromWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#remove_shared_link'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRemoveSharedLinkFromWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebLink(response.data);
            });
        }
    }
    function serializeAddShareLinkToWebLinkRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeAddShareLinkToWebLinkRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
            ['can_preview']: val.canPreview == void 0 ? void 0 : val.canPreview,
            ['can_edit']: val.canEdit == void 0 ? void 0 : val.canEdit,
        };
    }
    function serializeAddShareLinkToWebLinkRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeAddShareLinkToWebLinkRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeAddShareLinkToWebLinkRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeAddShareLinkToWebLinkRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeAddShareLinkToWebLinkRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0 ? void 0 : val.canDownload,
            ['can_preview']: val.canPreview == void 0 ? void 0 : val.canPreview,
            ['can_edit']: val.canEdit == void 0 ? void 0 : val.canEdit,
        };
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? void 0
                : serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['vanity_name']: val.vanityName == void 0 ? void 0 : val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0 ? void 0 : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? void 0
                : serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeRemoveSharedLinkFromWebLinkRequestBodySharedLinkField(val) {
        return {};
    }
    function serializeRemoveSharedLinkFromWebLinkRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? void 0
                : serializeRemoveSharedLinkFromWebLinkRequestBodySharedLinkField(val.sharedLink),
        };
    }

    function deserializeUserStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'inactive') {
            return val;
        }
        if (val == 'cannot_delete_edit') {
            return val;
        }
        if (val == 'cannot_delete_edit_upload') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize UserStatusField" });
    }
    function deserializeUserNotificationEmailField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserNotificationEmailField"',
            });
        }
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "UserNotificationEmailField"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        if (!(val.is_confirmed == void 0) && !sdIsBoolean(val.is_confirmed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_confirmed" of type "UserNotificationEmailField"',
            });
        }
        const isConfirmed = val.is_confirmed == void 0 ? void 0 : val.is_confirmed;
        return {
            email: email,
            isConfirmed: isConfirmed,
        };
    }
    function deserializeUser(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "User"' });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "User"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "User"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.language == void 0) && !sdIsString(val.language)) {
            throw new BoxSdkError({
                message: 'Expecting string for "language" of type "User"',
            });
        }
        const language = val.language == void 0 ? void 0 : val.language;
        if (!(val.timezone == void 0) && !sdIsString(val.timezone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "timezone" of type "User"',
            });
        }
        const timezone = val.timezone == void 0 ? void 0 : val.timezone;
        if (!(val.space_amount == void 0) && !sdIsNumber(val.space_amount)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_amount" of type "User"',
            });
        }
        const spaceAmount = val.space_amount == void 0 ? void 0 : val.space_amount;
        if (!(val.space_used == void 0) && !sdIsNumber(val.space_used)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_used" of type "User"',
            });
        }
        const spaceUsed = val.space_used == void 0 ? void 0 : val.space_used;
        if (!(val.max_upload_size == void 0) && !sdIsNumber(val.max_upload_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "max_upload_size" of type "User"',
            });
        }
        const maxUploadSize = val.max_upload_size == void 0 ? void 0 : val.max_upload_size;
        const status = val.status == void 0 ? void 0 : deserializeUserStatusField(val.status);
        if (!(val.job_title == void 0) && !sdIsString(val.job_title)) {
            throw new BoxSdkError({
                message: 'Expecting string for "job_title" of type "User"',
            });
        }
        const jobTitle = val.job_title == void 0 ? void 0 : val.job_title;
        if (!(val.phone == void 0) && !sdIsString(val.phone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "phone" of type "User"',
            });
        }
        const phone = val.phone == void 0 ? void 0 : val.phone;
        if (!(val.address == void 0) && !sdIsString(val.address)) {
            throw new BoxSdkError({
                message: 'Expecting string for "address" of type "User"',
            });
        }
        const address = val.address == void 0 ? void 0 : val.address;
        if (!(val.avatar_url == void 0) && !sdIsString(val.avatar_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "avatar_url" of type "User"',
            });
        }
        const avatarUrl = val.avatar_url == void 0 ? void 0 : val.avatar_url;
        const notificationEmail = val.notification_email == void 0
            ? void 0
            : deserializeUserNotificationEmailField(val.notification_email);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "User"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "User"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "User" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "User"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "User" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            language: language,
            timezone: timezone,
            spaceAmount: spaceAmount,
            spaceUsed: spaceUsed,
            maxUploadSize: maxUploadSize,
            status: status,
            jobTitle: jobTitle,
            phone: phone,
            address: address,
            avatarUrl: avatarUrl,
            notificationEmail: notificationEmail,
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function serializeTrackingCodeTypeField(val) {
        return val;
    }
    function deserializeTrackingCodeTypeField(val) {
        if (val == 'tracking_code') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrackingCodeTypeField" });
    }
    function serializeTrackingCode(val) {
        return {
            ['type']: val.type == void 0 ? void 0 : serializeTrackingCodeTypeField(val.type),
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['value']: val.value == void 0 ? void 0 : val.value,
        };
    }
    function deserializeTrackingCode(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrackingCode"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeTrackingCodeTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrackingCode"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.value == void 0) && !sdIsString(val.value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "value" of type "TrackingCode"',
            });
        }
        const value = val.value == void 0 ? void 0 : val.value;
        return { type: type, name: name, value: value };
    }

    function deserializeUserFullRoleField(val) {
        if (val == 'admin') {
            return val;
        }
        if (val == 'coadmin') {
            return val;
        }
        if (val == 'user') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize UserFullRoleField" });
    }
    function deserializeUserFullEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UserFullEnterpriseTypeField",
        });
    }
    function deserializeUserFullEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserFullEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserFullEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeUserFullEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserFullEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return { id: id, type: type, name: name };
    }
    function deserializeUserFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserFull"' });
        }
        const role = val.role == void 0 ? void 0 : deserializeUserFullRoleField(val.role);
        if (!(val.tracking_codes == void 0) && !sdIsList(val.tracking_codes)) {
            throw new BoxSdkError({
                message: 'Expecting array for "tracking_codes" of type "UserFull"',
            });
        }
        const trackingCodes = val.tracking_codes == void 0
            ? void 0
            : sdIsList(val.tracking_codes)
                ? val.tracking_codes.map(function (itm) {
                    return deserializeTrackingCode(itm);
                })
                : [];
        if (!(val.can_see_managed_users == void 0) &&
            !sdIsBoolean(val.can_see_managed_users)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_see_managed_users" of type "UserFull"',
            });
        }
        const canSeeManagedUsers = val.can_see_managed_users == void 0 ? void 0 : val.can_see_managed_users;
        if (!(val.is_sync_enabled == void 0) && !sdIsBoolean(val.is_sync_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_sync_enabled" of type "UserFull"',
            });
        }
        const isSyncEnabled = val.is_sync_enabled == void 0 ? void 0 : val.is_sync_enabled;
        if (!(val.is_external_collab_restricted == void 0) &&
            !sdIsBoolean(val.is_external_collab_restricted)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_external_collab_restricted" of type "UserFull"',
            });
        }
        const isExternalCollabRestricted = val.is_external_collab_restricted == void 0
            ? void 0
            : val.is_external_collab_restricted;
        if (!(val.is_exempt_from_device_limits == void 0) &&
            !sdIsBoolean(val.is_exempt_from_device_limits)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_exempt_from_device_limits" of type "UserFull"',
            });
        }
        const isExemptFromDeviceLimits = val.is_exempt_from_device_limits == void 0
            ? void 0
            : val.is_exempt_from_device_limits;
        if (!(val.is_exempt_from_login_verification == void 0) &&
            !sdIsBoolean(val.is_exempt_from_login_verification)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_exempt_from_login_verification" of type "UserFull"',
            });
        }
        const isExemptFromLoginVerification = val.is_exempt_from_login_verification == void 0
            ? void 0
            : val.is_exempt_from_login_verification;
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeUserFullEnterpriseField(val.enterprise);
        if (!(val.my_tags == void 0) && !sdIsList(val.my_tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "my_tags" of type "UserFull"',
            });
        }
        const myTags = val.my_tags == void 0
            ? void 0
            : sdIsList(val.my_tags)
                ? val.my_tags.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "UserFull"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.hostname == void 0) && !sdIsString(val.hostname)) {
            throw new BoxSdkError({
                message: 'Expecting string for "hostname" of type "UserFull"',
            });
        }
        const hostname = val.hostname == void 0 ? void 0 : val.hostname;
        if (!(val.is_platform_access_only == void 0) &&
            !sdIsBoolean(val.is_platform_access_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_platform_access_only" of type "UserFull"',
            });
        }
        const isPlatformAccessOnly = val.is_platform_access_only == void 0
            ? void 0
            : val.is_platform_access_only;
        if (!(val.external_app_user_id == void 0) &&
            !sdIsString(val.external_app_user_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_app_user_id" of type "UserFull"',
            });
        }
        const externalAppUserId = val.external_app_user_id == void 0 ? void 0 : val.external_app_user_id;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "UserFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "UserFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.language == void 0) && !sdIsString(val.language)) {
            throw new BoxSdkError({
                message: 'Expecting string for "language" of type "UserFull"',
            });
        }
        const language = val.language == void 0 ? void 0 : val.language;
        if (!(val.timezone == void 0) && !sdIsString(val.timezone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "timezone" of type "UserFull"',
            });
        }
        const timezone = val.timezone == void 0 ? void 0 : val.timezone;
        if (!(val.space_amount == void 0) && !sdIsNumber(val.space_amount)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_amount" of type "UserFull"',
            });
        }
        const spaceAmount = val.space_amount == void 0 ? void 0 : val.space_amount;
        if (!(val.space_used == void 0) && !sdIsNumber(val.space_used)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_used" of type "UserFull"',
            });
        }
        const spaceUsed = val.space_used == void 0 ? void 0 : val.space_used;
        if (!(val.max_upload_size == void 0) && !sdIsNumber(val.max_upload_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "max_upload_size" of type "UserFull"',
            });
        }
        const maxUploadSize = val.max_upload_size == void 0 ? void 0 : val.max_upload_size;
        const status = val.status == void 0 ? void 0 : deserializeUserStatusField(val.status);
        if (!(val.job_title == void 0) && !sdIsString(val.job_title)) {
            throw new BoxSdkError({
                message: 'Expecting string for "job_title" of type "UserFull"',
            });
        }
        const jobTitle = val.job_title == void 0 ? void 0 : val.job_title;
        if (!(val.phone == void 0) && !sdIsString(val.phone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "phone" of type "UserFull"',
            });
        }
        const phone = val.phone == void 0 ? void 0 : val.phone;
        if (!(val.address == void 0) && !sdIsString(val.address)) {
            throw new BoxSdkError({
                message: 'Expecting string for "address" of type "UserFull"',
            });
        }
        const address = val.address == void 0 ? void 0 : val.address;
        if (!(val.avatar_url == void 0) && !sdIsString(val.avatar_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "avatar_url" of type "UserFull"',
            });
        }
        const avatarUrl = val.avatar_url == void 0 ? void 0 : val.avatar_url;
        const notificationEmail = val.notification_email == void 0
            ? void 0
            : deserializeUserNotificationEmailField(val.notification_email);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserFull"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserFull"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserFull" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            role: role,
            trackingCodes: trackingCodes,
            canSeeManagedUsers: canSeeManagedUsers,
            isSyncEnabled: isSyncEnabled,
            isExternalCollabRestricted: isExternalCollabRestricted,
            isExemptFromDeviceLimits: isExemptFromDeviceLimits,
            isExemptFromLoginVerification: isExemptFromLoginVerification,
            enterprise: enterprise,
            myTags: myTags,
            hostname: hostname,
            isPlatformAccessOnly: isPlatformAccessOnly,
            externalAppUserId: externalAppUserId,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            language: language,
            timezone: timezone,
            spaceAmount: spaceAmount,
            spaceUsed: spaceUsed,
            maxUploadSize: maxUploadSize,
            status: status,
            jobTitle: jobTitle,
            phone: phone,
            address: address,
            avatarUrl: avatarUrl,
            notificationEmail: notificationEmail,
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function deserializeUsersOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UsersOrderDirectionField",
        });
    }
    function deserializeUsersOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UsersOrderField"' });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "UsersOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeUsersOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeUsers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Users"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Users"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Users"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Users"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Users"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Users"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Users"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeUsersOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Users"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeUserFull(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            totalCount: totalCount,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class CreateUserOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateUserHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateUserByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteUserByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new DeleteUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUsersHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateUserHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetUserMeHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetUserByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateUserByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteUserByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UsersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getUsers() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetUsersHeaders({}), cancellationToken) {
                const headers = new GetUsersHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['filter_term']: toString(queryParams.filterTerm),
                    ['user_type']: toString(queryParams.userType),
                    ['external_app_user_id']: toString(queryParams.externalAppUserId),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                    ['usemarker']: toString(queryParams.usemarker),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUsers(response.data);
            });
        }
        createUser(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateUserOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateUserRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUserFull(response.data);
            });
        }
        getUserMe() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetUserMeHeaders({}), cancellationToken) {
                const headers = new GetUserMeHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/me'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUserFull(response.data);
            });
        }
        getUserById(userId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUserFull(response.data);
            });
        }
        updateUserById(userId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new UpdateUserByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId)), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateUserByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUserFull(response.data);
            });
        }
        deleteUserById(userId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new DeleteUserByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['notify']: toString(queryParams.notify),
                    ['force']: toString(queryParams.force),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId)), {
                    method: 'DELETE',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateUserRequestBodyRoleField(val) {
        return val;
    }
    function serializeCreateUserRequestBodyStatusField(val) {
        return val;
    }
    function serializeCreateUserRequestBody(val) {
        return {
            ['name']: val.name,
            ['login']: val.login == void 0 ? void 0 : val.login,
            ['is_platform_access_only']: val.isPlatformAccessOnly == void 0 ? void 0 : val.isPlatformAccessOnly,
            ['role']: val.role == void 0
                ? void 0
                : serializeCreateUserRequestBodyRoleField(val.role),
            ['language']: val.language == void 0 ? void 0 : val.language,
            ['is_sync_enabled']: val.isSyncEnabled == void 0 ? void 0 : val.isSyncEnabled,
            ['job_title']: val.jobTitle == void 0 ? void 0 : val.jobTitle,
            ['phone']: val.phone == void 0 ? void 0 : val.phone,
            ['address']: val.address == void 0 ? void 0 : val.address,
            ['space_amount']: val.spaceAmount == void 0 ? void 0 : val.spaceAmount,
            ['tracking_codes']: val.trackingCodes == void 0
                ? void 0
                : val.trackingCodes.map(function (item) {
                    return serializeTrackingCode(item);
                }),
            ['can_see_managed_users']: val.canSeeManagedUsers == void 0 ? void 0 : val.canSeeManagedUsers,
            ['timezone']: val.timezone == void 0 ? void 0 : val.timezone,
            ['is_external_collab_restricted']: val.isExternalCollabRestricted == void 0
                ? void 0
                : val.isExternalCollabRestricted,
            ['is_exempt_from_device_limits']: val.isExemptFromDeviceLimits == void 0
                ? void 0
                : val.isExemptFromDeviceLimits,
            ['is_exempt_from_login_verification']: val.isExemptFromLoginVerification == void 0
                ? void 0
                : val.isExemptFromLoginVerification,
            ['status']: val.status == void 0
                ? void 0
                : serializeCreateUserRequestBodyStatusField(val.status),
            ['external_app_user_id']: val.externalAppUserId == void 0 ? void 0 : val.externalAppUserId,
        };
    }
    function serializeUpdateUserByIdRequestBodyRoleField(val) {
        return val;
    }
    function serializeUpdateUserByIdRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateUserByIdRequestBodyNotificationEmailField(val) {
        return { ['email']: val.email == void 0 ? void 0 : val.email };
    }
    function serializeUpdateUserByIdRequestBody(val) {
        return {
            ['enterprise']: val.enterprise == void 0 ? void 0 : val.enterprise,
            ['notify']: val.notify == void 0 ? void 0 : val.notify,
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['login']: val.login == void 0 ? void 0 : val.login,
            ['role']: val.role == void 0
                ? void 0
                : serializeUpdateUserByIdRequestBodyRoleField(val.role),
            ['language']: val.language == void 0 ? void 0 : val.language,
            ['is_sync_enabled']: val.isSyncEnabled == void 0 ? void 0 : val.isSyncEnabled,
            ['job_title']: val.jobTitle == void 0 ? void 0 : val.jobTitle,
            ['phone']: val.phone == void 0 ? void 0 : val.phone,
            ['address']: val.address == void 0 ? void 0 : val.address,
            ['tracking_codes']: val.trackingCodes == void 0
                ? void 0
                : val.trackingCodes.map(function (item) {
                    return serializeTrackingCode(item);
                }),
            ['can_see_managed_users']: val.canSeeManagedUsers == void 0 ? void 0 : val.canSeeManagedUsers,
            ['timezone']: val.timezone == void 0 ? void 0 : val.timezone,
            ['is_external_collab_restricted']: val.isExternalCollabRestricted == void 0
                ? void 0
                : val.isExternalCollabRestricted,
            ['is_exempt_from_device_limits']: val.isExemptFromDeviceLimits == void 0
                ? void 0
                : val.isExemptFromDeviceLimits,
            ['is_exempt_from_login_verification']: val.isExemptFromLoginVerification == void 0
                ? void 0
                : val.isExemptFromLoginVerification,
            ['is_password_reset_required']: val.isPasswordResetRequired == void 0
                ? void 0
                : val.isPasswordResetRequired,
            ['status']: val.status == void 0
                ? void 0
                : serializeUpdateUserByIdRequestBodyStatusField(val.status),
            ['space_amount']: val.spaceAmount == void 0 ? void 0 : val.spaceAmount,
            ['notification_email']: val.notificationEmail == void 0
                ? void 0
                : serializeUpdateUserByIdRequestBodyNotificationEmailField(val.notificationEmail),
            ['external_app_user_id']: val.externalAppUserId == void 0 ? void 0 : val.externalAppUserId,
        };
    }

    function deserializeSessionTerminationMessage(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SessionTerminationMessage"',
            });
        }
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "SessionTerminationMessage"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        return { message: message };
    }

    class TerminateUsersSessionsOptionals {
        constructor(fields) {
            this.headers = new TerminateUsersSessionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class TerminateGroupsSessionsOptionals {
        constructor(fields) {
            this.headers = new TerminateGroupsSessionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class TerminateUsersSessionsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TerminateGroupsSessionsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SessionTerminationManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        terminateUsersSessions(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new TerminateUsersSessionsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/terminate_sessions'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeTerminateUsersSessionsRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSessionTerminationMessage(response.data);
            });
        }
        terminateGroupsSessions(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new TerminateGroupsSessionsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/terminate_sessions'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeTerminateGroupsSessionsRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSessionTerminationMessage(response.data);
            });
        }
    }
    function serializeTerminateUsersSessionsRequestBody(val) {
        return {
            ['user_ids']: val.userIds.map(function (item) {
                return item;
            }),
            ['user_logins']: val.userLogins.map(function (item) {
                return item;
            }),
        };
    }
    function serializeTerminateGroupsSessionsRequestBody(val) {
        return {
            ['group_ids']: val.groupIds.map(function (item) {
                return item;
            }),
        };
    }

    function deserializeUserAvatarPicUrlsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserAvatarPicUrlsField"',
            });
        }
        if (!(val.small == void 0) && !sdIsString(val.small)) {
            throw new BoxSdkError({
                message: 'Expecting string for "small" of type "UserAvatarPicUrlsField"',
            });
        }
        const small = val.small == void 0 ? void 0 : val.small;
        if (!(val.large == void 0) && !sdIsString(val.large)) {
            throw new BoxSdkError({
                message: 'Expecting string for "large" of type "UserAvatarPicUrlsField"',
            });
        }
        const large = val.large == void 0 ? void 0 : val.large;
        if (!(val.preview == void 0) && !sdIsString(val.preview)) {
            throw new BoxSdkError({
                message: 'Expecting string for "preview" of type "UserAvatarPicUrlsField"',
            });
        }
        const preview = val.preview == void 0 ? void 0 : val.preview;
        return {
            small: small,
            large: large,
            preview: preview,
        };
    }
    function deserializeUserAvatar(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserAvatar"' });
        }
        const picUrls = val.pic_urls == void 0
            ? void 0
            : deserializeUserAvatarPicUrlsField(val.pic_urls);
        return { picUrls: picUrls };
    }

    class GetUserAvatarOptionals {
        constructor(fields) {
            this.headers = new GetUserAvatarHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateUserAvatarOptionals {
        constructor(fields) {
            this.headers = new CreateUserAvatarHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteUserAvatarOptionals {
        constructor(fields) {
            this.headers = new DeleteUserAvatarHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserAvatarHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateUserAvatarHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteUserAvatarHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AvatarsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getUserAvatar(userId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserAvatarOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/avatar'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return response.content;
            });
        }
        createUserAvatar(userId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (userId, requestBody, optionalsInput = {}) {
                const optionals = new CreateUserAvatarOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/avatar'), {
                    method: 'POST',
                    headers: headersMap,
                    multipartData: [
                        {
                            partName: 'pic',
                            fileStream: requestBody.pic,
                            fileName: requestBody.picFileName,
                            contentType: requestBody.picContentType,
                        },
                    ],
                    contentType: 'multipart/form-data',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeUserAvatar(response.data);
            });
        }
        deleteUserAvatar(userId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new DeleteUserAvatarOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/avatar'), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }

    class TransferOwnedFolderOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new TransferOwnedFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class TransferOwnedFolderHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TransferManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        transferOwnedFolder(userId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (userId, requestBody, optionalsInput = {}) {
                const optionals = new TransferOwnedFolderOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['notify']: toString(queryParams.notify),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/folders/0'), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeTransferOwnedFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFolderFull(response.data);
            });
        }
    }
    function serializeTransferOwnedFolderRequestBodyOwnedByField(val) {
        return { ['id']: val.id };
    }
    function serializeTransferOwnedFolderRequestBody(val) {
        return {
            ['owned_by']: serializeTransferOwnedFolderRequestBodyOwnedByField(val.ownedBy),
        };
    }

    function deserializeEmailAliasTypeField(val) {
        if (val == 'email_alias') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize EmailAliasTypeField" });
    }
    function deserializeEmailAlias(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EmailAlias"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "EmailAlias"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeEmailAliasTypeField(val.type);
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "EmailAlias"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        if (!(val.is_confirmed == void 0) && !sdIsBoolean(val.is_confirmed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_confirmed" of type "EmailAlias"',
            });
        }
        const isConfirmed = val.is_confirmed == void 0 ? void 0 : val.is_confirmed;
        return {
            id: id,
            type: type,
            email: email,
            isConfirmed: isConfirmed,
        };
    }

    function deserializeEmailAliases(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EmailAliases"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "EmailAliases"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "EmailAliases"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeEmailAlias(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    class GetUserEmailAliasesOptionals {
        constructor(fields) {
            this.headers = new GetUserEmailAliasesHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateUserEmailAliasOptionals {
        constructor(fields) {
            this.headers = new CreateUserEmailAliasHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteUserEmailAliasByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteUserEmailAliasByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserEmailAliasesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateUserEmailAliasHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteUserEmailAliasByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class EmailAliasesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getUserEmailAliases(userId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserEmailAliasesOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/email_aliases'), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeEmailAliases(response.data);
            });
        }
        createUserEmailAlias(userId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (userId, requestBody, optionalsInput = {}) {
                const optionals = new CreateUserEmailAliasOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/email_aliases'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateUserEmailAliasRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeEmailAlias(response.data);
            });
        }
        deleteUserEmailAliasById(userId_1, emailAliasId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, emailAliasId, optionalsInput = {}) {
                const optionals = new DeleteUserEmailAliasByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/email_aliases/', toString(emailAliasId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateUserEmailAliasRequestBody(val) {
        return { ['email']: val.email };
    }

    function deserializeGroupMembershipTypeField(val) {
        if (val == 'group_membership') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMembershipTypeField",
        });
    }
    function deserializeGroupMembershipRoleField(val) {
        if (val == 'member') {
            return val;
        }
        if (val == 'admin') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMembershipRoleField",
        });
    }
    function deserializeGroupMembership(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "GroupMembership"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupMembership"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeGroupMembershipTypeField(val.type);
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        const group = val.group == void 0 ? void 0 : deserializeGroupMini(val.group);
        const role = val.role == void 0 ? void 0 : deserializeGroupMembershipRoleField(val.role);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "GroupMembership"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "GroupMembership"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            user: user,
            group: group,
            role: role,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    function deserializeGroupMembershipsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMembershipsOrderDirectionField",
        });
    }
    function deserializeGroupMembershipsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupMembershipsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "GroupMembershipsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeGroupMembershipsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeGroupMemberships(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupMemberships"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "GroupMemberships"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "GroupMemberships"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "GroupMemberships"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "GroupMemberships"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeGroupMembershipsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "GroupMemberships"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeGroupMembership(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetUserMembershipsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetUserMembershipsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupMembershipsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupMembershipsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateGroupMembershipOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateGroupMembershipHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupMembershipByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupMembershipByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateGroupMembershipByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateGroupMembershipByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteGroupMembershipByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteGroupMembershipByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserMembershipsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupMembershipsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateGroupMembershipHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupMembershipByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateGroupMembershipByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteGroupMembershipByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class MembershipsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getUserMemberships(userId_1) {
            return __awaiter(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserMembershipsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/memberships'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupMemberships(response.data);
            });
        }
        getGroupMemberships(groupId_1) {
            return __awaiter(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new GetGroupMembershipsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId), '/memberships'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupMemberships(response.data);
            });
        }
        createGroupMembership(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateGroupMembershipOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateGroupMembershipRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupMembership(response.data);
            });
        }
        getGroupMembershipById(groupMembershipId_1) {
            return __awaiter(this, arguments, void 0, function* (groupMembershipId, optionalsInput = {}) {
                const optionals = new GetGroupMembershipByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships/', toString(groupMembershipId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupMembership(response.data);
            });
        }
        updateGroupMembershipById(groupMembershipId_1) {
            return __awaiter(this, arguments, void 0, function* (groupMembershipId, optionalsInput = {}) {
                const optionals = new UpdateGroupMembershipByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships/', toString(groupMembershipId)), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateGroupMembershipByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupMembership(response.data);
            });
        }
        deleteGroupMembershipById(groupMembershipId_1) {
            return __awaiter(this, arguments, void 0, function* (groupMembershipId, optionalsInput = {}) {
                const optionals = new DeleteGroupMembershipByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships/', toString(groupMembershipId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateGroupMembershipRequestBodyUserField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateGroupMembershipRequestBodyGroupField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateGroupMembershipRequestBodyRoleField(val) {
        return val;
    }
    function serializeCreateGroupMembershipRequestBody(val) {
        return {
            ['user']: serializeCreateGroupMembershipRequestBodyUserField(val.user),
            ['group']: serializeCreateGroupMembershipRequestBodyGroupField(val.group),
            ['role']: val.role == void 0
                ? void 0
                : serializeCreateGroupMembershipRequestBodyRoleField(val.role),
            ['configurable_permissions']: val.configurablePermissions == void 0
                ? void 0
                : val.configurablePermissions,
        };
    }
    function serializeUpdateGroupMembershipByIdRequestBodyRoleField(val) {
        return val;
    }
    function serializeUpdateGroupMembershipByIdRequestBody(val) {
        return {
            ['role']: val.role == void 0
                ? void 0
                : serializeUpdateGroupMembershipByIdRequestBodyRoleField(val.role),
            ['configurable_permissions']: val.configurablePermissions == void 0
                ? void 0
                : val.configurablePermissions,
        };
    }

    function deserializeInviteTypeField(val) {
        if (val == 'invite') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize InviteTypeField" });
    }
    function deserializeInviteInvitedToTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize InviteInvitedToTypeField",
        });
    }
    function deserializeInviteInvitedToField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "InviteInvitedToField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "InviteInvitedToField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeInviteInvitedToTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "InviteInvitedToField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return { id: id, type: type, name: name };
    }
    function deserializeInvite(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Invite"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "Invite" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Invite"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "Invite" to be defined',
            });
        }
        const type = deserializeInviteTypeField(val.type);
        const invitedTo = val.invited_to == void 0
            ? void 0
            : deserializeInviteInvitedToField(val.invited_to);
        const actionableBy = val.actionable_by == void 0
            ? void 0
            : deserializeUserMini(val.actionable_by);
        const invitedBy = val.invited_by == void 0 ? void 0 : deserializeUserMini(val.invited_by);
        if (!(val.status == void 0) && !sdIsString(val.status)) {
            throw new BoxSdkError({
                message: 'Expecting string for "status" of type "Invite"',
            });
        }
        const status = val.status == void 0 ? void 0 : val.status;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Invite"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "Invite"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            invitedTo: invitedTo,
            actionableBy: actionableBy,
            invitedBy: invitedBy,
            status: status,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    class CreateInviteOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateInviteHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetInviteByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetInviteByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateInviteHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetInviteByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class InvitesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        createInvite(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateInviteOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/invites'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateInviteRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeInvite(response.data);
            });
        }
        getInviteById(inviteId_1) {
            return __awaiter(this, arguments, void 0, function* (inviteId, optionalsInput = {}) {
                const optionals = new GetInviteByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/invites/', toString(inviteId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeInvite(response.data);
            });
        }
    }
    function serializeCreateInviteRequestBodyEnterpriseField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateInviteRequestBodyActionableByField(val) {
        return { ['login']: val.login == void 0 ? void 0 : val.login };
    }
    function serializeCreateInviteRequestBody(val) {
        return {
            ['enterprise']: serializeCreateInviteRequestBodyEnterpriseField(val.enterprise),
            ['actionable_by']: serializeCreateInviteRequestBodyActionableByField(val.actionableBy),
        };
    }

    function deserializeGroupFullInvitabilityLevelField(val) {
        if (val == 'admins_only') {
            return val;
        }
        if (val == 'admins_and_members') {
            return val;
        }
        if (val == 'all_managed_users') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupFullInvitabilityLevelField",
        });
    }
    function deserializeGroupFullMemberViewabilityLevelField(val) {
        if (val == 'admins_only') {
            return val;
        }
        if (val == 'admins_and_members') {
            return val;
        }
        if (val == 'all_managed_users') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupFullMemberViewabilityLevelField",
        });
    }
    function deserializeGroupFullPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupFullPermissionsField"',
            });
        }
        if (!(val.can_invite_as_collaborator == void 0) &&
            !sdIsBoolean(val.can_invite_as_collaborator)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_invite_as_collaborator" of type "GroupFullPermissionsField"',
            });
        }
        const canInviteAsCollaborator = val.can_invite_as_collaborator == void 0
            ? void 0
            : val.can_invite_as_collaborator;
        return {
            canInviteAsCollaborator: canInviteAsCollaborator,
        };
    }
    function deserializeGroupFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "GroupFull"' });
        }
        if (!(val.provenance == void 0) && !sdIsString(val.provenance)) {
            throw new BoxSdkError({
                message: 'Expecting string for "provenance" of type "GroupFull"',
            });
        }
        const provenance = val.provenance == void 0 ? void 0 : val.provenance;
        if (!(val.external_sync_identifier == void 0) &&
            !sdIsString(val.external_sync_identifier)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_sync_identifier" of type "GroupFull"',
            });
        }
        const externalSyncIdentifier = val.external_sync_identifier == void 0
            ? void 0
            : val.external_sync_identifier;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "GroupFull"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const invitabilityLevel = val.invitability_level == void 0
            ? void 0
            : deserializeGroupFullInvitabilityLevelField(val.invitability_level);
        const memberViewabilityLevel = val.member_viewability_level == void 0
            ? void 0
            : deserializeGroupFullMemberViewabilityLevelField(val.member_viewability_level);
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeGroupFullPermissionsField(val.permissions);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "GroupFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "GroupFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "GroupFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const groupType = val.group_type == void 0
            ? void 0
            : deserializeGroupMiniGroupTypeField(val.group_type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "GroupFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupFull"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "GroupFull" to be defined',
            });
        }
        const type = deserializeGroupBaseTypeField(val.type);
        return {
            provenance: provenance,
            externalSyncIdentifier: externalSyncIdentifier,
            description: description,
            invitabilityLevel: invitabilityLevel,
            memberViewabilityLevel: memberViewabilityLevel,
            permissions: permissions,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            name: name,
            groupType: groupType,
            id: id,
            type: type,
        };
    }

    function deserializeGroupsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupsOrderDirectionField",
        });
    }
    function deserializeGroupsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "GroupsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeGroupsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeGroups(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Groups"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Groups"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Groups"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Groups"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Groups"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeGroupsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Groups"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeGroupFull(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class CreateGroupOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateGroupHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateGroupByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateGroupByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteGroupByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteGroupByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateGroupHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateGroupByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteGroupByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GroupsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getGroups() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetGroupsHeaders({}), cancellationToken) {
                const headers = new GetGroupsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['filter_term']: toString(queryParams.filterTerm),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroups(response.data);
            });
        }
        createGroup(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateGroupOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups'), {
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateGroupRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupFull(response.data);
            });
        }
        getGroupById(groupId_1) {
            return __awaiter(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new GetGroupByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupFull(response.data);
            });
        }
        updateGroupById(groupId_1) {
            return __awaiter(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new UpdateGroupByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId)), {
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateGroupByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeGroupFull(response.data);
            });
        }
        deleteGroupById(groupId_1) {
            return __awaiter(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new DeleteGroupByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateGroupRequestBodyInvitabilityLevelField(val) {
        return val;
    }
    function serializeCreateGroupRequestBodyMemberViewabilityLevelField(val) {
        return val;
    }
    function serializeCreateGroupRequestBody(val) {
        return {
            ['name']: val.name,
            ['provenance']: val.provenance == void 0 ? void 0 : val.provenance,
            ['external_sync_identifier']: val.externalSyncIdentifier == void 0
                ? void 0
                : val.externalSyncIdentifier,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['invitability_level']: val.invitabilityLevel == void 0
                ? void 0
                : serializeCreateGroupRequestBodyInvitabilityLevelField(val.invitabilityLevel),
            ['member_viewability_level']: val.memberViewabilityLevel == void 0
                ? void 0
                : serializeCreateGroupRequestBodyMemberViewabilityLevelField(val.memberViewabilityLevel),
        };
    }
    function serializeUpdateGroupByIdRequestBodyInvitabilityLevelField(val) {
        return val;
    }
    function serializeUpdateGroupByIdRequestBodyMemberViewabilityLevelField(val) {
        return val;
    }
    function serializeUpdateGroupByIdRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['provenance']: val.provenance == void 0 ? void 0 : val.provenance,
            ['external_sync_identifier']: val.externalSyncIdentifier == void 0
                ? void 0
                : val.externalSyncIdentifier,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['invitability_level']: val.invitabilityLevel == void 0
                ? void 0
                : serializeUpdateGroupByIdRequestBodyInvitabilityLevelField(val.invitabilityLevel),
            ['member_viewability_level']: val.memberViewabilityLevel == void 0
                ? void 0
                : serializeUpdateGroupByIdRequestBodyMemberViewabilityLevelField(val.memberViewabilityLevel),
        };
    }

    function deserializeWebhookMiniTypeField(val) {
        if (val == 'webhook') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WebhookMiniTypeField" });
    }
    function deserializeWebhookMiniTargetTypeField(val) {
        if (val == 'file') {
            return val;
        }
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebhookMiniTargetTypeField",
        });
    }
    function deserializeWebhookMiniTargetField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebhookMiniTargetField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WebhookMiniTargetField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeWebhookMiniTargetTypeField(val.type);
        return { id: id, type: type };
    }
    function deserializeWebhookMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "WebhookMini"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WebhookMini"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWebhookMiniTypeField(val.type);
        const target = val.target == void 0
            ? void 0
            : deserializeWebhookMiniTargetField(val.target);
        return { id: id, type: type, target: target };
    }

    function deserializeWebhooks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Webhooks"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Webhooks"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Webhooks"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Webhooks"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Webhooks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeWebhookMini(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function deserializeWebhookTriggersField(val) {
        if (val == 'FILE.UPLOADED') {
            return val;
        }
        if (val == 'FILE.PREVIEWED') {
            return val;
        }
        if (val == 'FILE.DOWNLOADED') {
            return val;
        }
        if (val == 'FILE.TRASHED') {
            return val;
        }
        if (val == 'FILE.DELETED') {
            return val;
        }
        if (val == 'FILE.RESTORED') {
            return val;
        }
        if (val == 'FILE.COPIED') {
            return val;
        }
        if (val == 'FILE.MOVED') {
            return val;
        }
        if (val == 'FILE.LOCKED') {
            return val;
        }
        if (val == 'FILE.UNLOCKED') {
            return val;
        }
        if (val == 'FILE.RENAMED') {
            return val;
        }
        if (val == 'COMMENT.CREATED') {
            return val;
        }
        if (val == 'COMMENT.UPDATED') {
            return val;
        }
        if (val == 'COMMENT.DELETED') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT.CREATED') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT.UPDATED') {
            return val;
        }
        if (val == 'METADATA_INSTANCE.CREATED') {
            return val;
        }
        if (val == 'METADATA_INSTANCE.UPDATED') {
            return val;
        }
        if (val == 'METADATA_INSTANCE.DELETED') {
            return val;
        }
        if (val == 'FOLDER.CREATED') {
            return val;
        }
        if (val == 'FOLDER.RENAMED') {
            return val;
        }
        if (val == 'FOLDER.DOWNLOADED') {
            return val;
        }
        if (val == 'FOLDER.RESTORED') {
            return val;
        }
        if (val == 'FOLDER.DELETED') {
            return val;
        }
        if (val == 'FOLDER.COPIED') {
            return val;
        }
        if (val == 'FOLDER.MOVED') {
            return val;
        }
        if (val == 'FOLDER.TRASHED') {
            return val;
        }
        if (val == 'WEBHOOK.DELETED') {
            return val;
        }
        if (val == 'COLLABORATION.CREATED') {
            return val;
        }
        if (val == 'COLLABORATION.ACCEPTED') {
            return val;
        }
        if (val == 'COLLABORATION.REJECTED') {
            return val;
        }
        if (val == 'COLLABORATION.REMOVED') {
            return val;
        }
        if (val == 'COLLABORATION.UPDATED') {
            return val;
        }
        if (val == 'SHARED_LINK.DELETED') {
            return val;
        }
        if (val == 'SHARED_LINK.CREATED') {
            return val;
        }
        if (val == 'SHARED_LINK.UPDATED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.COMPLETED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.DECLINED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.EXPIRED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.SIGNER_EMAIL_BOUNCED') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WebhookTriggersField" });
    }
    function deserializeWebhook(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Webhook"' });
        }
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Webhook"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.address == void 0) && !sdIsString(val.address)) {
            throw new BoxSdkError({
                message: 'Expecting string for "address" of type "Webhook"',
            });
        }
        const address = val.address == void 0 ? void 0 : val.address;
        if (!(val.triggers == void 0) && !sdIsList(val.triggers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "triggers" of type "Webhook"',
            });
        }
        const triggers = val.triggers == void 0
            ? void 0
            : sdIsList(val.triggers)
                ? val.triggers.map(function (itm) {
                    return deserializeWebhookTriggersField(itm);
                })
                : [];
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Webhook"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWebhookMiniTypeField(val.type);
        const target = val.target == void 0
            ? void 0
            : deserializeWebhookMiniTargetField(val.target);
        return {
            createdBy: createdBy,
            createdAt: createdAt,
            address: address,
            triggers: triggers,
            id: id,
            type: type,
            target: target,
        };
    }

    class CreateWebhookOptionals {
        constructor(fields) {
            this.headers = new CreateWebhookHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetWebhookByIdOptionals {
        constructor(fields) {
            this.headers = new GetWebhookByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateWebhookByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateWebhookByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteWebhookByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteWebhookByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetWebhooksHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateWebhookHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetWebhookByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateWebhookByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteWebhookByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class WebhooksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getWebhooks() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetWebhooksHeaders({}), cancellationToken) {
                const headers = new GetWebhooksHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebhooks(response.data);
            });
        }
        createWebhook(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateWebhookOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateWebhookRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebhook(response.data);
            });
        }
        getWebhookById(webhookId_1) {
            return __awaiter(this, arguments, void 0, function* (webhookId, optionalsInput = {}) {
                const optionals = new GetWebhookByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks/', toString(webhookId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebhook(response.data);
            });
        }
        updateWebhookById(webhookId_1) {
            return __awaiter(this, arguments, void 0, function* (webhookId, optionalsInput = {}) {
                const optionals = new UpdateWebhookByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks/', toString(webhookId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateWebhookByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWebhook(response.data);
            });
        }
        deleteWebhookById(webhookId_1) {
            return __awaiter(this, arguments, void 0, function* (webhookId, optionalsInput = {}) {
                const optionals = new DeleteWebhookByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks/', toString(webhookId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateWebhookRequestBodyTargetTypeField(val) {
        return val;
    }
    function serializeCreateWebhookRequestBodyTargetField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializeCreateWebhookRequestBodyTargetTypeField(val.type),
        };
    }
    function serializeCreateWebhookRequestBodyTriggersField(val) {
        return val;
    }
    function serializeCreateWebhookRequestBody(val) {
        return {
            ['target']: serializeCreateWebhookRequestBodyTargetField(val.target),
            ['address']: val.address,
            ['triggers']: val.triggers.map(function (item) {
                return serializeCreateWebhookRequestBodyTriggersField(item);
            }),
        };
    }
    function serializeUpdateWebhookByIdRequestBodyTargetTypeField(val) {
        return val;
    }
    function serializeUpdateWebhookByIdRequestBodyTargetField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializeUpdateWebhookByIdRequestBodyTargetTypeField(val.type),
        };
    }
    function serializeUpdateWebhookByIdRequestBodyTriggersField(val) {
        return val;
    }
    function serializeUpdateWebhookByIdRequestBody(val) {
        return {
            ['target']: val.target == void 0
                ? void 0
                : serializeUpdateWebhookByIdRequestBodyTargetField(val.target),
            ['address']: val.address == void 0 ? void 0 : val.address,
            ['triggers']: val.triggers == void 0
                ? void 0
                : val.triggers.map(function (item) {
                    return serializeUpdateWebhookByIdRequestBodyTriggersField(item);
                }),
        };
    }

    function deserializeAppItemEventSourceTypeField(val) {
        if (val == 'app_item') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AppItemEventSourceTypeField",
        });
    }
    function deserializeAppItemEventSource(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemEventSource"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "AppItemEventSource" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AppItemEventSource"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AppItemEventSource" to be defined',
            });
        }
        const type = deserializeAppItemEventSourceTypeField(val.type);
        if (val.app_item_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "app_item_type" of type "AppItemEventSource" to be defined',
            });
        }
        if (!sdIsString(val.app_item_type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "app_item_type" of type "AppItemEventSource"',
            });
        }
        const appItemType = val.app_item_type;
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        const group = val.group == void 0 ? void 0 : deserializeGroupMini(val.group);
        return {
            id: id,
            type: type,
            appItemType: appItemType,
            user: user,
            group: group,
        };
    }

    function deserializeEventSourceItemTypeField(val) {
        if (val == 'file') {
            return val;
        }
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize EventSourceItemTypeField",
        });
    }
    function deserializeEventSourceClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "EventSourceClassificationField"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "EventSourceClassificationField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return { name: name };
    }
    function deserializeEventSource(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EventSource"' });
        }
        if (val.item_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_type" of type "EventSource" to be defined',
            });
        }
        const itemType = deserializeEventSourceItemTypeField(val.item_type);
        if (val.item_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_id" of type "EventSource" to be defined',
            });
        }
        if (!sdIsString(val.item_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "item_id" of type "EventSource"',
            });
        }
        const itemId = val.item_id;
        if (val.item_name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_name" of type "EventSource" to be defined',
            });
        }
        if (!sdIsString(val.item_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "item_name" of type "EventSource"',
            });
        }
        const itemName = val.item_name;
        const classification = val.classification == void 0
            ? void 0
            : deserializeEventSourceClassificationField(val.classification);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        return {
            itemType: itemType,
            itemId: itemId,
            itemName: itemName,
            classification: classification,
            parent: parent,
            ownedBy: ownedBy,
        };
    }

    function deserializeGenericSource(val) {
        return sdIsMap(val)
            ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                k,
                (function (v) {
                    return v;
                })(v),
            ]))
            : {};
    }

    function deserializeAppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser"',
            });
        }
        if (val.type == 'app_item') {
            return deserializeAppItemEventSource(val);
        }
        if (val.type == 'file') {
            return deserializeFile(val);
        }
        if (val.type == 'folder') {
            return deserializeFolder(val);
        }
        if (val.type == 'user') {
            return deserializeUser(val);
        }
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser"',
            });
        }
        if (val.item_type == 'file') {
            return deserializeEventSource(val);
        }
        if (val.item_type == 'folder') {
            return deserializeEventSource(val);
        }
        try {
            return deserializeGenericSource(val);
        }
        catch (error) {
        }
        finally {
        }
        throw new BoxSdkError({
            message: "Can't deserialize AppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser",
        });
    }

    function deserializeEventEventTypeField(val) {
        if (val == 'ACCESS_GRANTED') {
            return val;
        }
        if (val == 'ACCESS_REVOKED') {
            return val;
        }
        if (val == 'ADD_DEVICE_ASSOCIATION') {
            return val;
        }
        if (val == 'ADD_LOGIN_ACTIVITY_DEVICE') {
            return val;
        }
        if (val == 'ADMIN_LOGIN') {
            return val;
        }
        if (val == 'APPLICATION_CREATED') {
            return val;
        }
        if (val == 'APPLICATION_PUBLIC_KEY_ADDED') {
            return val;
        }
        if (val == 'APPLICATION_PUBLIC_KEY_DELETED') {
            return val;
        }
        if (val == 'CHANGE_ADMIN_ROLE') {
            return val;
        }
        if (val == 'CHANGE_FOLDER_PERMISSION') {
            return val;
        }
        if (val == 'COLLABORATION_ACCEPT') {
            return val;
        }
        if (val == 'COLLABORATION_EXPIRATION') {
            return val;
        }
        if (val == 'COLLABORATION_INVITE') {
            return val;
        }
        if (val == 'COLLABORATION_REMOVE') {
            return val;
        }
        if (val == 'COLLABORATION_ROLE_CHANGE') {
            return val;
        }
        if (val == 'COLLAB_ADD_COLLABORATOR') {
            return val;
        }
        if (val == 'COLLAB_INVITE_COLLABORATOR') {
            return val;
        }
        if (val == 'COLLAB_REMOVE_COLLABORATOR') {
            return val;
        }
        if (val == 'COLLAB_ROLE_CHANGE') {
            return val;
        }
        if (val == 'COMMENT_CREATE') {
            return val;
        }
        if (val == 'COMMENT_DELETE') {
            return val;
        }
        if (val == 'CONTENT_ACCESS') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_ABNORMAL_DOWNLOAD_ACTIVITY') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_AUTOMATION_ADD') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_AUTOMATION_DELETE') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_POLICY_ADD') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_SHARING_POLICY_VIOLATION') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_UPLOAD_POLICY_VIOLATION') {
            return val;
        }
        if (val == 'COPY') {
            return val;
        }
        if (val == 'DATA_RETENTION_CREATE_RETENTION') {
            return val;
        }
        if (val == 'DATA_RETENTION_REMOVE_RETENTION') {
            return val;
        }
        if (val == 'DELETE') {
            return val;
        }
        if (val == 'DELETE_USER') {
            return val;
        }
        if (val == 'DEVICE_TRUST_CHECK_FAILED') {
            return val;
        }
        if (val == 'DOWNLOAD') {
            return val;
        }
        if (val == 'EDIT') {
            return val;
        }
        if (val == 'EDIT_USER') {
            return val;
        }
        if (val == 'EMAIL_ALIAS_CONFIRM') {
            return val;
        }
        if (val == 'EMAIL_ALIAS_REMOVE') {
            return val;
        }
        if (val == 'ENABLE_TWO_FACTOR_AUTH') {
            return val;
        }
        if (val == 'ENTERPRISE_APP_AUTHORIZATION_UPDATE') {
            return val;
        }
        if (val == 'FAILED_LOGIN') {
            return val;
        }
        if (val == 'FILE_MARKED_MALICIOUS') {
            return val;
        }
        if (val == 'FILE_WATERMARKED_DOWNLOAD') {
            return val;
        }
        if (val == 'GROUP_ADD_ITEM') {
            return val;
        }
        if (val == 'GROUP_ADD_USER') {
            return val;
        }
        if (val == 'GROUP_CREATION') {
            return val;
        }
        if (val == 'GROUP_DELETION') {
            return val;
        }
        if (val == 'GROUP_EDITED') {
            return val;
        }
        if (val == 'GROUP_REMOVE_ITEM') {
            return val;
        }
        if (val == 'GROUP_REMOVE_USER') {
            return val;
        }
        if (val == 'ITEM_COPY') {
            return val;
        }
        if (val == 'ITEM_CREATE') {
            return val;
        }
        if (val == 'ITEM_DOWNLOAD') {
            return val;
        }
        if (val == 'ITEM_EMAIL_SEND') {
            return val;
        }
        if (val == 'ITEM_MAKE_CURRENT_VERSION') {
            return val;
        }
        if (val == 'ITEM_MODIFY') {
            return val;
        }
        if (val == 'ITEM_MOVE') {
            return val;
        }
        if (val == 'ITEM_OPEN') {
            return val;
        }
        if (val == 'ITEM_PREVIEW') {
            return val;
        }
        if (val == 'ITEM_RENAME') {
            return val;
        }
        if (val == 'ITEM_SHARED') {
            return val;
        }
        if (val == 'ITEM_SHARED_CREATE') {
            return val;
        }
        if (val == 'ITEM_SHARED_UNSHARE') {
            return val;
        }
        if (val == 'ITEM_SHARED_UPDATE') {
            return val;
        }
        if (val == 'ITEM_SYNC') {
            return val;
        }
        if (val == 'ITEM_TRASH') {
            return val;
        }
        if (val == 'ITEM_UNDELETE_VIA_TRASH') {
            return val;
        }
        if (val == 'ITEM_UNSYNC') {
            return val;
        }
        if (val == 'ITEM_UPLOAD') {
            return val;
        }
        if (val == 'LEGAL_HOLD_ASSIGNMENT_CREATE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_ASSIGNMENT_DELETE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_POLICY_CREATE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_POLICY_DELETE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_POLICY_UPDATE') {
            return val;
        }
        if (val == 'LOCK') {
            return val;
        }
        if (val == 'LOCK_CREATE') {
            return val;
        }
        if (val == 'LOCK_DESTROY') {
            return val;
        }
        if (val == 'LOGIN') {
            return val;
        }
        if (val == 'MASTER_INVITE_ACCEPT') {
            return val;
        }
        if (val == 'MASTER_INVITE_REJECT') {
            return val;
        }
        if (val == 'METADATA_INSTANCE_CREATE') {
            return val;
        }
        if (val == 'METADATA_INSTANCE_DELETE') {
            return val;
        }
        if (val == 'METADATA_INSTANCE_UPDATE') {
            return val;
        }
        if (val == 'METADATA_TEMPLATE_CREATE') {
            return val;
        }
        if (val == 'METADATA_TEMPLATE_DELETE') {
            return val;
        }
        if (val == 'METADATA_TEMPLATE_UPDATE') {
            return val;
        }
        if (val == 'MOVE') {
            return val;
        }
        if (val == 'NEW_USER') {
            return val;
        }
        if (val == 'PREVIEW') {
            return val;
        }
        if (val == 'REMOVE_DEVICE_ASSOCIATION') {
            return val;
        }
        if (val == 'REMOVE_LOGIN_ACTIVITY_DEVICE') {
            return val;
        }
        if (val == 'RENAME') {
            return val;
        }
        if (val == 'RETENTION_POLICY_ASSIGNMENT_ADD') {
            return val;
        }
        if (val == 'SHARE') {
            return val;
        }
        if (val == 'SHARED_LINK_SEND') {
            return val;
        }
        if (val == 'SHARE_EXPIRATION') {
            return val;
        }
        if (val == 'SHIELD_ALERT') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED_MISSING_JUSTIFICATION') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED_MISSING_JUSTIFICATION') {
            return val;
        }
        if (val == 'SHIELD_JUSTIFICATION_APPROVAL') {
            return val;
        }
        if (val == 'SHIELD_SHARED_LINK_ACCESS_BLOCKED') {
            return val;
        }
        if (val == 'SHIELD_SHARED_LINK_STATUS_RESTRICTED_ON_CREATE') {
            return val;
        }
        if (val == 'SHIELD_SHARED_LINK_STATUS_RESTRICTED_ON_UPDATE') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_ASSIGNED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_CANCELLED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_COMPLETED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_CONVERTED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_CREATED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_DECLINED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_EXPIRED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_SIGNED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_VIEWED_BY_SIGNED') {
            return val;
        }
        if (val == 'SIGNER_DOWNLOADED') {
            return val;
        }
        if (val == 'SIGNER_FORWARDED') {
            return val;
        }
        if (val == 'STORAGE_EXPIRATION') {
            return val;
        }
        if (val == 'TAG_ITEM_CREATE') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT_CREATE') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT_DELETE') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT_UPDATE') {
            return val;
        }
        if (val == 'TASK_CREATE') {
            return val;
        }
        if (val == 'TASK_UPDATE') {
            return val;
        }
        if (val == 'TERMS_OF_SERVICE_ACCEPT') {
            return val;
        }
        if (val == 'TERMS_OF_SERVICE_REJECT') {
            return val;
        }
        if (val == 'UNDELETE') {
            return val;
        }
        if (val == 'UNLOCK') {
            return val;
        }
        if (val == 'UNSHARE') {
            return val;
        }
        if (val == 'UPDATE_COLLABORATION_EXPIRATION') {
            return val;
        }
        if (val == 'UPDATE_SHARE_EXPIRATION') {
            return val;
        }
        if (val == 'UPLOAD') {
            return val;
        }
        if (val == 'USER_AUTHENTICATE_OAUTH2_ACCESS_TOKEN_CREATE') {
            return val;
        }
        if (val == 'WATERMARK_LABEL_CREATE') {
            return val;
        }
        if (val == 'WATERMARK_LABEL_DELETE') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize EventEventTypeField" });
    }
    function deserializeEventAdditionalDetailsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "EventAdditionalDetailsField"',
            });
        }
        return {};
    }
    function deserializeEvent(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Event"' });
        }
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "Event"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Event"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.recorded_at == void 0) && !sdIsString(val.recorded_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "recorded_at" of type "Event"',
            });
        }
        const recordedAt = val.recorded_at == void 0 ? void 0 : dateTimeFromString(val.recorded_at);
        if (!(val.event_id == void 0) && !sdIsString(val.event_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "event_id" of type "Event"',
            });
        }
        const eventId = val.event_id == void 0 ? void 0 : val.event_id;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const eventType = val.event_type == void 0
            ? void 0
            : deserializeEventEventTypeField(val.event_type);
        if (!(val.session_id == void 0) && !sdIsString(val.session_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "session_id" of type "Event"',
            });
        }
        const sessionId = val.session_id == void 0 ? void 0 : val.session_id;
        const source = val.source == void 0
            ? void 0
            : deserializeAppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser(val.source);
        const additionalDetails = val.additional_details == void 0
            ? void 0
            : deserializeEventAdditionalDetailsField(val.additional_details);
        return {
            type: type,
            createdAt: createdAt,
            recordedAt: recordedAt,
            eventId: eventId,
            createdBy: createdBy,
            eventType: eventType,
            sessionId: sessionId,
            source: source,
            additionalDetails: additionalDetails,
        };
    }

    function deserializeEventsNextStreamPositionField(val) {
        if (sdIsString(val)) {
            return val;
        }
        if (sdIsNumber(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize EventsNextStreamPositionField",
        });
    }
    function deserializeEvents(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Events"' });
        }
        if (!(val.chunk_size == void 0) && !sdIsNumber(val.chunk_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "chunk_size" of type "Events"',
            });
        }
        const chunkSize = val.chunk_size == void 0 ? void 0 : val.chunk_size;
        const nextStreamPosition = val.next_stream_position == void 0
            ? void 0
            : deserializeEventsNextStreamPositionField(val.next_stream_position);
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Events"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeEvent(itm);
                })
                : [];
        return {
            chunkSize: chunkSize,
            nextStreamPosition: nextStreamPosition,
            entries: entries,
        };
    }

    function deserializeRealtimeServer(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RealtimeServer"' });
        }
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "RealtimeServer"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "RealtimeServer"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.ttl == void 0) && !sdIsString(val.ttl)) {
            throw new BoxSdkError({
                message: 'Expecting string for "ttl" of type "RealtimeServer"',
            });
        }
        const ttl = val.ttl == void 0 ? void 0 : val.ttl;
        if (!(val.max_retries == void 0) && !sdIsString(val.max_retries)) {
            throw new BoxSdkError({
                message: 'Expecting string for "max_retries" of type "RealtimeServer"',
            });
        }
        const maxRetries = val.max_retries == void 0 ? void 0 : val.max_retries;
        if (!(val.retry_timeout == void 0) && !sdIsNumber(val.retry_timeout)) {
            throw new BoxSdkError({
                message: 'Expecting number for "retry_timeout" of type "RealtimeServer"',
            });
        }
        const retryTimeout = val.retry_timeout == void 0 ? void 0 : val.retry_timeout;
        return {
            type: type,
            url: url,
            ttl: ttl,
            maxRetries: maxRetries,
            retryTimeout: retryTimeout,
        };
    }

    function deserializeRealtimeServers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RealtimeServers"' });
        }
        if (!(val.chunk_size == void 0) && !sdIsNumber(val.chunk_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "chunk_size" of type "RealtimeServers"',
            });
        }
        const chunkSize = val.chunk_size == void 0 ? void 0 : val.chunk_size;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RealtimeServers"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRealtimeServer(itm);
                })
                : [];
        return { chunkSize: chunkSize, entries: entries };
    }

    class GetEventsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetEventsWithLongPollingHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class EventsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getEvents() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetEventsHeaders({}), cancellationToken) {
                const headers = new GetEventsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['stream_type']: toString(queryParams.streamType),
                    ['stream_position']: toString(queryParams.streamPosition),
                    ['limit']: toString(queryParams.limit),
                    ['event_type']: queryParams.eventType
                        ? queryParams.eventType.map(toString).join(',')
                        : undefined,
                    ['created_after']: queryParams.createdAfter
                        ? dateTimeToString(queryParams.createdAfter)
                        : undefined,
                    ['created_before']: queryParams.createdBefore
                        ? dateTimeToString(queryParams.createdBefore)
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/events'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeEvents(response.data);
            });
        }
        getEventsWithLongPolling() {
            return __awaiter(this, arguments, void 0, function* (headersInput = new GetEventsWithLongPollingHeaders({}), cancellationToken) {
                const headers = new GetEventsWithLongPollingHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/events'), {
                    method: 'OPTIONS',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRealtimeServers(response.data);
            });
        }
    }

    function deserializeCollectionTypeField(val) {
        if (val == 'collection') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize CollectionTypeField" });
    }
    function deserializeCollectionNameField(val) {
        if (val == 'Favorites') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize CollectionNameField" });
    }
    function deserializeCollectionCollectionTypeField(val) {
        if (val == 'favorites') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollectionCollectionTypeField",
        });
    }
    function deserializeCollection(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collection"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Collection"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeCollectionTypeField(val.type);
        const name = val.name == void 0 ? void 0 : deserializeCollectionNameField(val.name);
        const collectionType = val.collection_type == void 0
            ? void 0
            : deserializeCollectionCollectionTypeField(val.collection_type);
        return {
            id: id,
            type: type,
            name: name,
            collectionType: collectionType,
        };
    }

    function deserializeCollectionsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollectionsOrderDirectionField",
        });
    }
    function deserializeCollectionsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollectionsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "CollectionsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeCollectionsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeCollections(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collections"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Collections"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Collections"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Collections"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Collections"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeCollectionsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Collections"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollection(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetCollectionItemsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetCollectionItemsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollectionsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollectionItemsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CollectionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getCollections() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetCollectionsHeaders({}), cancellationToken) {
                const headers = new GetCollectionsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collections'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollections(response.data);
            });
        }
        getCollectionItems(collectionId_1) {
            return __awaiter(this, arguments, void 0, function* (collectionId, optionalsInput = {}) {
                const optionals = new GetCollectionItemsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collections/', toString(collectionId), '/items'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeItems(response.data);
            });
        }
    }

    function deserializeRecentItemInteractionTypeField(val) {
        if (val == 'item_preview') {
            return val;
        }
        if (val == 'item_upload') {
            return val;
        }
        if (val == 'item_comment') {
            return val;
        }
        if (val == 'item_open') {
            return val;
        }
        if (val == 'item_modify') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RecentItemInteractionTypeField",
        });
    }
    function deserializeRecentItem(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RecentItem"' });
        }
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "RecentItem"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        const item = val.item == void 0
            ? void 0
            : deserializeFileFullOrFolderFullOrWebLink(val.item);
        const interactionType = val.interaction_type == void 0
            ? void 0
            : deserializeRecentItemInteractionTypeField(val.interaction_type);
        if (!(val.interacted_at == void 0) && !sdIsString(val.interacted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "interacted_at" of type "RecentItem"',
            });
        }
        const interactedAt = val.interacted_at == void 0
            ? void 0
            : dateTimeFromString(val.interacted_at);
        if (!(val.interaction_shared_link == void 0) &&
            !sdIsString(val.interaction_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "interaction_shared_link" of type "RecentItem"',
            });
        }
        const interactionSharedLink = val.interaction_shared_link == void 0
            ? void 0
            : val.interaction_shared_link;
        return {
            type: type,
            item: item,
            interactionType: interactionType,
            interactedAt: interactedAt,
            interactionSharedLink: interactionSharedLink,
        };
    }

    function deserializeRecentItems(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RecentItems"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "RecentItems"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "RecentItems"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "RecentItems"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RecentItems"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRecentItem(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetRecentItemsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RecentItemsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getRecentItems() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetRecentItemsHeaders({}), cancellationToken) {
                const headers = new GetRecentItemsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/recent_items'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRecentItems(response.data);
            });
        }
    }

    function deserializeRetentionPolicyBaseTypeField(val) {
        if (val == 'retention_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyBaseTypeField",
        });
    }

    function deserializeRetentionPolicyMiniDispositionActionField(val) {
        if (val == 'permanently_delete') {
            return val;
        }
        if (val == 'remove_retention') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyMiniDispositionActionField",
        });
    }
    function deserializeRetentionPolicyMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyMini"',
            });
        }
        if (!(val.policy_name == void 0) && !sdIsString(val.policy_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "policy_name" of type "RetentionPolicyMini"',
            });
        }
        const policyName = val.policy_name == void 0 ? void 0 : val.policy_name;
        if (!(val.retention_length == void 0) && !sdIsString(val.retention_length)) {
            throw new BoxSdkError({
                message: 'Expecting string for "retention_length" of type "RetentionPolicyMini"',
            });
        }
        const retentionLength = val.retention_length == void 0 ? void 0 : val.retention_length;
        const dispositionAction = val.disposition_action == void 0
            ? void 0
            : deserializeRetentionPolicyMiniDispositionActionField(val.disposition_action);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "RetentionPolicyMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicyMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "RetentionPolicyMini" to be defined',
            });
        }
        const type = deserializeRetentionPolicyBaseTypeField(val.type);
        return {
            policyName: policyName,
            retentionLength: retentionLength,
            dispositionAction: dispositionAction,
            id: id,
            type: type,
        };
    }

    function deserializeRetentionPolicyPolicyTypeField(val) {
        if (val == 'finite') {
            return val;
        }
        if (val == 'indefinite') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyPolicyTypeField",
        });
    }
    function deserializeRetentionPolicyRetentionTypeField(val) {
        if (val == 'modifiable') {
            return val;
        }
        if (val == 'non_modifiable') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyRetentionTypeField",
        });
    }
    function deserializeRetentionPolicyStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'retired') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyStatusField",
        });
    }
    function deserializeRetentionPolicyAssignmentCountsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignmentCountsField"',
            });
        }
        if (!(val.enterprise == void 0) && !sdIsNumber(val.enterprise)) {
            throw new BoxSdkError({
                message: 'Expecting number for "enterprise" of type "RetentionPolicyAssignmentCountsField"',
            });
        }
        const enterprise = val.enterprise == void 0 ? void 0 : val.enterprise;
        if (!(val.folder == void 0) && !sdIsNumber(val.folder)) {
            throw new BoxSdkError({
                message: 'Expecting number for "folder" of type "RetentionPolicyAssignmentCountsField"',
            });
        }
        const folder = val.folder == void 0 ? void 0 : val.folder;
        if (!(val.metadata_template == void 0) &&
            !sdIsNumber(val.metadata_template)) {
            throw new BoxSdkError({
                message: 'Expecting number for "metadata_template" of type "RetentionPolicyAssignmentCountsField"',
            });
        }
        const metadataTemplate = val.metadata_template == void 0 ? void 0 : val.metadata_template;
        return {
            enterprise: enterprise,
            folder: folder,
            metadataTemplate: metadataTemplate,
        };
    }
    function deserializeRetentionPolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RetentionPolicy"' });
        }
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "RetentionPolicy"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const policyType = val.policy_type == void 0
            ? void 0
            : deserializeRetentionPolicyPolicyTypeField(val.policy_type);
        const retentionType = val.retention_type == void 0
            ? void 0
            : deserializeRetentionPolicyRetentionTypeField(val.retention_type);
        const status = val.status == void 0
            ? void 0
            : deserializeRetentionPolicyStatusField(val.status);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "RetentionPolicy"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "RetentionPolicy"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.can_owner_extend_retention == void 0) &&
            !sdIsBoolean(val.can_owner_extend_retention)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_owner_extend_retention" of type "RetentionPolicy"',
            });
        }
        const canOwnerExtendRetention = val.can_owner_extend_retention == void 0
            ? void 0
            : val.can_owner_extend_retention;
        if (!(val.are_owners_notified == void 0) &&
            !sdIsBoolean(val.are_owners_notified)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_owners_notified" of type "RetentionPolicy"',
            });
        }
        const areOwnersNotified = val.are_owners_notified == void 0 ? void 0 : val.are_owners_notified;
        if (!(val.custom_notification_recipients == void 0) &&
            !sdIsList(val.custom_notification_recipients)) {
            throw new BoxSdkError({
                message: 'Expecting array for "custom_notification_recipients" of type "RetentionPolicy"',
            });
        }
        const customNotificationRecipients = val.custom_notification_recipients == void 0
            ? void 0
            : sdIsList(val.custom_notification_recipients)
                ? val.custom_notification_recipients.map(function (itm) {
                    return deserializeUserMini(itm);
                })
                : [];
        const assignmentCounts = val.assignment_counts == void 0
            ? void 0
            : deserializeRetentionPolicyAssignmentCountsField(val.assignment_counts);
        if (!(val.policy_name == void 0) && !sdIsString(val.policy_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "policy_name" of type "RetentionPolicy"',
            });
        }
        const policyName = val.policy_name == void 0 ? void 0 : val.policy_name;
        if (!(val.retention_length == void 0) && !sdIsString(val.retention_length)) {
            throw new BoxSdkError({
                message: 'Expecting string for "retention_length" of type "RetentionPolicy"',
            });
        }
        const retentionLength = val.retention_length == void 0 ? void 0 : val.retention_length;
        const dispositionAction = val.disposition_action == void 0
            ? void 0
            : deserializeRetentionPolicyMiniDispositionActionField(val.disposition_action);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "RetentionPolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "RetentionPolicy" to be defined',
            });
        }
        const type = deserializeRetentionPolicyBaseTypeField(val.type);
        return {
            description: description,
            policyType: policyType,
            retentionType: retentionType,
            status: status,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            canOwnerExtendRetention: canOwnerExtendRetention,
            areOwnersNotified: areOwnersNotified,
            customNotificationRecipients: customNotificationRecipients,
            assignmentCounts: assignmentCounts,
            policyName: policyName,
            retentionLength: retentionLength,
            dispositionAction: dispositionAction,
            id: id,
            type: type,
        };
    }

    function deserializeRetentionPolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicies"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RetentionPolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRetentionPolicy(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "RetentionPolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "RetentionPolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    class CreateRetentionPolicyOptionals {
        constructor(fields) {
            this.headers = new CreateRetentionPolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPolicyByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetRetentionPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateRetentionPolicyByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateRetentionPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteRetentionPolicyByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteRetentionPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPoliciesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateRetentionPolicyHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetRetentionPolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateRetentionPolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteRetentionPolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RetentionPoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getRetentionPolicies() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetRetentionPoliciesHeaders({}), cancellationToken) {
                const headers = new GetRetentionPoliciesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['policy_name']: toString(queryParams.policyName),
                    ['policy_type']: toString(queryParams.policyType),
                    ['created_by_user_id']: toString(queryParams.createdByUserId),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRetentionPolicies(response.data);
            });
        }
        createRetentionPolicy(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateRetentionPolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateRetentionPolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRetentionPolicy(response.data);
            });
        }
        getRetentionPolicyById(retentionPolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new GetRetentionPolicyByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRetentionPolicy(response.data);
            });
        }
        updateRetentionPolicyById(retentionPolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new UpdateRetentionPolicyByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateRetentionPolicyByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRetentionPolicy(response.data);
            });
        }
        deleteRetentionPolicyById(retentionPolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new DeleteRetentionPolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateRetentionPolicyRequestBodyPolicyTypeField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyRequestBodyDispositionActionField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyRequestBodyRetentionTypeField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyRequestBody(val) {
        return {
            ['policy_name']: val.policyName,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['policy_type']: serializeCreateRetentionPolicyRequestBodyPolicyTypeField(val.policyType),
            ['disposition_action']: serializeCreateRetentionPolicyRequestBodyDispositionActionField(val.dispositionAction),
            ['retention_length']: val.retentionLength == void 0 ? void 0 : val.retentionLength,
            ['retention_type']: val.retentionType == void 0
                ? void 0
                : serializeCreateRetentionPolicyRequestBodyRetentionTypeField(val.retentionType),
            ['can_owner_extend_retention']: val.canOwnerExtendRetention == void 0
                ? void 0
                : val.canOwnerExtendRetention,
            ['are_owners_notified']: val.areOwnersNotified == void 0 ? void 0 : val.areOwnersNotified,
            ['custom_notification_recipients']: val.customNotificationRecipients == void 0
                ? void 0
                : val.customNotificationRecipients.map(function (item) {
                    return serializeUserMini(item);
                }),
        };
    }
    function serializeUpdateRetentionPolicyByIdRequestBody(val) {
        return {
            ['policy_name']: val.policyName == void 0 ? void 0 : val.policyName,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['disposition_action']: val.dispositionAction == void 0 ? void 0 : val.dispositionAction,
            ['retention_type']: val.retentionType == void 0 ? void 0 : val.retentionType,
            ['retention_length']: val.retentionLength == void 0 ? void 0 : val.retentionLength,
            ['status']: val.status == void 0 ? void 0 : val.status,
            ['can_owner_extend_retention']: val.canOwnerExtendRetention == void 0
                ? void 0
                : val.canOwnerExtendRetention,
            ['are_owners_notified']: val.areOwnersNotified == void 0 ? void 0 : val.areOwnersNotified,
            ['custom_notification_recipients']: val.customNotificationRecipients == void 0
                ? void 0
                : val.customNotificationRecipients.map(function (item) {
                    return serializeUserBase(item);
                }),
        };
    }

    function deserializeRetentionPolicyAssignmentTypeField(val) {
        if (val == 'retention_policy_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyAssignmentTypeField",
        });
    }
    function deserializeRetentionPolicyAssignmentAssignedToTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        if (val == 'enterprise') {
            return val;
        }
        if (val == 'metadata_template') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyAssignmentAssignedToTypeField",
        });
    }
    function deserializeRetentionPolicyAssignmentAssignedToField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignmentAssignedToField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicyAssignmentAssignedToField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeRetentionPolicyAssignmentAssignedToTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }
    function deserializeRetentionPolicyAssignmentFilterFieldsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignmentFilterFieldsField"',
            });
        }
        if (!(val.field == void 0) && !sdIsString(val.field)) {
            throw new BoxSdkError({
                message: 'Expecting string for "field" of type "RetentionPolicyAssignmentFilterFieldsField"',
            });
        }
        const field = val.field == void 0 ? void 0 : val.field;
        if (!(val.value == void 0) && !sdIsString(val.value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "value" of type "RetentionPolicyAssignmentFilterFieldsField"',
            });
        }
        const value = val.value == void 0 ? void 0 : val.value;
        return {
            field: field,
            value: value,
        };
    }
    function deserializeRetentionPolicyAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignment"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "RetentionPolicyAssignment" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicyAssignment"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "RetentionPolicyAssignment" to be defined',
            });
        }
        const type = deserializeRetentionPolicyAssignmentTypeField(val.type);
        const retentionPolicy = val.retention_policy == void 0
            ? void 0
            : deserializeRetentionPolicyMini(val.retention_policy);
        const assignedTo = val.assigned_to == void 0
            ? void 0
            : deserializeRetentionPolicyAssignmentAssignedToField(val.assigned_to);
        if (!(val.filter_fields == void 0) && !sdIsList(val.filter_fields)) {
            throw new BoxSdkError({
                message: 'Expecting array for "filter_fields" of type "RetentionPolicyAssignment"',
            });
        }
        const filterFields = val.filter_fields == void 0
            ? void 0
            : sdIsList(val.filter_fields)
                ? val.filter_fields.map(function (itm) {
                    return deserializeRetentionPolicyAssignmentFilterFieldsField(itm);
                })
                : [];
        const assignedBy = val.assigned_by == void 0 ? void 0 : deserializeUserMini(val.assigned_by);
        if (!(val.assigned_at == void 0) && !sdIsString(val.assigned_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "assigned_at" of type "RetentionPolicyAssignment"',
            });
        }
        const assignedAt = val.assigned_at == void 0 ? void 0 : dateTimeFromString(val.assigned_at);
        if (!(val.start_date_field == void 0) && !sdIsString(val.start_date_field)) {
            throw new BoxSdkError({
                message: 'Expecting string for "start_date_field" of type "RetentionPolicyAssignment"',
            });
        }
        const startDateField = val.start_date_field == void 0 ? void 0 : val.start_date_field;
        return {
            id: id,
            type: type,
            retentionPolicy: retentionPolicy,
            assignedTo: assignedTo,
            filterFields: filterFields,
            assignedBy: assignedBy,
            assignedAt: assignedAt,
            startDateField: startDateField,
        };
    }

    function deserializeRetentionPolicyAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignments"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RetentionPolicyAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRetentionPolicyAssignment(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "RetentionPolicyAssignments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "RetentionPolicyAssignments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    function deserializeFilesUnderRetention(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FilesUnderRetention"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FilesUnderRetention"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FilesUnderRetention"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FilesUnderRetention"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FilesUnderRetention"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetRetentionPolicyAssignmentsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetRetentionPolicyAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateRetentionPolicyAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateRetentionPolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetRetentionPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteRetentionPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteRetentionPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFilesUnderRetentionPolicyAssignmentOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFilesUnderRetentionPolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPolicyAssignmentsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateRetentionPolicyAssignmentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetRetentionPolicyAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteRetentionPolicyAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFilesUnderRetentionPolicyAssignmentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RetentionPolicyAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getRetentionPolicyAssignments(retentionPolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new GetRetentionPolicyAssignmentsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['type']: toString(queryParams.type),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId), '/assignments'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRetentionPolicyAssignments(response.data);
            });
        }
        createRetentionPolicyAssignment(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateRetentionPolicyAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateRetentionPolicyAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRetentionPolicyAssignment(response.data);
            });
        }
        getRetentionPolicyAssignmentById(retentionPolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (retentionPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetRetentionPolicyAssignmentByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments/', toString(retentionPolicyAssignmentId)), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeRetentionPolicyAssignment(response.data);
            });
        }
        deleteRetentionPolicyAssignmentById(retentionPolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (retentionPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteRetentionPolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments/', toString(retentionPolicyAssignmentId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getFilesUnderRetentionPolicyAssignment(retentionPolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (retentionPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetFilesUnderRetentionPolicyAssignmentOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments/', toString(retentionPolicyAssignmentId), '/files_under_retention'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFilesUnderRetention(response.data);
            });
        }
    }
    function serializeCreateRetentionPolicyAssignmentRequestBodyAssignToTypeField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyAssignmentRequestBodyAssignToField(val) {
        return {
            ['type']: serializeCreateRetentionPolicyAssignmentRequestBodyAssignToTypeField(val.type),
            ['id']: val.id == void 0 ? void 0 : val.id,
        };
    }
    function serializeCreateRetentionPolicyAssignmentRequestBodyFilterFieldsField(val) {
        return {
            ['field']: val.field == void 0 ? void 0 : val.field,
            ['value']: val.value == void 0 ? void 0 : val.value,
        };
    }
    function serializeCreateRetentionPolicyAssignmentRequestBody(val) {
        return {
            ['policy_id']: val.policyId,
            ['assign_to']: serializeCreateRetentionPolicyAssignmentRequestBodyAssignToField(val.assignTo),
            ['filter_fields']: val.filterFields == void 0
                ? void 0
                : val.filterFields.map(function (item) {
                    return serializeCreateRetentionPolicyAssignmentRequestBodyFilterFieldsField(item);
                }),
            ['start_date_field']: val.startDateField == void 0 ? void 0 : val.startDateField,
        };
    }

    function deserializeLegalHoldPolicyMiniTypeField(val) {
        if (val == 'legal_hold_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize LegalHoldPolicyMiniTypeField",
        });
    }
    function deserializeLegalHoldPolicyMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyMini"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "LegalHoldPolicyMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "LegalHoldPolicyMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "LegalHoldPolicyMini" to be defined',
            });
        }
        const type = deserializeLegalHoldPolicyMiniTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeLegalHoldPolicyStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'applying') {
            return val;
        }
        if (val == 'releasing') {
            return val;
        }
        if (val == 'released') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize LegalHoldPolicyStatusField",
        });
    }
    function deserializeLegalHoldPolicyAssignmentCountsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        if (!(val.user == void 0) && !sdIsNumber(val.user)) {
            throw new BoxSdkError({
                message: 'Expecting number for "user" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const user = val.user == void 0 ? void 0 : val.user;
        if (!(val.folder == void 0) && !sdIsNumber(val.folder)) {
            throw new BoxSdkError({
                message: 'Expecting number for "folder" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const folder = val.folder == void 0 ? void 0 : val.folder;
        if (!(val.file == void 0) && !sdIsNumber(val.file)) {
            throw new BoxSdkError({
                message: 'Expecting number for "file" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const file = val.file == void 0 ? void 0 : val.file;
        if (!(val.file_version == void 0) && !sdIsNumber(val.file_version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "file_version" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const fileVersion = val.file_version == void 0 ? void 0 : val.file_version;
        return {
            user: user,
            folder: folder,
            file: file,
            fileVersion: fileVersion,
        };
    }
    function deserializeLegalHoldPolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "LegalHoldPolicy"' });
        }
        if (!(val.policy_name == void 0) && !sdIsString(val.policy_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "policy_name" of type "LegalHoldPolicy"',
            });
        }
        const policyName = val.policy_name == void 0 ? void 0 : val.policy_name;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "LegalHoldPolicy"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const status = val.status == void 0
            ? void 0
            : deserializeLegalHoldPolicyStatusField(val.status);
        const assignmentCounts = val.assignment_counts == void 0
            ? void 0
            : deserializeLegalHoldPolicyAssignmentCountsField(val.assignment_counts);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "LegalHoldPolicy"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "LegalHoldPolicy"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.deleted_at == void 0) && !sdIsString(val.deleted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "deleted_at" of type "LegalHoldPolicy"',
            });
        }
        const deletedAt = val.deleted_at == void 0 ? void 0 : dateTimeFromString(val.deleted_at);
        if (!(val.filter_started_at == void 0) &&
            !sdIsString(val.filter_started_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "filter_started_at" of type "LegalHoldPolicy"',
            });
        }
        const filterStartedAt = val.filter_started_at == void 0
            ? void 0
            : dateTimeFromString(val.filter_started_at);
        if (!(val.filter_ended_at == void 0) && !sdIsString(val.filter_ended_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "filter_ended_at" of type "LegalHoldPolicy"',
            });
        }
        const filterEndedAt = val.filter_ended_at == void 0
            ? void 0
            : dateTimeFromString(val.filter_ended_at);
        if (!(val.release_notes == void 0) && !sdIsString(val.release_notes)) {
            throw new BoxSdkError({
                message: 'Expecting string for "release_notes" of type "LegalHoldPolicy"',
            });
        }
        const releaseNotes = val.release_notes == void 0 ? void 0 : val.release_notes;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "LegalHoldPolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "LegalHoldPolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "LegalHoldPolicy" to be defined',
            });
        }
        const type = deserializeLegalHoldPolicyMiniTypeField(val.type);
        return {
            policyName: policyName,
            description: description,
            status: status,
            assignmentCounts: assignmentCounts,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
            filterStartedAt: filterStartedAt,
            filterEndedAt: filterEndedAt,
            releaseNotes: releaseNotes,
            id: id,
            type: type,
        };
    }

    function deserializeLegalHoldPolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicies"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "LegalHoldPolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "LegalHoldPolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "LegalHoldPolicies"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "LegalHoldPolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeLegalHoldPolicy(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class CreateLegalHoldPolicyOptionals {
        constructor(fields) {
            this.headers = new CreateLegalHoldPolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyByIdOptionals {
        constructor(fields) {
            this.headers = new GetLegalHoldPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateLegalHoldPolicyByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateLegalHoldPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteLegalHoldPolicyByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteLegalHoldPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPoliciesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateLegalHoldPolicyHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetLegalHoldPolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateLegalHoldPolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteLegalHoldPolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class LegalHoldPoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getLegalHoldPolicies() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetLegalHoldPoliciesHeaders({}), cancellationToken) {
                const headers = new GetLegalHoldPoliciesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['policy_name']: toString(queryParams.policyName),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeLegalHoldPolicies(response.data);
            });
        }
        createLegalHoldPolicy(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateLegalHoldPolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateLegalHoldPolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeLegalHoldPolicy(response.data);
            });
        }
        getLegalHoldPolicyById(legalHoldPolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (legalHoldPolicyId, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies/', toString(legalHoldPolicyId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeLegalHoldPolicy(response.data);
            });
        }
        updateLegalHoldPolicyById(legalHoldPolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (legalHoldPolicyId, optionalsInput = {}) {
                const optionals = new UpdateLegalHoldPolicyByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies/', toString(legalHoldPolicyId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateLegalHoldPolicyByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeLegalHoldPolicy(response.data);
            });
        }
        deleteLegalHoldPolicyById(legalHoldPolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (legalHoldPolicyId, optionalsInput = {}) {
                const optionals = new DeleteLegalHoldPolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies/', toString(legalHoldPolicyId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateLegalHoldPolicyRequestBody(val) {
        return {
            ['policy_name']: val.policyName,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['filter_started_at']: val.filterStartedAt == void 0
                ? void 0
                : dateTimeToString(val.filterStartedAt),
            ['filter_ended_at']: val.filterEndedAt == void 0
                ? void 0
                : dateTimeToString(val.filterEndedAt),
            ['is_ongoing']: val.isOngoing == void 0 ? void 0 : val.isOngoing,
        };
    }
    function serializeUpdateLegalHoldPolicyByIdRequestBody(val) {
        return {
            ['policy_name']: val.policyName == void 0 ? void 0 : val.policyName,
            ['description']: val.description == void 0 ? void 0 : val.description,
            ['release_notes']: val.releaseNotes == void 0 ? void 0 : val.releaseNotes,
        };
    }

    function deserializeLegalHoldPolicyAssignmentBaseTypeField(val) {
        if (val == 'legal_hold_policy_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize LegalHoldPolicyAssignmentBaseTypeField",
        });
    }

    function deserializeLegalHoldPolicyAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyAssignment"',
            });
        }
        const legalHoldPolicy = val.legal_hold_policy == void 0
            ? void 0
            : deserializeLegalHoldPolicyMini(val.legal_hold_policy);
        const assignedTo = val.assigned_to == void 0
            ? void 0
            : deserializeFileOrFolderOrWebLink(val.assigned_to);
        const assignedBy = val.assigned_by == void 0 ? void 0 : deserializeUserMini(val.assigned_by);
        if (!(val.assigned_at == void 0) && !sdIsString(val.assigned_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "assigned_at" of type "LegalHoldPolicyAssignment"',
            });
        }
        const assignedAt = val.assigned_at == void 0 ? void 0 : dateTimeFromString(val.assigned_at);
        if (!(val.deleted_at == void 0) && !sdIsString(val.deleted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "deleted_at" of type "LegalHoldPolicyAssignment"',
            });
        }
        const deletedAt = val.deleted_at == void 0 ? void 0 : dateTimeFromString(val.deleted_at);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "LegalHoldPolicyAssignment"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeLegalHoldPolicyAssignmentBaseTypeField(val.type);
        return {
            legalHoldPolicy: legalHoldPolicy,
            assignedTo: assignedTo,
            assignedBy: assignedBy,
            assignedAt: assignedAt,
            deletedAt: deletedAt,
            id: id,
            type: type,
        };
    }

    function deserializeLegalHoldPolicyAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyAssignments"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "LegalHoldPolicyAssignments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "LegalHoldPolicyAssignments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "LegalHoldPolicyAssignments"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "LegalHoldPolicyAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeLegalHoldPolicyAssignment(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function deserializeFilesOnHold(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FilesOnHold"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FilesOnHold"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FilesOnHold"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FilesOnHold"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FilesOnHold"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetLegalHoldPolicyAssignmentsOptionals {
        constructor(fields) {
            this.headers = new GetLegalHoldPolicyAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateLegalHoldPolicyAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateLegalHoldPolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetLegalHoldPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteLegalHoldPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteLegalHoldPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentFileOnHoldOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetLegalHoldPolicyAssignmentFileOnHoldHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateLegalHoldPolicyAssignmentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteLegalHoldPolicyAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentFileOnHoldHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class LegalHoldPolicyAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getLegalHoldPolicyAssignments(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyAssignmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['policy_id']: toString(queryParams.policyId),
                    ['assign_to_type']: toString(queryParams.assignToType),
                    ['assign_to_id']: toString(queryParams.assignToId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeLegalHoldPolicyAssignments(response.data);
            });
        }
        createLegalHoldPolicyAssignment(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateLegalHoldPolicyAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateLegalHoldPolicyAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeLegalHoldPolicyAssignment(response.data);
            });
        }
        getLegalHoldPolicyAssignmentById(legalHoldPolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (legalHoldPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments/', toString(legalHoldPolicyAssignmentId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeLegalHoldPolicyAssignment(response.data);
            });
        }
        deleteLegalHoldPolicyAssignmentById(legalHoldPolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (legalHoldPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteLegalHoldPolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments/', toString(legalHoldPolicyAssignmentId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getLegalHoldPolicyAssignmentFileOnHold(legalHoldPolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (legalHoldPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyAssignmentFileOnHoldOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments/', toString(legalHoldPolicyAssignmentId), '/files_on_hold'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFilesOnHold(response.data);
            });
        }
    }
    function serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToTypeField(val) {
        return val;
    }
    function serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToField(val) {
        return {
            ['type']: serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateLegalHoldPolicyAssignmentRequestBody(val) {
        return {
            ['policy_id']: val.policyId,
            ['assign_to']: serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToField(val.assignTo),
        };
    }

    function deserializeFileVersionRetentionTypeField(val) {
        if (val == 'file_version_retention') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionRetentionTypeField",
        });
    }
    function deserializeFileVersionRetention(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionRetention"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionRetention"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeFileVersionRetentionTypeField(val.type);
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        const file = val.file == void 0 ? void 0 : deserializeFileMini(val.file);
        if (!(val.applied_at == void 0) && !sdIsString(val.applied_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "applied_at" of type "FileVersionRetention"',
            });
        }
        const appliedAt = val.applied_at == void 0 ? void 0 : dateTimeFromString(val.applied_at);
        if (!(val.disposition_at == void 0) && !sdIsString(val.disposition_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "disposition_at" of type "FileVersionRetention"',
            });
        }
        const dispositionAt = val.disposition_at == void 0
            ? void 0
            : dateTimeFromString(val.disposition_at);
        const winningRetentionPolicy = val.winning_retention_policy == void 0
            ? void 0
            : deserializeRetentionPolicyMini(val.winning_retention_policy);
        return {
            id: id,
            type: type,
            fileVersion: fileVersion,
            file: file,
            appliedAt: appliedAt,
            dispositionAt: dispositionAt,
            winningRetentionPolicy: winningRetentionPolicy,
        };
    }

    function deserializeFileVersionRetentions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionRetentions"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FileVersionRetentions"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FileVersionRetentions"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FileVersionRetentions"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileVersionRetentions"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileVersionRetention(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetFileVersionRetentionByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileVersionRetentionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionRetentionsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileVersionRetentionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileVersionRetentionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileVersionRetentions() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetFileVersionRetentionsHeaders({}), cancellationToken) {
                const headers = new GetFileVersionRetentionsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['file_id']: toString(queryParams.fileId),
                    ['file_version_id']: toString(queryParams.fileVersionId),
                    ['policy_id']: toString(queryParams.policyId),
                    ['disposition_action']: toString(queryParams.dispositionAction),
                    ['disposition_before']: toString(queryParams.dispositionBefore),
                    ['disposition_after']: toString(queryParams.dispositionAfter),
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_retentions'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersionRetentions(response.data);
            });
        }
        getFileVersionRetentionById(fileVersionRetentionId_1) {
            return __awaiter(this, arguments, void 0, function* (fileVersionRetentionId, optionalsInput = {}) {
                const optionals = new GetFileVersionRetentionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_retentions/', toString(fileVersionRetentionId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersionRetention(response.data);
            });
        }
    }

    function deserializeFileVersionLegalHoldTypeField(val) {
        if (val == 'file_version_legal_hold') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionLegalHoldTypeField",
        });
    }
    function deserializeFileVersionLegalHold(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionLegalHold"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionLegalHold"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeFileVersionLegalHoldTypeField(val.type);
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        const file = val.file == void 0 ? void 0 : deserializeFileMini(val.file);
        if (!(val.legal_hold_policy_assignments == void 0) &&
            !sdIsList(val.legal_hold_policy_assignments)) {
            throw new BoxSdkError({
                message: 'Expecting array for "legal_hold_policy_assignments" of type "FileVersionLegalHold"',
            });
        }
        const legalHoldPolicyAssignments = val.legal_hold_policy_assignments == void 0
            ? void 0
            : sdIsList(val.legal_hold_policy_assignments)
                ? val.legal_hold_policy_assignments.map(function (itm) {
                    return deserializeLegalHoldPolicyAssignment(itm);
                })
                : [];
        if (!(val.deleted_at == void 0) && !sdIsString(val.deleted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "deleted_at" of type "FileVersionLegalHold"',
            });
        }
        const deletedAt = val.deleted_at == void 0 ? void 0 : dateTimeFromString(val.deleted_at);
        return {
            id: id,
            type: type,
            fileVersion: fileVersion,
            file: file,
            legalHoldPolicyAssignments: legalHoldPolicyAssignments,
            deletedAt: deletedAt,
        };
    }

    function deserializeFileVersionLegalHolds(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionLegalHolds"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FileVersionLegalHolds"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FileVersionLegalHolds"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FileVersionLegalHolds"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileVersionLegalHolds"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileVersionLegalHold(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetFileVersionLegalHoldByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileVersionLegalHoldByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionLegalHoldsOptionals {
        constructor(fields) {
            this.headers = new GetFileVersionLegalHoldsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionLegalHoldByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileVersionLegalHoldsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileVersionLegalHoldsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getFileVersionLegalHoldById(fileVersionLegalHoldId_1) {
            return __awaiter(this, arguments, void 0, function* (fileVersionLegalHoldId, optionalsInput = {}) {
                const optionals = new GetFileVersionLegalHoldByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_legal_holds/', toString(fileVersionLegalHoldId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersionLegalHold(response.data);
            });
        }
        getFileVersionLegalHolds(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetFileVersionLegalHoldsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['policy_id']: toString(queryParams.policyId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_legal_holds'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeFileVersionLegalHolds(response.data);
            });
        }
    }

    function serializeEnterpriseBaseTypeField(val) {
        return val;
    }
    function deserializeEnterpriseBaseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize EnterpriseBaseTypeField",
        });
    }
    function serializeEnterpriseBase(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0 ? void 0 : serializeEnterpriseBaseTypeField(val.type),
        };
    }
    function deserializeEnterpriseBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EnterpriseBase"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "EnterpriseBase"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeEnterpriseBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeShieldInformationBarrierTypeField(val) {
        if (val == 'shield_information_barrier') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierTypeField",
        });
    }
    function deserializeShieldInformationBarrierStatusField(val) {
        if (val == 'draft') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (val == 'disabled') {
            return val;
        }
        if (val == 'enabled') {
            return val;
        }
        if (val == 'invalid') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierStatusField",
        });
    }
    function deserializeShieldInformationBarrier(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrier"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrier"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierTypeField(val.type);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeEnterpriseBase(val.enterprise);
        const status = val.status == void 0
            ? void 0
            : deserializeShieldInformationBarrierStatusField(val.status);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrier"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrier"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        if (!(val.enabled_at == void 0) && !sdIsString(val.enabled_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "enabled_at" of type "ShieldInformationBarrier"',
            });
        }
        const enabledAt = val.enabled_at == void 0 ? void 0 : dateTimeFromString(val.enabled_at);
        const enabledBy = val.enabled_by == void 0 ? void 0 : deserializeUserBase(val.enabled_by);
        return {
            id: id,
            type: type,
            enterprise: enterprise,
            status: status,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
            enabledAt: enabledAt,
            enabledBy: enabledBy,
        };
    }

    function deserializeShieldInformationBarriers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarriers"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarriers"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarriers"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarriers"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrier(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateShieldInformationBarrierStatusOptionals {
        constructor(fields) {
            this.headers = new UpdateShieldInformationBarrierStatusHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateShieldInformationBarrierStatusHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarriersHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarriersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getShieldInformationBarrierById(shieldInformationBarrierId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers/', toString(shieldInformationBarrierId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrier(response.data);
            });
        }
        updateShieldInformationBarrierStatus(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new UpdateShieldInformationBarrierStatusOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers/change_status'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeUpdateShieldInformationBarrierStatusRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrier(response.data);
            });
        }
        getShieldInformationBarriers() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetShieldInformationBarriersHeaders({}), cancellationToken) {
                const headers = new GetShieldInformationBarriersHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarriers(response.data);
            });
        }
        createShieldInformationBarrier(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrier(response.data);
            });
        }
    }
    function serializeUpdateShieldInformationBarrierStatusRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateShieldInformationBarrierStatusRequestBody(val) {
        return {
            ['id']: val.id,
            ['status']: serializeUpdateShieldInformationBarrierStatusRequestBodyStatusField(val.status),
        };
    }
    function serializeCreateShieldInformationBarrierRequestBody(val) {
        return { ['enterprise']: serializeEnterpriseBase(val.enterprise) };
    }

    function deserializeShieldInformationBarrierReportBaseTypeField(val) {
        if (val == 'shield_information_barrier_report') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierReportBaseTypeField",
        });
    }

    function serializeShieldInformationBarrierBaseTypeField(val) {
        return val;
    }
    function deserializeShieldInformationBarrierBaseTypeField(val) {
        if (val == 'shield_information_barrier') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierBaseTypeField",
        });
    }
    function serializeShieldInformationBarrierBase(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializeShieldInformationBarrierBaseTypeField(val.type),
        };
    }
    function deserializeShieldInformationBarrierBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierBase"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierBase"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function serializeShieldInformationBarrierReference(val) {
        return {
            ['shield_information_barrier']: val.shieldInformationBarrier == void 0
                ? void 0
                : serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
        };
    }
    function deserializeShieldInformationBarrierReference(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReference"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        return {
            shieldInformationBarrier: shieldInformationBarrier,
        };
    }

    function deserializeShieldInformationBarrierReportDetailsDetailsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReportDetailsDetailsField"',
            });
        }
        if (!(val.folder_id == void 0) && !sdIsString(val.folder_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_id" of type "ShieldInformationBarrierReportDetailsDetailsField"',
            });
        }
        const folderId = val.folder_id == void 0 ? void 0 : val.folder_id;
        return {
            folderId: folderId,
        };
    }
    function deserializeShieldInformationBarrierReportDetails(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReportDetails"',
            });
        }
        const details = val.details == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportDetailsDetailsField(val.details);
        return { details: details };
    }

    function deserializeShieldInformationBarrierReportStatusField(val) {
        if (val == 'pending') {
            return val;
        }
        if (val == 'error') {
            return val;
        }
        if (val == 'done') {
            return val;
        }
        if (val == 'cancelled') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierReportStatusField",
        });
    }
    function deserializeShieldInformationBarrierReport(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReport"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierReference(val.shield_information_barrier);
        const status = val.status == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportStatusField(val.status);
        const details = val.details == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportDetails(val.details);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierReport"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierReport"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierReport"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportBaseTypeField(val.type);
        return {
            shieldInformationBarrier: shieldInformationBarrier,
            status: status,
            details: details,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            id: id,
            type: type,
        };
    }

    function deserializeShieldInformationBarrierReports(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReports"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierReports"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierReports"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierReports"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierReport(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierReportsOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierReportsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierReportOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierReportHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierReportByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierReportByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierReportsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierReportHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierReportByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierReportsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getShieldInformationBarrierReports(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierReportsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_id']: toString(queryParams.shieldInformationBarrierId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_reports'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierReports(response.data);
            });
        }
        createShieldInformationBarrierReport(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierReportOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_reports'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeShieldInformationBarrierReference(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierReport(response.data);
            });
        }
        getShieldInformationBarrierReportById(shieldInformationBarrierReportId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierReportId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierReportByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_reports/', toString(shieldInformationBarrierReportId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierReport(response.data);
            });
        }
    }

    function deserializeShieldInformationBarrierSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegment"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegment"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentTypeField(val.type);
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "ShieldInformationBarrierSegment"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "ShieldInformationBarrierSegment"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierSegment"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierSegment"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        return {
            id: id,
            type: type,
            shieldInformationBarrier: shieldInformationBarrier,
            name: name,
            description: description,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
        };
    }

    function deserializeShieldInformationBarrierSegments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegments"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierSegments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierSegments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierSegments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierSegment(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierSegmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateShieldInformationBarrierSegmentByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateShieldInformationBarrierSegmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteShieldInformationBarrierSegmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentsOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierSegmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateShieldInformationBarrierSegmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierSegmentsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierSegmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getShieldInformationBarrierSegmentById(shieldInformationBarrierSegmentId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierSegmentId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments/', toString(shieldInformationBarrierSegmentId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegment(response.data);
            });
        }
        updateShieldInformationBarrierSegmentById(shieldInformationBarrierSegmentId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierSegmentId, optionalsInput = {}) {
                const optionals = new UpdateShieldInformationBarrierSegmentByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments/', toString(shieldInformationBarrierSegmentId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateShieldInformationBarrierSegmentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegment(response.data);
            });
        }
        deleteShieldInformationBarrierSegmentById(shieldInformationBarrierSegmentId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierSegmentId, optionalsInput = {}) {
                const optionals = new DeleteShieldInformationBarrierSegmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments/', toString(shieldInformationBarrierSegmentId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getShieldInformationBarrierSegments(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_id']: toString(queryParams.shieldInformationBarrierId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegments(response.data);
            });
        }
        createShieldInformationBarrierSegment(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierSegmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierSegmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegment(response.data);
            });
        }
    }
    function serializeUpdateShieldInformationBarrierSegmentByIdRequestBody(val) {
        return {
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['description']: val.description == void 0 ? void 0 : val.description,
        };
    }
    function serializeCreateShieldInformationBarrierSegmentRequestBody(val) {
        return {
            ['shield_information_barrier']: serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
            ['name']: val.name,
            ['description']: val.description == void 0 ? void 0 : val.description,
        };
    }

    function deserializeShieldInformationBarrierSegmentMemberBaseTypeField(val) {
        if (val == 'shield_information_barrier_segment_member') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentMemberBaseTypeField",
        });
    }

    function deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }
    function deserializeShieldInformationBarrierSegmentMember(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentMember"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        const shieldInformationBarrierSegment = val.shield_information_barrier_segment == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField(val.shield_information_barrier_segment);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierSegmentMember"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierSegmentMember"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        const user = val.user == void 0 ? void 0 : deserializeUserBase(val.user);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentMember"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentMemberBaseTypeField(val.type);
        return {
            shieldInformationBarrier: shieldInformationBarrier,
            shieldInformationBarrierSegment: shieldInformationBarrierSegment,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
            user: user,
            id: id,
            type: type,
        };
    }

    function deserializeShieldInformationBarrierSegmentMembers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentMembers"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierSegmentMembers"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierSegmentMembers"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierSegmentMembers"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierSegmentMember(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierSegmentMemberByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentMemberByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentMemberByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteShieldInformationBarrierSegmentMemberByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentMembersOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentMembersHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentMemberOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierSegmentMemberHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentMemberByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentMemberByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierSegmentMembersHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentMemberHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierSegmentMembersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getShieldInformationBarrierSegmentMemberById(shieldInformationBarrierSegmentMemberId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierSegmentMemberId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentMemberByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members/', toString(shieldInformationBarrierSegmentMemberId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegmentMember(response.data);
            });
        }
        deleteShieldInformationBarrierSegmentMemberById(shieldInformationBarrierSegmentMemberId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierSegmentMemberId, optionalsInput = {}) {
                const optionals = new DeleteShieldInformationBarrierSegmentMemberByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members/', toString(shieldInformationBarrierSegmentMemberId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getShieldInformationBarrierSegmentMembers(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentMembersOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_segment_id']: toString(queryParams.shieldInformationBarrierSegmentId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegmentMembers(response.data);
            });
        }
        createShieldInformationBarrierSegmentMember(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierSegmentMemberOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierSegmentMemberRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegmentMember(response.data);
            });
        }
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBodyTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentTypeField(val.type),
        };
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBody(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeCreateShieldInformationBarrierSegmentMemberRequestBodyTypeField(val.type),
            ['shield_information_barrier']: val.shieldInformationBarrier == void 0
                ? void 0
                : serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
            ['shield_information_barrier_segment']: serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentField(val.shieldInformationBarrierSegment),
            ['user']: serializeUserBase(val.user),
        };
    }

    function deserializeShieldInformationBarrierSegmentRestrictionBaseTypeField(val) {
        if (val == 'shield_information_barrier_segment_restriction') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentRestrictionBaseTypeField",
        });
    }

    function deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }
    function deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }

    function deserializeShieldInformationBarrierSegmentRestriction(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        if (val.shield_information_barrier_segment == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "shield_information_barrier_segment" of type "ShieldInformationBarrierSegmentRestriction" to be defined',
            });
        }
        const shieldInformationBarrierSegment = deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField(val.shield_information_barrier_segment);
        if (val.restricted_segment == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "restricted_segment" of type "ShieldInformationBarrierSegmentRestriction" to be defined',
            });
        }
        const restrictedSegment = deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField(val.restricted_segment);
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentRestrictionBaseTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return {
            shieldInformationBarrier: shieldInformationBarrier,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
            shieldInformationBarrierSegment: shieldInformationBarrierSegment,
            restrictedSegment: restrictedSegment,
            type: type,
            id: id,
        };
    }

    function deserializeShieldInformationBarrierSegmentRestrictions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierSegmentRestriction(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierSegmentRestrictionByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentRestrictionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentRestrictionByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteShieldInformationBarrierSegmentRestrictionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentRestrictionsOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentRestrictionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentRestrictionOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierSegmentRestrictionHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentRestrictionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentRestrictionByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierSegmentRestrictionsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentRestrictionRequestBody {
        constructor(fields) {
            this.type = 'shield_information_barrier_segment_restriction';
            if (fields.type) {
                this.type = fields.type;
            }
            if (fields.shieldInformationBarrier) {
                this.shieldInformationBarrier = fields.shieldInformationBarrier;
            }
            if (fields.shieldInformationBarrierSegment) {
                this.shieldInformationBarrierSegment =
                    fields.shieldInformationBarrierSegment;
            }
            if (fields.restrictedSegment) {
                this.restrictedSegment = fields.restrictedSegment;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentRestrictionHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierSegmentRestrictionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getShieldInformationBarrierSegmentRestrictionById(shieldInformationBarrierSegmentRestrictionId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierSegmentRestrictionId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentRestrictionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions/', toString(shieldInformationBarrierSegmentRestrictionId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegmentRestriction(response.data);
            });
        }
        deleteShieldInformationBarrierSegmentRestrictionById(shieldInformationBarrierSegmentRestrictionId_1) {
            return __awaiter(this, arguments, void 0, function* (shieldInformationBarrierSegmentRestrictionId, optionalsInput = {}) {
                const optionals = new DeleteShieldInformationBarrierSegmentRestrictionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions/', toString(shieldInformationBarrierSegmentRestrictionId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getShieldInformationBarrierSegmentRestrictions(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentRestrictionsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_segment_id']: toString(queryParams.shieldInformationBarrierSegmentId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegmentRestrictions(response.data);
            });
        }
        createShieldInformationBarrierSegmentRestriction(requestBodyInput_1) {
            return __awaiter(this, arguments, void 0, function* (requestBodyInput, optionalsInput = {}) {
                const requestBody = new CreateShieldInformationBarrierSegmentRestrictionRequestBody({
                    type: requestBodyInput.type,
                    shieldInformationBarrier: requestBodyInput.shieldInformationBarrier,
                    shieldInformationBarrierSegment: requestBodyInput.shieldInformationBarrierSegment,
                    restrictedSegment: requestBodyInput.restrictedSegment,
                });
                const optionals = new CreateShieldInformationBarrierSegmentRestrictionOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeShieldInformationBarrierSegmentRestriction(response.data);
            });
        }
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentTypeField(val.type),
        };
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0
                ? void 0
                : serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentTypeField(val.type),
        };
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBody(val) {
        return {
            ['type']: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyTypeField(val.type),
            ['shield_information_barrier']: val.shieldInformationBarrier == void 0
                ? void 0
                : serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
            ['shield_information_barrier_segment']: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentField(val.shieldInformationBarrierSegment),
            ['restricted_segment']: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentField(val.restrictedSegment),
        };
    }

    function deserializeDevicePinnerTypeField(val) {
        if (val == 'device_pinner') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize DevicePinnerTypeField" });
    }
    function deserializeDevicePinner(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "DevicePinner"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "DevicePinner"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeDevicePinnerTypeField(val.type);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.product_name == void 0) && !sdIsString(val.product_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "product_name" of type "DevicePinner"',
            });
        }
        const productName = val.product_name == void 0 ? void 0 : val.product_name;
        return {
            id: id,
            type: type,
            ownedBy: ownedBy,
            productName: productName,
        };
    }

    function deserializeDevicePinnersOrderByField(val) {
        if (val == 'id') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DevicePinnersOrderByField",
        });
    }
    function deserializeDevicePinnersOrderDirectionField(val) {
        if (val == 'asc') {
            return val;
        }
        if (val == 'desc') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DevicePinnersOrderDirectionField",
        });
    }
    function deserializeDevicePinnersOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DevicePinnersOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : deserializeDevicePinnersOrderByField(val.by);
        const direction = val.direction == void 0
            ? void 0
            : deserializeDevicePinnersOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeDevicePinners(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "DevicePinners"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "DevicePinners"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeDevicePinner(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "DevicePinners"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsNumber(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting number for "next_marker" of type "DevicePinners"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "DevicePinners"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeDevicePinnersOrderField(itm);
                })
                : [];
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
            order: order,
        };
    }

    class GetDevicePinnerByIdOptionals {
        constructor(fields) {
            this.headers = new GetDevicePinnerByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteDevicePinnerByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteDevicePinnerByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetEnterpriseDevicePinnersOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetEnterpriseDevicePinnersHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDevicePinnerByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteDevicePinnerByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetEnterpriseDevicePinnersHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DevicePinnersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getDevicePinnerById(devicePinnerId_1) {
            return __awaiter(this, arguments, void 0, function* (devicePinnerId, optionalsInput = {}) {
                const optionals = new GetDevicePinnerByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/device_pinners/', toString(devicePinnerId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeDevicePinner(response.data);
            });
        }
        deleteDevicePinnerById(devicePinnerId_1) {
            return __awaiter(this, arguments, void 0, function* (devicePinnerId, optionalsInput = {}) {
                const optionals = new DeleteDevicePinnerByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/device_pinners/', toString(devicePinnerId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getEnterpriseDevicePinners(enterpriseId_1) {
            return __awaiter(this, arguments, void 0, function* (enterpriseId, optionalsInput = {}) {
                const optionals = new GetEnterpriseDevicePinnersOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['direction']: toString(queryParams.direction),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/enterprises/', toString(enterpriseId), '/device_pinners'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeDevicePinners(response.data);
            });
        }
    }

    function deserializeTermsOfServiceStatusField(val) {
        if (val == 'enabled') {
            return val;
        }
        if (val == 'disabled') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceStatusField",
        });
    }
    function deserializeTermsOfServiceEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceEnterpriseTypeField",
        });
    }
    function deserializeTermsOfServiceEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfServiceEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeTermsOfServiceEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TermsOfServiceEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            id: id,
            type: type,
            name: name,
        };
    }
    function deserializeTermsOfServiceTosTypeField(val) {
        if (val == 'managed') {
            return val;
        }
        if (val == 'external') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceTosTypeField",
        });
    }
    function deserializeTermsOfService(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TermsOfService"' });
        }
        const status = val.status == void 0
            ? void 0
            : deserializeTermsOfServiceStatusField(val.status);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeTermsOfServiceEnterpriseField(val.enterprise);
        const tosType = val.tos_type == void 0
            ? void 0
            : deserializeTermsOfServiceTosTypeField(val.tos_type);
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "TermsOfService"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TermsOfService"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TermsOfService"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TermsOfService" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfService"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TermsOfService" to be defined',
            });
        }
        const type = deserializeTermsOfServiceBaseTypeField(val.type);
        return {
            status: status,
            enterprise: enterprise,
            tosType: tosType,
            text: text,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            id: id,
            type: type,
        };
    }

    function deserializeTermsOfServices(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TermsOfServices"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TermsOfServices"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TermsOfServices"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTermsOfService(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    class CreateTermsOfServiceOptionals {
        constructor(fields) {
            this.headers = new CreateTermsOfServiceHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTermsOfServiceByIdOptionals {
        constructor(fields) {
            this.headers = new GetTermsOfServiceByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTermsOfServiceByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateTermsOfServiceByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTermsOfServiceHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTermsOfServiceHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTermsOfServiceByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTermsOfServiceByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TermsOfServicesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getTermsOfService() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetTermsOfServiceHeaders({}), cancellationToken) {
                const headers = new GetTermsOfServiceHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['tos_type']: toString(queryParams.tosType),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTermsOfServices(response.data);
            });
        }
        createTermsOfService(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTermsOfServiceOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTermsOfServiceRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTermsOfService(response.data);
            });
        }
        getTermsOfServiceById(termsOfServiceId_1) {
            return __awaiter(this, arguments, void 0, function* (termsOfServiceId, optionalsInput = {}) {
                const optionals = new GetTermsOfServiceByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services/', toString(termsOfServiceId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTermsOfService(response.data);
            });
        }
        updateTermsOfServiceById(termsOfServiceId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (termsOfServiceId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateTermsOfServiceByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services/', toString(termsOfServiceId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTermsOfServiceByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTermsOfService(response.data);
            });
        }
    }
    function serializeCreateTermsOfServiceRequestBodyStatusField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceRequestBodyTosTypeField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceRequestBody(val) {
        return {
            ['status']: serializeCreateTermsOfServiceRequestBodyStatusField(val.status),
            ['tos_type']: val.tosType == void 0
                ? void 0
                : serializeCreateTermsOfServiceRequestBodyTosTypeField(val.tosType),
            ['text']: val.text,
        };
    }
    function serializeUpdateTermsOfServiceByIdRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateTermsOfServiceByIdRequestBody(val) {
        return {
            ['status']: serializeUpdateTermsOfServiceByIdRequestBodyStatusField(val.status),
            ['text']: val.text,
        };
    }

    function deserializeTermsOfServiceUserStatusTypeField(val) {
        if (val == 'terms_of_service_user_status') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceUserStatusTypeField",
        });
    }
    function deserializeTermsOfServiceUserStatus(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceUserStatus"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TermsOfServiceUserStatus" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfServiceUserStatus"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TermsOfServiceUserStatus" to be defined',
            });
        }
        const type = deserializeTermsOfServiceUserStatusTypeField(val.type);
        const tos = val.tos == void 0 ? void 0 : deserializeTermsOfServiceBase(val.tos);
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        if (!(val.is_accepted == void 0) && !sdIsBoolean(val.is_accepted)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accepted" of type "TermsOfServiceUserStatus"',
            });
        }
        const isAccepted = val.is_accepted == void 0 ? void 0 : val.is_accepted;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TermsOfServiceUserStatus"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TermsOfServiceUserStatus"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            tos: tos,
            user: user,
            isAccepted: isAccepted,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    function deserializeTermsOfServiceUserStatuses(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceUserStatuses"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TermsOfServiceUserStatuses"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TermsOfServiceUserStatuses"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTermsOfServiceUserStatus(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }

    class GetTermsOfServiceUserStatusesOptionals {
        constructor(fields) {
            this.headers = new GetTermsOfServiceUserStatusesHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateTermsOfServiceStatusForUserOptionals {
        constructor(fields) {
            this.headers = new CreateTermsOfServiceStatusForUserHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTermsOfServiceStatusForUserByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateTermsOfServiceStatusForUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTermsOfServiceUserStatusesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTermsOfServiceStatusForUserHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTermsOfServiceStatusForUserByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TermsOfServiceUserStatusesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getTermsOfServiceUserStatuses(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetTermsOfServiceUserStatusesOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['tos_id']: toString(queryParams.tosId),
                    ['user_id']: toString(queryParams.userId),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_service_user_statuses'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTermsOfServiceUserStatuses(response.data);
            });
        }
        createTermsOfServiceStatusForUser(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTermsOfServiceStatusForUserOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_service_user_statuses'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTermsOfServiceStatusForUserRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTermsOfServiceUserStatus(response.data);
            });
        }
        updateTermsOfServiceStatusForUserById(termsOfServiceUserStatusId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (termsOfServiceUserStatusId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateTermsOfServiceStatusForUserByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_service_user_statuses/', toString(termsOfServiceUserStatusId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTermsOfServiceStatusForUserByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeTermsOfServiceUserStatus(response.data);
            });
        }
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyTosTypeField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyTosField(val) {
        return {
            ['type']: serializeCreateTermsOfServiceStatusForUserRequestBodyTosTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyUserTypeField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyUserField(val) {
        return {
            ['type']: serializeCreateTermsOfServiceStatusForUserRequestBodyUserTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBody(val) {
        return {
            ['tos']: serializeCreateTermsOfServiceStatusForUserRequestBodyTosField(val.tos),
            ['user']: serializeCreateTermsOfServiceStatusForUserRequestBodyUserField(val.user),
            ['is_accepted']: val.isAccepted,
        };
    }
    function serializeUpdateTermsOfServiceStatusForUserByIdRequestBody(val) {
        return { ['is_accepted']: val.isAccepted };
    }

    function deserializeCollaborationAllowlistEntryTypeField(val) {
        if (val == 'collaboration_whitelist_entry') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistEntryTypeField",
        });
    }
    function deserializeCollaborationAllowlistEntryDirectionField(val) {
        if (val == 'inbound') {
            return val;
        }
        if (val == 'outbound') {
            return val;
        }
        if (val == 'both') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistEntryDirectionField",
        });
    }
    function deserializeCollaborationAllowlistEntryEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistEntryEnterpriseTypeField",
        });
    }
    function deserializeCollaborationAllowlistEntryEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistEntryEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistEntryEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "CollaborationAllowlistEntryEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            id: id,
            type: type,
            name: name,
        };
    }
    function deserializeCollaborationAllowlistEntry(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistEntry"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistEntry"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryTypeField(val.type);
        if (!(val.domain == void 0) && !sdIsString(val.domain)) {
            throw new BoxSdkError({
                message: 'Expecting string for "domain" of type "CollaborationAllowlistEntry"',
            });
        }
        const domain = val.domain == void 0 ? void 0 : val.domain;
        const direction = val.direction == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryDirectionField(val.direction);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryEnterpriseField(val.enterprise);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "CollaborationAllowlistEntry"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        return {
            id: id,
            type: type,
            domain: domain,
            direction: direction,
            enterprise: enterprise,
            createdAt: createdAt,
        };
    }

    function deserializeCollaborationAllowlistEntries(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistEntries"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "CollaborationAllowlistEntries"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "CollaborationAllowlistEntries"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "CollaborationAllowlistEntries"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "CollaborationAllowlistEntries"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollaborationAllowlistEntry(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class CreateCollaborationWhitelistEntryOptionals {
        constructor(fields) {
            this.headers = new CreateCollaborationWhitelistEntryHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistEntryByIdOptionals {
        constructor(fields) {
            this.headers = new GetCollaborationWhitelistEntryByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCollaborationWhitelistEntryByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCollaborationWhitelistEntryByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistEntriesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCollaborationWhitelistEntryHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollaborationWhitelistEntryByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCollaborationWhitelistEntryByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CollaborationAllowlistEntriesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getCollaborationWhitelistEntries() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetCollaborationWhitelistEntriesHeaders({}), cancellationToken) {
                const headers = new GetCollaborationWhitelistEntriesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborationAllowlistEntries(response.data);
            });
        }
        createCollaborationWhitelistEntry(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCollaborationWhitelistEntryOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateCollaborationWhitelistEntryRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborationAllowlistEntry(response.data);
            });
        }
        getCollaborationWhitelistEntryById(collaborationWhitelistEntryId_1) {
            return __awaiter(this, arguments, void 0, function* (collaborationWhitelistEntryId, optionalsInput = {}) {
                const optionals = new GetCollaborationWhitelistEntryByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries/', toString(collaborationWhitelistEntryId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborationAllowlistEntry(response.data);
            });
        }
        deleteCollaborationWhitelistEntryById(collaborationWhitelistEntryId_1) {
            return __awaiter(this, arguments, void 0, function* (collaborationWhitelistEntryId, optionalsInput = {}) {
                const optionals = new DeleteCollaborationWhitelistEntryByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries/', toString(collaborationWhitelistEntryId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateCollaborationWhitelistEntryRequestBodyDirectionField(val) {
        return val;
    }
    function serializeCreateCollaborationWhitelistEntryRequestBody(val) {
        return {
            ['domain']: val.domain,
            ['direction']: serializeCreateCollaborationWhitelistEntryRequestBodyDirectionField(val.direction),
        };
    }

    function deserializeCollaborationAllowlistExemptTargetTypeField(val) {
        if (val == 'collaboration_whitelist_exempt_target') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistExemptTargetTypeField",
        });
    }
    function deserializeCollaborationAllowlistExemptTargetEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistExemptTargetEnterpriseTypeField",
        });
    }
    function deserializeCollaborationAllowlistExemptTargetEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistExemptTargetEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistExemptTargetEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistExemptTargetEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "CollaborationAllowlistExemptTargetEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            id: id,
            type: type,
            name: name,
        };
    }
    function deserializeCollaborationAllowlistExemptTarget(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistExemptTarget"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistExemptTarget"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistExemptTargetTypeField(val.type);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeCollaborationAllowlistExemptTargetEnterpriseField(val.enterprise);
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "CollaborationAllowlistExemptTarget"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "CollaborationAllowlistExemptTarget"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            enterprise: enterprise,
            user: user,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    function deserializeCollaborationAllowlistExemptTargets(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistExemptTargets"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollaborationAllowlistExemptTarget(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class CreateCollaborationWhitelistExemptTargetOptionals {
        constructor(fields) {
            this.headers = new CreateCollaborationWhitelistExemptTargetHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistExemptTargetByIdOptionals {
        constructor(fields) {
            this.headers = new GetCollaborationWhitelistExemptTargetByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCollaborationWhitelistExemptTargetByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCollaborationWhitelistExemptTargetByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistExemptTargetsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCollaborationWhitelistExemptTargetHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollaborationWhitelistExemptTargetByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCollaborationWhitelistExemptTargetByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CollaborationAllowlistExemptTargetsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getCollaborationWhitelistExemptTargets() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetCollaborationWhitelistExemptTargetsHeaders({}), cancellationToken) {
                const headers = new GetCollaborationWhitelistExemptTargetsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborationAllowlistExemptTargets(response.data);
            });
        }
        createCollaborationWhitelistExemptTarget(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCollaborationWhitelistExemptTargetOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateCollaborationWhitelistExemptTargetRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborationAllowlistExemptTarget(response.data);
            });
        }
        getCollaborationWhitelistExemptTargetById(collaborationWhitelistExemptTargetId_1) {
            return __awaiter(this, arguments, void 0, function* (collaborationWhitelistExemptTargetId, optionalsInput = {}) {
                const optionals = new GetCollaborationWhitelistExemptTargetByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets/', toString(collaborationWhitelistExemptTargetId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeCollaborationAllowlistExemptTarget(response.data);
            });
        }
        deleteCollaborationWhitelistExemptTargetById(collaborationWhitelistExemptTargetId_1) {
            return __awaiter(this, arguments, void 0, function* (collaborationWhitelistExemptTargetId, optionalsInput = {}) {
                const optionals = new DeleteCollaborationWhitelistExemptTargetByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets/', toString(collaborationWhitelistExemptTargetId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateCollaborationWhitelistExemptTargetRequestBodyUserField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateCollaborationWhitelistExemptTargetRequestBody(val) {
        return {
            ['user']: serializeCreateCollaborationWhitelistExemptTargetRequestBodyUserField(val.user),
        };
    }

    function deserializeStoragePolicyMiniTypeField(val) {
        if (val == 'storage_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StoragePolicyMiniTypeField",
        });
    }
    function deserializeStoragePolicyMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyMini"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StoragePolicyMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicyMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StoragePolicyMini" to be defined',
            });
        }
        const type = deserializeStoragePolicyMiniTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeStoragePolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "StoragePolicy"' });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "StoragePolicy"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StoragePolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StoragePolicy" to be defined',
            });
        }
        const type = deserializeStoragePolicyMiniTypeField(val.type);
        return { name: name, id: id, type: type };
    }

    function deserializeStoragePolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "StoragePolicies"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "StoragePolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "StoragePolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "StoragePolicies"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "StoragePolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeStoragePolicy(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetStoragePolicyByIdOptionals {
        constructor(fields) {
            this.headers = new GetStoragePolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetStoragePoliciesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetStoragePolicyByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class StoragePoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getStoragePolicies() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetStoragePoliciesHeaders({}), cancellationToken) {
                const headers = new GetStoragePoliciesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policies'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeStoragePolicies(response.data);
            });
        }
        getStoragePolicyById(storagePolicyId_1) {
            return __awaiter(this, arguments, void 0, function* (storagePolicyId, optionalsInput = {}) {
                const optionals = new GetStoragePolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policies/', toString(storagePolicyId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeStoragePolicy(response.data);
            });
        }
    }

    function deserializeStoragePolicyAssignmentTypeField(val) {
        if (val == 'storage_policy_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StoragePolicyAssignmentTypeField",
        });
    }
    function deserializeStoragePolicyAssignmentAssignedToField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyAssignmentAssignedToField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicyAssignmentAssignedToField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "StoragePolicyAssignmentAssignedToField"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        return {
            id: id,
            type: type,
        };
    }
    function deserializeStoragePolicyAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyAssignment"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StoragePolicyAssignment" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicyAssignment"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StoragePolicyAssignment" to be defined',
            });
        }
        const type = deserializeStoragePolicyAssignmentTypeField(val.type);
        const storagePolicy = val.storage_policy == void 0
            ? void 0
            : deserializeStoragePolicyMini(val.storage_policy);
        const assignedTo = val.assigned_to == void 0
            ? void 0
            : deserializeStoragePolicyAssignmentAssignedToField(val.assigned_to);
        return {
            id: id,
            type: type,
            storagePolicy: storagePolicy,
            assignedTo: assignedTo,
        };
    }

    function deserializeStoragePolicyAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyAssignments"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "StoragePolicyAssignments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "StoragePolicyAssignments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "StoragePolicyAssignments"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "StoragePolicyAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeStoragePolicyAssignment(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetStoragePolicyAssignmentsOptionals {
        constructor(fields) {
            this.headers = new GetStoragePolicyAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateStoragePolicyAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateStoragePolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetStoragePolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetStoragePolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateStoragePolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateStoragePolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteStoragePolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteStoragePolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetStoragePolicyAssignmentsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateStoragePolicyAssignmentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetStoragePolicyAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateStoragePolicyAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteStoragePolicyAssignmentByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class StoragePolicyAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getStoragePolicyAssignments(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetStoragePolicyAssignmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['resolved_for_type']: toString(queryParams.resolvedForType),
                    ['resolved_for_id']: toString(queryParams.resolvedForId),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeStoragePolicyAssignments(response.data);
            });
        }
        createStoragePolicyAssignment(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateStoragePolicyAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateStoragePolicyAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeStoragePolicyAssignment(response.data);
            });
        }
        getStoragePolicyAssignmentById(storagePolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (storagePolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetStoragePolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments/', toString(storagePolicyAssignmentId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeStoragePolicyAssignment(response.data);
            });
        }
        updateStoragePolicyAssignmentById(storagePolicyAssignmentId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (storagePolicyAssignmentId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateStoragePolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments/', toString(storagePolicyAssignmentId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateStoragePolicyAssignmentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeStoragePolicyAssignment(response.data);
            });
        }
        deleteStoragePolicyAssignmentById(storagePolicyAssignmentId_1) {
            return __awaiter(this, arguments, void 0, function* (storagePolicyAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteStoragePolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments/', toString(storagePolicyAssignmentId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyTypeField(val) {
        return val;
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyField(val) {
        return {
            ['type']: serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyAssignedToTypeField(val) {
        return val;
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyAssignedToField(val) {
        return {
            ['type']: serializeCreateStoragePolicyAssignmentRequestBodyAssignedToTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateStoragePolicyAssignmentRequestBody(val) {
        return {
            ['storage_policy']: serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyField(val.storagePolicy),
            ['assigned_to']: serializeCreateStoragePolicyAssignmentRequestBodyAssignedToField(val.assignedTo),
        };
    }
    function serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyTypeField(val) {
        return val;
    }
    function serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyField(val) {
        return {
            ['type']: serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeUpdateStoragePolicyAssignmentByIdRequestBody(val) {
        return {
            ['storage_policy']: serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyField(val.storagePolicy),
        };
    }

    function deserializeZipDownloadNameConflictsTypeField(val) {
        if (val == 'file') {
            return val;
        }
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ZipDownloadNameConflictsTypeField",
        });
    }
    function deserializeZipDownloadNameConflictsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ZipDownloadNameConflictsField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ZipDownloadNameConflictsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeZipDownloadNameConflictsTypeField(val.type);
        if (!(val.original_name == void 0) && !sdIsString(val.original_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "original_name" of type "ZipDownloadNameConflictsField"',
            });
        }
        const originalName = val.original_name == void 0 ? void 0 : val.original_name;
        if (!(val.download_name == void 0) && !sdIsString(val.download_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_name" of type "ZipDownloadNameConflictsField"',
            });
        }
        const downloadName = val.download_name == void 0 ? void 0 : val.download_name;
        return {
            id: id,
            type: type,
            originalName: originalName,
            downloadName: downloadName,
        };
    }
    function deserializeZipDownload(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "ZipDownload"' });
        }
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "ZipDownload"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.status_url == void 0) && !sdIsString(val.status_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "status_url" of type "ZipDownload"',
            });
        }
        const statusUrl = val.status_url == void 0 ? void 0 : val.status_url;
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "ZipDownload"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        if (!(val.name_conflicts == void 0) && !sdIsList(val.name_conflicts)) {
            throw new BoxSdkError({
                message: 'Expecting array for "name_conflicts" of type "ZipDownload"',
            });
        }
        const nameConflicts = val.name_conflicts == void 0
            ? void 0
            : sdIsList(val.name_conflicts)
                ? val.name_conflicts.map(function (itm) {
                    return sdIsList(itm)
                        ? itm.map(function (itm) {
                            return deserializeZipDownloadNameConflictsField(itm);
                        })
                        : [];
                })
                : [];
        return {
            downloadUrl: downloadUrl,
            statusUrl: statusUrl,
            expiresAt: expiresAt,
            nameConflicts: nameConflicts,
        };
    }

    function serializeZipDownloadRequestItemsTypeField(val) {
        return val;
    }
    function serializeZipDownloadRequestItemsField(val) {
        return {
            ['type']: serializeZipDownloadRequestItemsTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeZipDownloadRequest(val) {
        return {
            ['items']: val.items.map(function (item) {
                return serializeZipDownloadRequestItemsField(item);
            }),
            ['download_file_name']: val.downloadFileName == void 0 ? void 0 : val.downloadFileName,
        };
    }

    function deserializeZipDownloadStatusStateField(val) {
        if (val == 'in_progress') {
            return val;
        }
        if (val == 'failed') {
            return val;
        }
        if (val == 'succeeded') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ZipDownloadStatusStateField",
        });
    }
    function deserializeZipDownloadStatus(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ZipDownloadStatus"',
            });
        }
        if (!(val.total_file_count == void 0) && !sdIsNumber(val.total_file_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_file_count" of type "ZipDownloadStatus"',
            });
        }
        const totalFileCount = val.total_file_count == void 0 ? void 0 : val.total_file_count;
        if (!(val.downloaded_file_count == void 0) &&
            !sdIsNumber(val.downloaded_file_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "downloaded_file_count" of type "ZipDownloadStatus"',
            });
        }
        const downloadedFileCount = val.downloaded_file_count == void 0 ? void 0 : val.downloaded_file_count;
        if (!(val.skipped_file_count == void 0) &&
            !sdIsNumber(val.skipped_file_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "skipped_file_count" of type "ZipDownloadStatus"',
            });
        }
        const skippedFileCount = val.skipped_file_count == void 0 ? void 0 : val.skipped_file_count;
        if (!(val.skipped_folder_count == void 0) &&
            !sdIsNumber(val.skipped_folder_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "skipped_folder_count" of type "ZipDownloadStatus"',
            });
        }
        const skippedFolderCount = val.skipped_folder_count == void 0 ? void 0 : val.skipped_folder_count;
        const state = val.state == void 0
            ? void 0
            : deserializeZipDownloadStatusStateField(val.state);
        return {
            totalFileCount: totalFileCount,
            downloadedFileCount: downloadedFileCount,
            skippedFileCount: skippedFileCount,
            skippedFolderCount: skippedFolderCount,
            state: state,
        };
    }

    class CreateZipDownloadOptionals {
        constructor(fields) {
            this.headers = new CreateZipDownloadHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetZipDownloadContentOptionals {
        constructor(fields) {
            this.headers = new GetZipDownloadContentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetZipDownloadStatusOptionals {
        constructor(fields) {
            this.headers = new GetZipDownloadStatusHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DownloadZipOptionals {
        constructor(fields) {
            this.headers = new DownloadZipHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateZipDownloadHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetZipDownloadContentHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetZipDownloadStatusHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DownloadZipHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ZipDownloadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        createZipDownload(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateZipDownloadOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/zip_downloads'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeZipDownloadRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeZipDownload(response.data);
            });
        }
        getZipDownloadContent(downloadUrl_1) {
            return __awaiter(this, arguments, void 0, function* (downloadUrl, optionalsInput = {}) {
                const optionals = new GetZipDownloadContentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(downloadUrl, {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return response.content;
            });
        }
        getZipDownloadStatus(statusUrl_1) {
            return __awaiter(this, arguments, void 0, function* (statusUrl, optionalsInput = {}) {
                const optionals = new GetZipDownloadStatusOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(statusUrl, {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeZipDownloadStatus(response.data);
            });
        }
        downloadZip(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new DownloadZipOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const zipDownloadSession = yield this.createZipDownload({
                    items: requestBody.items,
                    downloadFileName: requestBody.downloadFileName,
                }, {
                    headers: new CreateZipDownloadHeaders({
                        extraHeaders: headers.extraHeaders,
                    }),
                    cancellationToken: cancellationToken,
                });
                return yield this.getZipDownloadContent(zipDownloadSession.downloadUrl, {
                    headers: new GetZipDownloadContentHeaders({
                        extraHeaders: headers.extraHeaders,
                    }),
                    cancellationToken: cancellationToken,
                });
            });
        }
    }

    function serializeSignRequestPrefillTag(val) {
        return {
            ['document_tag_id']: val.documentTagId == void 0 ? void 0 : val.documentTagId,
            ['text_value']: val.textValue == void 0 ? void 0 : val.textValue,
            ['checkbox_value']: val.checkboxValue == void 0 ? void 0 : val.checkboxValue,
            ['date_value']: val.dateValue == void 0 ? void 0 : dateToString(val.dateValue),
        };
    }
    function deserializeSignRequestPrefillTag(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestPrefillTag"',
            });
        }
        if (!(val.document_tag_id == void 0) && !sdIsString(val.document_tag_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_tag_id" of type "SignRequestPrefillTag"',
            });
        }
        const documentTagId = val.document_tag_id == void 0 ? void 0 : val.document_tag_id;
        if (!(val.text_value == void 0) && !sdIsString(val.text_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text_value" of type "SignRequestPrefillTag"',
            });
        }
        const textValue = val.text_value == void 0 ? void 0 : val.text_value;
        if (!(val.checkbox_value == void 0) && !sdIsBoolean(val.checkbox_value)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "checkbox_value" of type "SignRequestPrefillTag"',
            });
        }
        const checkboxValue = val.checkbox_value == void 0 ? void 0 : val.checkbox_value;
        if (!(val.date_value == void 0) && !sdIsString(val.date_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "date_value" of type "SignRequestPrefillTag"',
            });
        }
        const dateValue = val.date_value == void 0 ? void 0 : dateFromString(val.date_value);
        return {
            documentTagId: documentTagId,
            textValue: textValue,
            checkboxValue: checkboxValue,
            dateValue: dateValue,
        };
    }

    function serializeSignRequestBase(val) {
        return {
            ['is_document_preparation_needed']: val.isDocumentPreparationNeeded == void 0
                ? void 0
                : val.isDocumentPreparationNeeded,
            ['redirect_url']: val.redirectUrl == void 0 ? void 0 : val.redirectUrl,
            ['declined_redirect_url']: val.declinedRedirectUrl == void 0 ? void 0 : val.declinedRedirectUrl,
            ['are_text_signatures_enabled']: val.areTextSignaturesEnabled == void 0
                ? void 0
                : val.areTextSignaturesEnabled,
            ['email_subject']: val.emailSubject == void 0 ? void 0 : val.emailSubject,
            ['email_message']: val.emailMessage == void 0 ? void 0 : val.emailMessage,
            ['are_reminders_enabled']: val.areRemindersEnabled == void 0 ? void 0 : val.areRemindersEnabled,
            ['name']: val.name == void 0 ? void 0 : val.name,
            ['prefill_tags']: val.prefillTags == void 0
                ? void 0
                : val.prefillTags.map(function (item) {
                    return serializeSignRequestPrefillTag(item);
                }),
            ['days_valid']: val.daysValid == void 0 ? void 0 : val.daysValid,
            ['external_id']: val.externalId == void 0 ? void 0 : val.externalId,
            ['is_phone_verification_required_to_view']: val.isPhoneVerificationRequiredToView == void 0
                ? void 0
                : val.isPhoneVerificationRequiredToView,
            ['template_id']: val.templateId == void 0 ? void 0 : val.templateId,
            ['external_system_name']: val.externalSystemName == void 0 ? void 0 : val.externalSystemName,
        };
    }

    function serializeSignRequestCreateSignerRoleField(val) {
        return val;
    }
    function deserializeSignRequestCreateSignerRoleField(val) {
        if (val == 'signer') {
            return val;
        }
        if (val == 'approver') {
            return val;
        }
        if (val == 'final_copy_reader') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestCreateSignerRoleField",
        });
    }
    function serializeSignRequestCreateSigner(val) {
        return {
            ['email']: val.email == void 0 ? void 0 : val.email,
            ['role']: val.role == void 0
                ? void 0
                : serializeSignRequestCreateSignerRoleField(val.role),
            ['is_in_person']: val.isInPerson == void 0 ? void 0 : val.isInPerson,
            ['order']: val.order == void 0 ? void 0 : val.order,
            ['embed_url_external_user_id']: val.embedUrlExternalUserId == void 0
                ? void 0
                : val.embedUrlExternalUserId,
            ['redirect_url']: val.redirectUrl == void 0 ? void 0 : val.redirectUrl,
            ['declined_redirect_url']: val.declinedRedirectUrl == void 0 ? void 0 : val.declinedRedirectUrl,
            ['login_required']: val.loginRequired == void 0 ? void 0 : val.loginRequired,
            ['verification_phone_number']: val.verificationPhoneNumber == void 0
                ? void 0
                : val.verificationPhoneNumber,
            ['password']: val.password == void 0 ? void 0 : val.password,
            ['signer_group_id']: val.signerGroupId == void 0 ? void 0 : val.signerGroupId,
            ['suppress_notifications']: val.suppressNotifications == void 0 ? void 0 : val.suppressNotifications,
        };
    }

    function deserializeSignRequestSignerInputTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestSignerInputTypeField",
        });
    }
    function deserializeSignRequestSignerInputContentTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'initial') {
            return val;
        }
        if (val == 'stamp') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'full_name') {
            return val;
        }
        if (val == 'first_name') {
            return val;
        }
        if (val == 'last_name') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'title') {
            return val;
        }
        if (val == 'email') {
            return val;
        }
        if (val == 'attachment') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestSignerInputContentTypeField",
        });
    }
    function deserializeSignRequestSignerInput(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSignerInput"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeSignRequestSignerInputTypeField(val.type);
        const contentType = val.content_type == void 0
            ? void 0
            : deserializeSignRequestSignerInputContentTypeField(val.content_type);
        if (val.page_index == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "page_index" of type "SignRequestSignerInput" to be defined',
            });
        }
        if (!sdIsNumber(val.page_index)) {
            throw new BoxSdkError({
                message: 'Expecting number for "page_index" of type "SignRequestSignerInput"',
            });
        }
        const pageIndex = val.page_index;
        if (!(val.read_only == void 0) && !sdIsBoolean(val.read_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "read_only" of type "SignRequestSignerInput"',
            });
        }
        const readOnly = val.read_only == void 0 ? void 0 : val.read_only;
        if (!(val.document_tag_id == void 0) && !sdIsString(val.document_tag_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_tag_id" of type "SignRequestSignerInput"',
            });
        }
        const documentTagId = val.document_tag_id == void 0 ? void 0 : val.document_tag_id;
        if (!(val.text_value == void 0) && !sdIsString(val.text_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text_value" of type "SignRequestSignerInput"',
            });
        }
        const textValue = val.text_value == void 0 ? void 0 : val.text_value;
        if (!(val.checkbox_value == void 0) && !sdIsBoolean(val.checkbox_value)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "checkbox_value" of type "SignRequestSignerInput"',
            });
        }
        const checkboxValue = val.checkbox_value == void 0 ? void 0 : val.checkbox_value;
        if (!(val.date_value == void 0) && !sdIsString(val.date_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "date_value" of type "SignRequestSignerInput"',
            });
        }
        const dateValue = val.date_value == void 0 ? void 0 : dateFromString(val.date_value);
        return {
            type: type,
            contentType: contentType,
            pageIndex: pageIndex,
            readOnly: readOnly,
            documentTagId: documentTagId,
            textValue: textValue,
            checkboxValue: checkboxValue,
            dateValue: dateValue,
        };
    }

    function deserializeSignRequestSignerSignerDecisionTypeField(val) {
        if (val == 'signed') {
            return val;
        }
        if (val == 'declined') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestSignerSignerDecisionTypeField",
        });
    }
    function deserializeSignRequestSignerSignerDecisionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSignerSignerDecisionField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeSignRequestSignerSignerDecisionTypeField(val.type);
        if (!(val.finalized_at == void 0) && !sdIsString(val.finalized_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "finalized_at" of type "SignRequestSignerSignerDecisionField"',
            });
        }
        const finalizedAt = val.finalized_at == void 0 ? void 0 : dateTimeFromString(val.finalized_at);
        if (!(val.additional_info == void 0) && !sdIsString(val.additional_info)) {
            throw new BoxSdkError({
                message: 'Expecting string for "additional_info" of type "SignRequestSignerSignerDecisionField"',
            });
        }
        const additionalInfo = val.additional_info == void 0 ? void 0 : val.additional_info;
        return {
            type: type,
            finalizedAt: finalizedAt,
            additionalInfo: additionalInfo,
        };
    }
    function deserializeSignRequestSigner(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSigner"',
            });
        }
        if (!(val.has_viewed_document == void 0) &&
            !sdIsBoolean(val.has_viewed_document)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "has_viewed_document" of type "SignRequestSigner"',
            });
        }
        const hasViewedDocument = val.has_viewed_document == void 0 ? void 0 : val.has_viewed_document;
        const signerDecision = val.signer_decision == void 0
            ? void 0
            : deserializeSignRequestSignerSignerDecisionField(val.signer_decision);
        if (!(val.inputs == void 0) && !sdIsList(val.inputs)) {
            throw new BoxSdkError({
                message: 'Expecting array for "inputs" of type "SignRequestSigner"',
            });
        }
        const inputs = val.inputs == void 0
            ? void 0
            : sdIsList(val.inputs)
                ? val.inputs.map(function (itm) {
                    return deserializeSignRequestSignerInput(itm);
                })
                : [];
        if (!(val.embed_url == void 0) && !sdIsString(val.embed_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "embed_url" of type "SignRequestSigner"',
            });
        }
        const embedUrl = val.embed_url == void 0 ? void 0 : val.embed_url;
        if (!(val.iframeable_embed_url == void 0) &&
            !sdIsString(val.iframeable_embed_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "iframeable_embed_url" of type "SignRequestSigner"',
            });
        }
        const iframeableEmbedUrl = val.iframeable_embed_url == void 0 ? void 0 : val.iframeable_embed_url;
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "SignRequestSigner"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        const role = val.role == void 0
            ? void 0
            : deserializeSignRequestCreateSignerRoleField(val.role);
        if (!(val.is_in_person == void 0) && !sdIsBoolean(val.is_in_person)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_in_person" of type "SignRequestSigner"',
            });
        }
        const isInPerson = val.is_in_person == void 0 ? void 0 : val.is_in_person;
        if (!(val.order == void 0) && !sdIsNumber(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting number for "order" of type "SignRequestSigner"',
            });
        }
        const order = val.order == void 0 ? void 0 : val.order;
        if (!(val.embed_url_external_user_id == void 0) &&
            !sdIsString(val.embed_url_external_user_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "embed_url_external_user_id" of type "SignRequestSigner"',
            });
        }
        const embedUrlExternalUserId = val.embed_url_external_user_id == void 0
            ? void 0
            : val.embed_url_external_user_id;
        if (!(val.redirect_url == void 0) && !sdIsString(val.redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "redirect_url" of type "SignRequestSigner"',
            });
        }
        const redirectUrl = val.redirect_url == void 0 ? void 0 : val.redirect_url;
        if (!(val.declined_redirect_url == void 0) &&
            !sdIsString(val.declined_redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "declined_redirect_url" of type "SignRequestSigner"',
            });
        }
        const declinedRedirectUrl = val.declined_redirect_url == void 0 ? void 0 : val.declined_redirect_url;
        if (!(val.login_required == void 0) && !sdIsBoolean(val.login_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "login_required" of type "SignRequestSigner"',
            });
        }
        const loginRequired = val.login_required == void 0 ? void 0 : val.login_required;
        if (!(val.verification_phone_number == void 0) &&
            !sdIsString(val.verification_phone_number)) {
            throw new BoxSdkError({
                message: 'Expecting string for "verification_phone_number" of type "SignRequestSigner"',
            });
        }
        const verificationPhoneNumber = val.verification_phone_number == void 0
            ? void 0
            : val.verification_phone_number;
        if (!(val.password == void 0) && !sdIsString(val.password)) {
            throw new BoxSdkError({
                message: 'Expecting string for "password" of type "SignRequestSigner"',
            });
        }
        const password = val.password == void 0 ? void 0 : val.password;
        if (!(val.signer_group_id == void 0) && !sdIsString(val.signer_group_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "signer_group_id" of type "SignRequestSigner"',
            });
        }
        const signerGroupId = val.signer_group_id == void 0 ? void 0 : val.signer_group_id;
        if (!(val.suppress_notifications == void 0) &&
            !sdIsBoolean(val.suppress_notifications)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "suppress_notifications" of type "SignRequestSigner"',
            });
        }
        const suppressNotifications = val.suppress_notifications == void 0 ? void 0 : val.suppress_notifications;
        return {
            hasViewedDocument: hasViewedDocument,
            signerDecision: signerDecision,
            inputs: inputs,
            embedUrl: embedUrl,
            iframeableEmbedUrl: iframeableEmbedUrl,
            email: email,
            role: role,
            isInPerson: isInPerson,
            order: order,
            embedUrlExternalUserId: embedUrlExternalUserId,
            redirectUrl: redirectUrl,
            declinedRedirectUrl: declinedRedirectUrl,
            loginRequired: loginRequired,
            verificationPhoneNumber: verificationPhoneNumber,
            password: password,
            signerGroupId: signerGroupId,
            suppressNotifications: suppressNotifications,
        };
    }

    function deserializeSignRequestTypeField(val) {
        if (val == 'sign-request') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize SignRequestTypeField" });
    }
    function deserializeSignRequestStatusField(val) {
        if (val == 'converting') {
            return val;
        }
        if (val == 'created') {
            return val;
        }
        if (val == 'sent') {
            return val;
        }
        if (val == 'viewed') {
            return val;
        }
        if (val == 'signed') {
            return val;
        }
        if (val == 'cancelled') {
            return val;
        }
        if (val == 'declined') {
            return val;
        }
        if (val == 'error_converting') {
            return val;
        }
        if (val == 'error_sending') {
            return val;
        }
        if (val == 'expired') {
            return val;
        }
        if (val == 'finalizing') {
            return val;
        }
        if (val == 'error_finalizing') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestStatusField",
        });
    }
    function deserializeSignRequestSignFilesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSignFilesField"',
            });
        }
        if (!(val.files == void 0) && !sdIsList(val.files)) {
            throw new BoxSdkError({
                message: 'Expecting array for "files" of type "SignRequestSignFilesField"',
            });
        }
        const files = val.files == void 0
            ? void 0
            : sdIsList(val.files)
                ? val.files.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        if (!(val.is_ready_for_download == void 0) &&
            !sdIsBoolean(val.is_ready_for_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_ready_for_download" of type "SignRequestSignFilesField"',
            });
        }
        const isReadyForDownload = val.is_ready_for_download == void 0 ? void 0 : val.is_ready_for_download;
        return {
            files: files,
            isReadyForDownload: isReadyForDownload,
        };
    }
    function deserializeSignRequest(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignRequest"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeSignRequestTypeField(val.type);
        if (!(val.source_files == void 0) && !sdIsList(val.source_files)) {
            throw new BoxSdkError({
                message: 'Expecting array for "source_files" of type "SignRequest"',
            });
        }
        const sourceFiles = val.source_files == void 0
            ? void 0
            : sdIsList(val.source_files)
                ? val.source_files.map(function (itm) {
                    return deserializeFileBase(itm);
                })
                : [];
        if (!(val.signers == void 0) && !sdIsList(val.signers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "signers" of type "SignRequest"',
            });
        }
        const signers = val.signers == void 0
            ? void 0
            : sdIsList(val.signers)
                ? val.signers.map(function (itm) {
                    return deserializeSignRequestSigner(itm);
                })
                : [];
        if (!(val.signature_color == void 0) && !sdIsString(val.signature_color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "signature_color" of type "SignRequest"',
            });
        }
        const signatureColor = val.signature_color == void 0 ? void 0 : val.signature_color;
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "SignRequest"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.prepare_url == void 0) && !sdIsString(val.prepare_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prepare_url" of type "SignRequest"',
            });
        }
        const prepareUrl = val.prepare_url == void 0 ? void 0 : val.prepare_url;
        const signingLog = val.signing_log == void 0 ? void 0 : deserializeFileMini(val.signing_log);
        const status = val.status == void 0
            ? void 0
            : deserializeSignRequestStatusField(val.status);
        const signFiles = val.sign_files == void 0
            ? void 0
            : deserializeSignRequestSignFilesField(val.sign_files);
        if (!(val.auto_expire_at == void 0) && !sdIsString(val.auto_expire_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "auto_expire_at" of type "SignRequest"',
            });
        }
        const autoExpireAt = val.auto_expire_at == void 0
            ? void 0
            : dateTimeFromString(val.auto_expire_at);
        const parentFolder = val.parent_folder == void 0
            ? void 0
            : deserializeFolderMini(val.parent_folder);
        if (!(val.is_document_preparation_needed == void 0) &&
            !sdIsBoolean(val.is_document_preparation_needed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_document_preparation_needed" of type "SignRequest"',
            });
        }
        const isDocumentPreparationNeeded = val.is_document_preparation_needed == void 0
            ? void 0
            : val.is_document_preparation_needed;
        if (!(val.redirect_url == void 0) && !sdIsString(val.redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "redirect_url" of type "SignRequest"',
            });
        }
        const redirectUrl = val.redirect_url == void 0 ? void 0 : val.redirect_url;
        if (!(val.declined_redirect_url == void 0) &&
            !sdIsString(val.declined_redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "declined_redirect_url" of type "SignRequest"',
            });
        }
        const declinedRedirectUrl = val.declined_redirect_url == void 0 ? void 0 : val.declined_redirect_url;
        if (!(val.are_text_signatures_enabled == void 0) &&
            !sdIsBoolean(val.are_text_signatures_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_text_signatures_enabled" of type "SignRequest"',
            });
        }
        const areTextSignaturesEnabled = val.are_text_signatures_enabled == void 0
            ? void 0
            : val.are_text_signatures_enabled;
        if (!(val.email_subject == void 0) && !sdIsString(val.email_subject)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_subject" of type "SignRequest"',
            });
        }
        const emailSubject = val.email_subject == void 0 ? void 0 : val.email_subject;
        if (!(val.email_message == void 0) && !sdIsString(val.email_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_message" of type "SignRequest"',
            });
        }
        const emailMessage = val.email_message == void 0 ? void 0 : val.email_message;
        if (!(val.are_reminders_enabled == void 0) &&
            !sdIsBoolean(val.are_reminders_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_reminders_enabled" of type "SignRequest"',
            });
        }
        const areRemindersEnabled = val.are_reminders_enabled == void 0 ? void 0 : val.are_reminders_enabled;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "SignRequest"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.prefill_tags == void 0) && !sdIsList(val.prefill_tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "prefill_tags" of type "SignRequest"',
            });
        }
        const prefillTags = val.prefill_tags == void 0
            ? void 0
            : sdIsList(val.prefill_tags)
                ? val.prefill_tags.map(function (itm) {
                    return deserializeSignRequestPrefillTag(itm);
                })
                : [];
        if (!(val.days_valid == void 0) && !sdIsNumber(val.days_valid)) {
            throw new BoxSdkError({
                message: 'Expecting number for "days_valid" of type "SignRequest"',
            });
        }
        const daysValid = val.days_valid == void 0 ? void 0 : val.days_valid;
        if (!(val.external_id == void 0) && !sdIsString(val.external_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_id" of type "SignRequest"',
            });
        }
        const externalId = val.external_id == void 0 ? void 0 : val.external_id;
        if (!(val.is_phone_verification_required_to_view == void 0) &&
            !sdIsBoolean(val.is_phone_verification_required_to_view)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_phone_verification_required_to_view" of type "SignRequest"',
            });
        }
        const isPhoneVerificationRequiredToView = val.is_phone_verification_required_to_view == void 0
            ? void 0
            : val.is_phone_verification_required_to_view;
        if (!(val.template_id == void 0) && !sdIsString(val.template_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "template_id" of type "SignRequest"',
            });
        }
        const templateId = val.template_id == void 0 ? void 0 : val.template_id;
        if (!(val.external_system_name == void 0) &&
            !sdIsString(val.external_system_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_system_name" of type "SignRequest"',
            });
        }
        const externalSystemName = val.external_system_name == void 0 ? void 0 : val.external_system_name;
        return {
            type: type,
            sourceFiles: sourceFiles,
            signers: signers,
            signatureColor: signatureColor,
            id: id,
            prepareUrl: prepareUrl,
            signingLog: signingLog,
            status: status,
            signFiles: signFiles,
            autoExpireAt: autoExpireAt,
            parentFolder: parentFolder,
            isDocumentPreparationNeeded: isDocumentPreparationNeeded,
            redirectUrl: redirectUrl,
            declinedRedirectUrl: declinedRedirectUrl,
            areTextSignaturesEnabled: areTextSignaturesEnabled,
            emailSubject: emailSubject,
            emailMessage: emailMessage,
            areRemindersEnabled: areRemindersEnabled,
            name: name,
            prefillTags: prefillTags,
            daysValid: daysValid,
            externalId: externalId,
            isPhoneVerificationRequiredToView: isPhoneVerificationRequiredToView,
            templateId: templateId,
            externalSystemName: externalSystemName,
        };
    }

    function deserializeSignRequests(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignRequests"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SignRequests"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "SignRequests"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SignRequests"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeSignRequest(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    function serializeSignRequestCreateRequestSignatureColorField(val) {
        return val;
    }
    function serializeSignRequestCreateRequest(val) {
        const base = serializeSignRequestBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestCreateRequest"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['source_files']: val.sourceFiles == void 0
                ? void 0
                : val.sourceFiles.map(function (item) {
                    return serializeFileBase(item);
                }),
            ['signature_color']: val.signatureColor == void 0
                ? void 0
                : serializeSignRequestCreateRequestSignatureColorField(val.signatureColor),
            ['signers']: val.signers.map(function (item) {
                return serializeSignRequestCreateSigner(item);
            }),
            ['parent_folder']: val.parentFolder == void 0
                ? void 0
                : serializeFolderMini(val.parentFolder),
        });
    }

    class CancelSignRequestOptionals {
        constructor(fields) {
            this.headers = new CancelSignRequestHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class ResendSignRequestOptionals {
        constructor(fields) {
            this.headers = new ResendSignRequestHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSignRequestByIdOptionals {
        constructor(fields) {
            this.headers = new GetSignRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateSignRequestOptionals {
        constructor(fields) {
            this.headers = new CreateSignRequestHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CancelSignRequestHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ResendSignRequestHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSignRequestByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSignRequestsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateSignRequestHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SignRequestsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        cancelSignRequest(signRequestId_1) {
            return __awaiter(this, arguments, void 0, function* (signRequestId, optionalsInput = {}) {
                const optionals = new CancelSignRequestOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests/', toString(signRequestId), '/cancel'), {
                    method: 'POST',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSignRequest(response.data);
            });
        }
        resendSignRequest(signRequestId_1) {
            return __awaiter(this, arguments, void 0, function* (signRequestId, optionalsInput = {}) {
                const optionals = new ResendSignRequestOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests/', toString(signRequestId), '/resend'), {
                    method: 'POST',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        getSignRequestById(signRequestId_1) {
            return __awaiter(this, arguments, void 0, function* (signRequestId, optionalsInput = {}) {
                const optionals = new GetSignRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests/', toString(signRequestId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSignRequest(response.data);
            });
        }
        getSignRequests() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetSignRequestsHeaders({}), cancellationToken) {
                const headers = new GetSignRequestsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSignRequests(response.data);
            });
        }
        createSignRequest(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateSignRequestOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeSignRequestCreateRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSignRequest(response.data);
            });
        }
    }

    function deserializeWorkflowMiniTypeField(val) {
        if (val == 'workflow') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WorkflowMiniTypeField" });
    }

    function deserializeWorkflowFlowsTypeField(val) {
        if (val == 'flow') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerTypeField(val) {
        if (val == 'trigger') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerTriggerTypeField(val) {
        if (val == 'WORKFLOW_MANUAL_START') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerTriggerTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerScopeTypeField(val) {
        if (val == 'trigger_scope') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerScopeTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerScopeObjectTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerScopeObjectTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerScopeObjectField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsTriggerScopeObjectField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerScopeObjectTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsTriggerScopeObjectField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return { type: type, id: id };
    }
    function deserializeWorkflowFlowsTriggerScopeField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsTriggerScopeField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerScopeTypeField(val.type);
        if (!(val.ref == void 0) && !sdIsString(val.ref)) {
            throw new BoxSdkError({
                message: 'Expecting string for "ref" of type "WorkflowFlowsTriggerScopeField"',
            });
        }
        const ref = val.ref == void 0 ? void 0 : val.ref;
        const object = val.object == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerScopeObjectField(val.object);
        return {
            type: type,
            ref: ref,
            object: object,
        };
    }
    function deserializeWorkflowFlowsTriggerField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsTriggerField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerTypeField(val.type);
        const triggerType = val.trigger_type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerTriggerTypeField(val.trigger_type);
        if (!(val.scope == void 0) && !sdIsList(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting array for "scope" of type "WorkflowFlowsTriggerField"',
            });
        }
        const scope = val.scope == void 0
            ? void 0
            : sdIsList(val.scope)
                ? val.scope.map(function (itm) {
                    return deserializeWorkflowFlowsTriggerScopeField(itm);
                })
                : [];
        return {
            type: type,
            triggerType: triggerType,
            scope: scope,
        };
    }
    function deserializeWorkflowFlowsOutcomesTypeField(val) {
        if (val == 'outcome') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesActionTypeField(val) {
        if (val == 'add_metadata') {
            return val;
        }
        if (val == 'assign_task') {
            return val;
        }
        if (val == 'copy_file') {
            return val;
        }
        if (val == 'copy_folder') {
            return val;
        }
        if (val == 'create_folder') {
            return val;
        }
        if (val == 'delete_file') {
            return val;
        }
        if (val == 'delete_folder') {
            return val;
        }
        if (val == 'lock_file') {
            return val;
        }
        if (val == 'move_file') {
            return val;
        }
        if (val == 'move_folder') {
            return val;
        }
        if (val == 'remove_watermark_file') {
            return val;
        }
        if (val == 'rename_folder') {
            return val;
        }
        if (val == 'restore_folder') {
            return val;
        }
        if (val == 'share_file') {
            return val;
        }
        if (val == 'share_folder') {
            return val;
        }
        if (val == 'unlock_file') {
            return val;
        }
        if (val == 'upload_file') {
            return val;
        }
        if (val == 'wait_for_task') {
            return val;
        }
        if (val == 'watermark_file') {
            return val;
        }
        if (val == 'go_back_to_step') {
            return val;
        }
        if (val == 'apply_file_classification') {
            return val;
        }
        if (val == 'apply_folder_classification') {
            return val;
        }
        if (val == 'send_notification') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesActionTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesIfRejectedTypeField(val) {
        if (val == 'outcome') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesIfRejectedTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesIfRejectedActionTypeField(val) {
        if (val == 'add_metadata') {
            return val;
        }
        if (val == 'assign_task') {
            return val;
        }
        if (val == 'copy_file') {
            return val;
        }
        if (val == 'copy_folder') {
            return val;
        }
        if (val == 'create_folder') {
            return val;
        }
        if (val == 'delete_file') {
            return val;
        }
        if (val == 'delete_folder') {
            return val;
        }
        if (val == 'lock_file') {
            return val;
        }
        if (val == 'move_file') {
            return val;
        }
        if (val == 'move_folder') {
            return val;
        }
        if (val == 'remove_watermark_file') {
            return val;
        }
        if (val == 'rename_folder') {
            return val;
        }
        if (val == 'restore_folder') {
            return val;
        }
        if (val == 'share_file') {
            return val;
        }
        if (val == 'share_folder') {
            return val;
        }
        if (val == 'unlock_file') {
            return val;
        }
        if (val == 'upload_file') {
            return val;
        }
        if (val == 'wait_for_task') {
            return val;
        }
        if (val == 'watermark_file') {
            return val;
        }
        if (val == 'go_back_to_step') {
            return val;
        }
        if (val == 'apply_file_classification') {
            return val;
        }
        if (val == 'apply_folder_classification') {
            return val;
        }
        if (val == 'send_notification') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesIfRejectedActionTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesIfRejectedField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsOutcomesIfRejectedField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsOutcomesIfRejectedField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesIfRejectedTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "WorkflowFlowsOutcomesIfRejectedField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const actionType = val.action_type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesIfRejectedActionTypeField(val.action_type);
        return {
            id: id,
            type: type,
            name: name,
            actionType: actionType,
        };
    }
    function deserializeWorkflowFlowsOutcomesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsOutcomesField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsOutcomesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "WorkflowFlowsOutcomesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const actionType = val.action_type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesActionTypeField(val.action_type);
        if (!(val.if_rejected == void 0) && !sdIsList(val.if_rejected)) {
            throw new BoxSdkError({
                message: 'Expecting array for "if_rejected" of type "WorkflowFlowsOutcomesField"',
            });
        }
        const ifRejected = val.if_rejected == void 0
            ? void 0
            : sdIsList(val.if_rejected)
                ? val.if_rejected.map(function (itm) {
                    return deserializeWorkflowFlowsOutcomesIfRejectedField(itm);
                })
                : [];
        return {
            id: id,
            type: type,
            name: name,
            actionType: actionType,
            ifRejected: ifRejected,
        };
    }
    function deserializeWorkflowFlowsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWorkflowFlowsTypeField(val.type);
        const trigger = val.trigger == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerField(val.trigger);
        if (!(val.outcomes == void 0) && !sdIsList(val.outcomes)) {
            throw new BoxSdkError({
                message: 'Expecting array for "outcomes" of type "WorkflowFlowsField"',
            });
        }
        const outcomes = val.outcomes == void 0
            ? void 0
            : sdIsList(val.outcomes)
                ? val.outcomes.map(function (itm) {
                    return deserializeWorkflowFlowsOutcomesField(itm);
                })
                : [];
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "WorkflowFlowsField"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        return {
            id: id,
            type: type,
            trigger: trigger,
            outcomes: outcomes,
            createdAt: createdAt,
            createdBy: createdBy,
        };
    }
    function deserializeWorkflow(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Workflow"' });
        }
        if (!(val.flows == void 0) && !sdIsList(val.flows)) {
            throw new BoxSdkError({
                message: 'Expecting array for "flows" of type "Workflow"',
            });
        }
        const flows = val.flows == void 0
            ? void 0
            : sdIsList(val.flows)
                ? val.flows.map(function (itm) {
                    return deserializeWorkflowFlowsField(itm);
                })
                : [];
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Workflow"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWorkflowMiniTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "Workflow"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "Workflow"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.is_enabled == void 0) && !sdIsBoolean(val.is_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_enabled" of type "Workflow"',
            });
        }
        const isEnabled = val.is_enabled == void 0 ? void 0 : val.is_enabled;
        return {
            flows: flows,
            id: id,
            type: type,
            name: name,
            description: description,
            isEnabled: isEnabled,
        };
    }

    function deserializeWorkflows(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Workflows"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Workflows"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Workflows"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Workflows"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Workflows"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeWorkflow(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function serializeCollaboratorVariableTypeField(val) {
        return val;
    }
    function serializeCollaboratorVariableVariableTypeField(val) {
        return val;
    }
    function serializeCollaboratorVariableVariableValueTypeField(val) {
        return val;
    }
    function serializeCollaboratorVariableVariableValueField(val) {
        return {
            ['type']: serializeCollaboratorVariableVariableValueTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCollaboratorVariable(val) {
        return {
            ['type']: serializeCollaboratorVariableTypeField(val.type),
            ['variable_type']: serializeCollaboratorVariableVariableTypeField(val.variableType),
            ['variable_value']: val.variableValue.map(function (item) {
                return serializeCollaboratorVariableVariableValueField(item);
            }),
        };
    }

    function serializeCompletionRuleVariableTypeField(val) {
        return val;
    }
    function serializeCompletionRuleVariableVariableTypeField(val) {
        return val;
    }
    function serializeCompletionRuleVariableVariableValueField(val) {
        return val;
    }
    function serializeCompletionRuleVariable(val) {
        return {
            ['type']: serializeCompletionRuleVariableTypeField(val.type),
            ['variable_type']: serializeCompletionRuleVariableVariableTypeField(val.variableType),
            ['variable_value']: serializeCompletionRuleVariableVariableValueField(val.variableValue),
        };
    }

    function serializeRoleVariableTypeField(val) {
        return val;
    }
    function serializeRoleVariableVariableTypeField(val) {
        return val;
    }
    function serializeRoleVariableVariableValueField(val) {
        return val;
    }
    function serializeRoleVariable(val) {
        return {
            ['type']: serializeRoleVariableTypeField(val.type),
            ['variable_type']: serializeRoleVariableVariableTypeField(val.variableType),
            ['variable_value']: serializeRoleVariableVariableValueField(val.variableValue),
        };
    }

    function serializeOutcome(val) {
        return {
            ['id']: val.id,
            ['collaborators']: val.collaborators == void 0
                ? void 0
                : serializeCollaboratorVariable(val.collaborators),
            ['completion_rule']: val.completionRule == void 0
                ? void 0
                : serializeCompletionRuleVariable(val.completionRule),
            ['file_collaborator_role']: val.fileCollaboratorRole == void 0
                ? void 0
                : serializeRoleVariable(val.fileCollaboratorRole),
            ['task_collaborators']: val.taskCollaborators == void 0
                ? void 0
                : serializeCollaboratorVariable(val.taskCollaborators),
            ['role']: val.role == void 0 ? void 0 : serializeRoleVariable(val.role),
        };
    }

    class GetWorkflowsOptionals {
        constructor(fields) {
            this.headers = new GetWorkflowsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class StartWorkflowOptionals {
        constructor(fields) {
            this.headers = new StartWorkflowHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetWorkflowsHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class StartWorkflowHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class WorkflowsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getWorkflows(queryParams_1) {
            return __awaiter(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetWorkflowsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['folder_id']: toString(queryParams.folderId),
                    ['trigger_type']: toString(queryParams.triggerType),
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/workflows'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeWorkflows(response.data);
            });
        }
        startWorkflow(workflowId_1, requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (workflowId, requestBody, optionalsInput = {}) {
                const optionals = new StartWorkflowOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/workflows/', toString(workflowId), '/start'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeStartWorkflowRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeStartWorkflowRequestBodyTypeField(val) {
        return val;
    }
    function serializeStartWorkflowRequestBodyFlowField(val) {
        return {
            ['type']: val.type == void 0 ? void 0 : val.type,
            ['id']: val.id == void 0 ? void 0 : val.id,
        };
    }
    function serializeStartWorkflowRequestBodyFilesTypeField(val) {
        return val;
    }
    function serializeStartWorkflowRequestBodyFilesField(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeStartWorkflowRequestBodyFilesTypeField(val.type),
            ['id']: val.id == void 0 ? void 0 : val.id,
        };
    }
    function serializeStartWorkflowRequestBodyFolderTypeField(val) {
        return val;
    }
    function serializeStartWorkflowRequestBodyFolderField(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeStartWorkflowRequestBodyFolderTypeField(val.type),
            ['id']: val.id == void 0 ? void 0 : val.id,
        };
    }
    function serializeStartWorkflowRequestBody(val) {
        return {
            ['type']: val.type == void 0
                ? void 0
                : serializeStartWorkflowRequestBodyTypeField(val.type),
            ['flow']: serializeStartWorkflowRequestBodyFlowField(val.flow),
            ['files']: val.files.map(function (item) {
                return serializeStartWorkflowRequestBodyFilesField(item);
            }),
            ['folder']: serializeStartWorkflowRequestBodyFolderField(val.folder),
            ['outcomes']: val.outcomes == void 0
                ? void 0
                : val.outcomes.map(function (item) {
                    return serializeOutcome(item);
                }),
        };
    }

    function deserializeTemplateSignerInputTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'attachment') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TemplateSignerInputTypeField",
        });
    }
    function deserializeTemplateSignerInputContentTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'initial') {
            return val;
        }
        if (val == 'stamp') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'full_name') {
            return val;
        }
        if (val == 'first_name') {
            return val;
        }
        if (val == 'last_name') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'title') {
            return val;
        }
        if (val == 'email') {
            return val;
        }
        if (val == 'attachment') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TemplateSignerInputContentTypeField",
        });
    }
    function deserializeTemplateSignerInputCoordinatesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TemplateSignerInputCoordinatesField"',
            });
        }
        if (!(val.x == void 0) && !sdIsNumber(val.x)) {
            throw new BoxSdkError({
                message: 'Expecting number for "x" of type "TemplateSignerInputCoordinatesField"',
            });
        }
        const x = val.x == void 0 ? void 0 : val.x;
        if (!(val.y == void 0) && !sdIsNumber(val.y)) {
            throw new BoxSdkError({
                message: 'Expecting number for "y" of type "TemplateSignerInputCoordinatesField"',
            });
        }
        const y = val.y == void 0 ? void 0 : val.y;
        return { x: x, y: y };
    }
    function deserializeTemplateSignerInputDimensionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TemplateSignerInputDimensionsField"',
            });
        }
        if (!(val.width == void 0) && !sdIsNumber(val.width)) {
            throw new BoxSdkError({
                message: 'Expecting number for "width" of type "TemplateSignerInputDimensionsField"',
            });
        }
        const width = val.width == void 0 ? void 0 : val.width;
        if (!(val.height == void 0) && !sdIsNumber(val.height)) {
            throw new BoxSdkError({
                message: 'Expecting number for "height" of type "TemplateSignerInputDimensionsField"',
            });
        }
        const height = val.height == void 0 ? void 0 : val.height;
        return {
            width: width,
            height: height,
        };
    }
    function deserializeTemplateSignerInput(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TemplateSignerInput"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTemplateSignerInputTypeField(val.type);
        const contentType = val.content_type == void 0
            ? void 0
            : deserializeTemplateSignerInputContentTypeField(val.content_type);
        if (!(val.is_required == void 0) && !sdIsBoolean(val.is_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_required" of type "TemplateSignerInput"',
            });
        }
        const isRequired = val.is_required == void 0 ? void 0 : val.is_required;
        if (val.page_index == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "page_index" of type "TemplateSignerInput" to be defined',
            });
        }
        if (!sdIsNumber(val.page_index)) {
            throw new BoxSdkError({
                message: 'Expecting number for "page_index" of type "TemplateSignerInput"',
            });
        }
        const pageIndex = val.page_index;
        if (!(val.document_id == void 0) && !sdIsString(val.document_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_id" of type "TemplateSignerInput"',
            });
        }
        const documentId = val.document_id == void 0 ? void 0 : val.document_id;
        if (!(val.dropdown_choices == void 0) && !sdIsList(val.dropdown_choices)) {
            throw new BoxSdkError({
                message: 'Expecting array for "dropdown_choices" of type "TemplateSignerInput"',
            });
        }
        const dropdownChoices = val.dropdown_choices == void 0
            ? void 0
            : sdIsList(val.dropdown_choices)
                ? val.dropdown_choices.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "TemplateSignerInput"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.group_id == void 0) && !sdIsString(val.group_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "group_id" of type "TemplateSignerInput"',
            });
        }
        const groupId = val.group_id == void 0 ? void 0 : val.group_id;
        const coordinates = val.coordinates == void 0
            ? void 0
            : deserializeTemplateSignerInputCoordinatesField(val.coordinates);
        const dimensions = val.dimensions == void 0
            ? void 0
            : deserializeTemplateSignerInputDimensionsField(val.dimensions);
        if (!(val.label == void 0) && !sdIsString(val.label)) {
            throw new BoxSdkError({
                message: 'Expecting string for "label" of type "TemplateSignerInput"',
            });
        }
        const label = val.label == void 0 ? void 0 : val.label;
        if (!(val.read_only == void 0) && !sdIsBoolean(val.read_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "read_only" of type "TemplateSignerInput"',
            });
        }
        const readOnly = val.read_only == void 0 ? void 0 : val.read_only;
        if (!(val.document_tag_id == void 0) && !sdIsString(val.document_tag_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_tag_id" of type "TemplateSignerInput"',
            });
        }
        const documentTagId = val.document_tag_id == void 0 ? void 0 : val.document_tag_id;
        if (!(val.text_value == void 0) && !sdIsString(val.text_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text_value" of type "TemplateSignerInput"',
            });
        }
        const textValue = val.text_value == void 0 ? void 0 : val.text_value;
        if (!(val.checkbox_value == void 0) && !sdIsBoolean(val.checkbox_value)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "checkbox_value" of type "TemplateSignerInput"',
            });
        }
        const checkboxValue = val.checkbox_value == void 0 ? void 0 : val.checkbox_value;
        if (!(val.date_value == void 0) && !sdIsString(val.date_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "date_value" of type "TemplateSignerInput"',
            });
        }
        const dateValue = val.date_value == void 0 ? void 0 : dateFromString(val.date_value);
        return {
            type: type,
            contentType: contentType,
            isRequired: isRequired,
            pageIndex: pageIndex,
            documentId: documentId,
            dropdownChoices: dropdownChoices,
            groupId: groupId,
            coordinates: coordinates,
            dimensions: dimensions,
            label: label,
            readOnly: readOnly,
            documentTagId: documentTagId,
            textValue: textValue,
            checkboxValue: checkboxValue,
            dateValue: dateValue,
        };
    }

    function deserializeTemplateSignerRoleField(val) {
        if (val == 'signer') {
            return val;
        }
        if (val == 'approver') {
            return val;
        }
        if (val == 'final_copy_reader') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TemplateSignerRoleField",
        });
    }
    function deserializeTemplateSigner(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TemplateSigner"' });
        }
        if (!(val.inputs == void 0) && !sdIsList(val.inputs)) {
            throw new BoxSdkError({
                message: 'Expecting array for "inputs" of type "TemplateSigner"',
            });
        }
        const inputs = val.inputs == void 0
            ? void 0
            : sdIsList(val.inputs)
                ? val.inputs.map(function (itm) {
                    return deserializeTemplateSignerInput(itm);
                })
                : [];
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "TemplateSigner"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        const role = val.role == void 0 ? void 0 : deserializeTemplateSignerRoleField(val.role);
        if (!(val.is_in_person == void 0) && !sdIsBoolean(val.is_in_person)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_in_person" of type "TemplateSigner"',
            });
        }
        const isInPerson = val.is_in_person == void 0 ? void 0 : val.is_in_person;
        if (!(val.order == void 0) && !sdIsNumber(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting number for "order" of type "TemplateSigner"',
            });
        }
        const order = val.order == void 0 ? void 0 : val.order;
        if (!(val.signer_group_id == void 0) && !sdIsString(val.signer_group_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "signer_group_id" of type "TemplateSigner"',
            });
        }
        const signerGroupId = val.signer_group_id == void 0 ? void 0 : val.signer_group_id;
        return {
            inputs: inputs,
            email: email,
            role: role,
            isInPerson: isInPerson,
            order: order,
            signerGroupId: signerGroupId,
        };
    }

    function deserializeSignTemplateTypeField(val) {
        if (val == 'sign-template') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize SignTemplateTypeField" });
    }
    function deserializeSignTemplateAdditionalInfoNonEditableField(val) {
        if (val == 'email_subject') {
            return val;
        }
        if (val == 'email_message') {
            return val;
        }
        if (val == 'name') {
            return val;
        }
        if (val == 'days_valid') {
            return val;
        }
        if (val == 'signers') {
            return val;
        }
        if (val == 'source_files') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignTemplateAdditionalInfoNonEditableField",
        });
    }
    function deserializeSignTemplateAdditionalInfoRequiredSignersField(val) {
        if (val == 'email') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignTemplateAdditionalInfoRequiredSignersField",
        });
    }
    function deserializeSignTemplateAdditionalInfoRequiredField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateAdditionalInfoRequiredField"',
            });
        }
        if (!(val.signers == void 0) && !sdIsList(val.signers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "signers" of type "SignTemplateAdditionalInfoRequiredField"',
            });
        }
        const signers = val.signers == void 0
            ? void 0
            : sdIsList(val.signers)
                ? val.signers.map(function (itm) {
                    return sdIsList(itm)
                        ? itm.map(function (itm) {
                            return deserializeSignTemplateAdditionalInfoRequiredSignersField(itm);
                        })
                        : [];
                })
                : [];
        return { signers: signers };
    }
    function deserializeSignTemplateAdditionalInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateAdditionalInfoField"',
            });
        }
        if (!(val.non_editable == void 0) && !sdIsList(val.non_editable)) {
            throw new BoxSdkError({
                message: 'Expecting array for "non_editable" of type "SignTemplateAdditionalInfoField"',
            });
        }
        const nonEditable = val.non_editable == void 0
            ? void 0
            : sdIsList(val.non_editable)
                ? val.non_editable.map(function (itm) {
                    return deserializeSignTemplateAdditionalInfoNonEditableField(itm);
                })
                : [];
        const required = val.required == void 0
            ? void 0
            : deserializeSignTemplateAdditionalInfoRequiredField(val.required);
        return {
            nonEditable: nonEditable,
            required: required,
        };
    }
    function deserializeSignTemplateReadySignLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateReadySignLinkField"',
            });
        }
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "SignTemplateReadySignLinkField"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "SignTemplateReadySignLinkField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.instructions == void 0) && !sdIsString(val.instructions)) {
            throw new BoxSdkError({
                message: 'Expecting string for "instructions" of type "SignTemplateReadySignLinkField"',
            });
        }
        const instructions = val.instructions == void 0 ? void 0 : val.instructions;
        if (!(val.folder_id == void 0) && !sdIsString(val.folder_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_id" of type "SignTemplateReadySignLinkField"',
            });
        }
        const folderId = val.folder_id == void 0 ? void 0 : val.folder_id;
        if (!(val.is_notification_disabled == void 0) &&
            !sdIsBoolean(val.is_notification_disabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_notification_disabled" of type "SignTemplateReadySignLinkField"',
            });
        }
        const isNotificationDisabled = val.is_notification_disabled == void 0
            ? void 0
            : val.is_notification_disabled;
        if (!(val.is_active == void 0) && !sdIsBoolean(val.is_active)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_active" of type "SignTemplateReadySignLinkField"',
            });
        }
        const isActive = val.is_active == void 0 ? void 0 : val.is_active;
        return {
            url: url,
            name: name,
            instructions: instructions,
            folderId: folderId,
            isNotificationDisabled: isNotificationDisabled,
            isActive: isActive,
        };
    }
    function deserializeSignTemplateCustomBrandingField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateCustomBrandingField"',
            });
        }
        if (!(val.company_name == void 0) && !sdIsString(val.company_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "company_name" of type "SignTemplateCustomBrandingField"',
            });
        }
        const companyName = val.company_name == void 0 ? void 0 : val.company_name;
        if (!(val.logo_uri == void 0) && !sdIsString(val.logo_uri)) {
            throw new BoxSdkError({
                message: 'Expecting string for "logo_uri" of type "SignTemplateCustomBrandingField"',
            });
        }
        const logoUri = val.logo_uri == void 0 ? void 0 : val.logo_uri;
        if (!(val.branding_color == void 0) && !sdIsString(val.branding_color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "branding_color" of type "SignTemplateCustomBrandingField"',
            });
        }
        const brandingColor = val.branding_color == void 0 ? void 0 : val.branding_color;
        if (!(val.email_footer_text == void 0) &&
            !sdIsString(val.email_footer_text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_footer_text" of type "SignTemplateCustomBrandingField"',
            });
        }
        const emailFooterText = val.email_footer_text == void 0 ? void 0 : val.email_footer_text;
        return {
            companyName: companyName,
            logoUri: logoUri,
            brandingColor: brandingColor,
            emailFooterText: emailFooterText,
        };
    }
    function deserializeSignTemplate(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignTemplate"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeSignTemplateTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "SignTemplate"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "SignTemplate"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.email_subject == void 0) && !sdIsString(val.email_subject)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_subject" of type "SignTemplate"',
            });
        }
        const emailSubject = val.email_subject == void 0 ? void 0 : val.email_subject;
        if (!(val.email_message == void 0) && !sdIsString(val.email_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_message" of type "SignTemplate"',
            });
        }
        const emailMessage = val.email_message == void 0 ? void 0 : val.email_message;
        if (!(val.days_valid == void 0) && !sdIsNumber(val.days_valid)) {
            throw new BoxSdkError({
                message: 'Expecting number for "days_valid" of type "SignTemplate"',
            });
        }
        const daysValid = val.days_valid == void 0 ? void 0 : val.days_valid;
        const parentFolder = val.parent_folder == void 0
            ? void 0
            : deserializeFolderMini(val.parent_folder);
        if (!(val.source_files == void 0) && !sdIsList(val.source_files)) {
            throw new BoxSdkError({
                message: 'Expecting array for "source_files" of type "SignTemplate"',
            });
        }
        const sourceFiles = val.source_files == void 0
            ? void 0
            : sdIsList(val.source_files)
                ? val.source_files.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        if (!(val.are_fields_locked == void 0) &&
            !sdIsBoolean(val.are_fields_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_fields_locked" of type "SignTemplate"',
            });
        }
        const areFieldsLocked = val.are_fields_locked == void 0 ? void 0 : val.are_fields_locked;
        if (!(val.are_options_locked == void 0) &&
            !sdIsBoolean(val.are_options_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_options_locked" of type "SignTemplate"',
            });
        }
        const areOptionsLocked = val.are_options_locked == void 0 ? void 0 : val.are_options_locked;
        if (!(val.are_recipients_locked == void 0) &&
            !sdIsBoolean(val.are_recipients_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_recipients_locked" of type "SignTemplate"',
            });
        }
        const areRecipientsLocked = val.are_recipients_locked == void 0 ? void 0 : val.are_recipients_locked;
        if (!(val.are_email_settings_locked == void 0) &&
            !sdIsBoolean(val.are_email_settings_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_email_settings_locked" of type "SignTemplate"',
            });
        }
        const areEmailSettingsLocked = val.are_email_settings_locked == void 0
            ? void 0
            : val.are_email_settings_locked;
        if (!(val.are_files_locked == void 0) && !sdIsBoolean(val.are_files_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_files_locked" of type "SignTemplate"',
            });
        }
        const areFilesLocked = val.are_files_locked == void 0 ? void 0 : val.are_files_locked;
        if (!(val.signers == void 0) && !sdIsList(val.signers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "signers" of type "SignTemplate"',
            });
        }
        const signers = val.signers == void 0
            ? void 0
            : sdIsList(val.signers)
                ? val.signers.map(function (itm) {
                    return deserializeTemplateSigner(itm);
                })
                : [];
        const additionalInfo = val.additional_info == void 0
            ? void 0
            : deserializeSignTemplateAdditionalInfoField(val.additional_info);
        const readySignLink = val.ready_sign_link == void 0
            ? void 0
            : deserializeSignTemplateReadySignLinkField(val.ready_sign_link);
        const customBranding = val.custom_branding == void 0
            ? void 0
            : deserializeSignTemplateCustomBrandingField(val.custom_branding);
        return {
            type: type,
            id: id,
            name: name,
            emailSubject: emailSubject,
            emailMessage: emailMessage,
            daysValid: daysValid,
            parentFolder: parentFolder,
            sourceFiles: sourceFiles,
            areFieldsLocked: areFieldsLocked,
            areOptionsLocked: areOptionsLocked,
            areRecipientsLocked: areRecipientsLocked,
            areEmailSettingsLocked: areEmailSettingsLocked,
            areFilesLocked: areFilesLocked,
            signers: signers,
            additionalInfo: additionalInfo,
            readySignLink: readySignLink,
            customBranding: customBranding,
        };
    }

    function deserializeSignTemplates(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignTemplates"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SignTemplates"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "SignTemplates"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "SignTemplates"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SignTemplates"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeSignTemplate(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetSignTemplateByIdOptionals {
        constructor(fields) {
            this.headers = new GetSignTemplateByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSignTemplatesHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSignTemplateByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SignTemplatesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getSignTemplates() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetSignTemplatesHeaders({}), cancellationToken) {
                const headers = new GetSignTemplatesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_templates'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSignTemplates(response.data);
            });
        }
        getSignTemplateById(templateId_1) {
            return __awaiter(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new GetSignTemplateByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_templates/', toString(templateId)), {
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeSignTemplate(response.data);
            });
        }
    }

    function deserializeIntegrationMappingBaseIntegrationTypeField(val) {
        if (val == 'slack') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingBaseIntegrationTypeField",
        });
    }

    function serializeIntegrationMappingPartnerItemSlackTypeField(val) {
        return val;
    }
    function deserializeIntegrationMappingPartnerItemSlackTypeField(val) {
        if (val == 'channel') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingPartnerItemSlackTypeField",
        });
    }
    function serializeIntegrationMappingPartnerItemSlack(val) {
        return {
            ['type']: serializeIntegrationMappingPartnerItemSlackTypeField(val.type),
            ['id']: val.id,
            ['slack_workspace_id']: val.slackWorkspaceId == void 0 ? void 0 : val.slackWorkspaceId,
            ['slack_org_id']: val.slackOrgId == void 0 ? void 0 : val.slackOrgId,
        };
    }
    function deserializeIntegrationMappingPartnerItemSlack(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingPartnerItemSlack"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "IntegrationMappingPartnerItemSlack" to be defined',
            });
        }
        const type = deserializeIntegrationMappingPartnerItemSlackTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "IntegrationMappingPartnerItemSlack" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "IntegrationMappingPartnerItemSlack"',
            });
        }
        const id = val.id;
        if (!(val.slack_workspace_id == void 0) &&
            !sdIsString(val.slack_workspace_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "slack_workspace_id" of type "IntegrationMappingPartnerItemSlack"',
            });
        }
        const slackWorkspaceId = val.slack_workspace_id == void 0 ? void 0 : val.slack_workspace_id;
        if (!(val.slack_org_id == void 0) && !sdIsString(val.slack_org_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "slack_org_id" of type "IntegrationMappingPartnerItemSlack"',
            });
        }
        const slackOrgId = val.slack_org_id == void 0 ? void 0 : val.slack_org_id;
        return {
            type: type,
            id: id,
            slackWorkspaceId: slackWorkspaceId,
            slackOrgId: slackOrgId,
        };
    }

    function serializeIntegrationMappingSlackOptions(val) {
        return {
            ['is_access_management_disabled']: val.isAccessManagementDisabled == void 0
                ? void 0
                : val.isAccessManagementDisabled,
        };
    }
    function deserializeIntegrationMappingSlackOptions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingSlackOptions"',
            });
        }
        if (!(val.is_access_management_disabled == void 0) &&
            !sdIsBoolean(val.is_access_management_disabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_access_management_disabled" of type "IntegrationMappingSlackOptions"',
            });
        }
        const isAccessManagementDisabled = val.is_access_management_disabled == void 0
            ? void 0
            : val.is_access_management_disabled;
        return {
            isAccessManagementDisabled: isAccessManagementDisabled,
        };
    }

    function deserializeUserIntegrationMappings(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserIntegrationMappings"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserIntegrationMappings"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserIntegrationMappings"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserIntegrationMappings" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserIntegrationMappings"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserIntegrationMappings" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function deserializeIntegrationMappingTypeField(val) {
        if (val == 'integration_mapping') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingTypeField",
        });
    }
    function deserializeIntegrationMapping(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMapping"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "IntegrationMapping" to be defined',
            });
        }
        const type = deserializeIntegrationMappingTypeField(val.type);
        if (val.partner_item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "partner_item" of type "IntegrationMapping" to be defined',
            });
        }
        const partnerItem = deserializeIntegrationMappingPartnerItemSlack(val.partner_item);
        if (val.box_item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "box_item" of type "IntegrationMapping" to be defined',
            });
        }
        const boxItem = deserializeFolderMini(val.box_item);
        if (!(val.is_manually_created == void 0) &&
            !sdIsBoolean(val.is_manually_created)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_manually_created" of type "IntegrationMapping"',
            });
        }
        const isManuallyCreated = val.is_manually_created == void 0 ? void 0 : val.is_manually_created;
        const options = val.options == void 0
            ? void 0
            : deserializeIntegrationMappingSlackOptions(val.options);
        const createdBy = val.created_by == void 0
            ? void 0
            : deserializeUserIntegrationMappings(val.created_by);
        const modifiedBy = val.modified_by == void 0
            ? void 0
            : deserializeUserIntegrationMappings(val.modified_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "IntegrationMapping"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "IntegrationMapping"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "IntegrationMapping"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const integrationType = val.integration_type == void 0
            ? void 0
            : deserializeIntegrationMappingBaseIntegrationTypeField(val.integration_type);
        return {
            type: type,
            partnerItem: partnerItem,
            boxItem: boxItem,
            isManuallyCreated: isManuallyCreated,
            options: options,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            id: id,
            integrationType: integrationType,
        };
    }

    function deserializeIntegrationMappings(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappings"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "IntegrationMappings"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "IntegrationMappings"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "IntegrationMappings"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeIntegrationMapping(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    function serializeIntegrationMappingBoxItemSlackTypeField(val) {
        return val;
    }
    function serializeIntegrationMappingBoxItemSlack(val) {
        return {
            ['type']: serializeIntegrationMappingBoxItemSlackTypeField(val.type),
            ['id']: val.id,
        };
    }

    function serializeIntegrationMappingSlackCreateRequest(val) {
        return {
            ['partner_item']: serializeIntegrationMappingPartnerItemSlack(val.partnerItem),
            ['box_item']: serializeIntegrationMappingBoxItemSlack(val.boxItem),
            ['options']: val.options == void 0
                ? void 0
                : serializeIntegrationMappingSlackOptions(val.options),
        };
    }

    class CreateSlackIntegrationMappingOptionals {
        constructor(fields) {
            this.headers = new CreateSlackIntegrationMappingHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSlackIntegrationMappingByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateSlackIntegrationMappingByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteSlackIntegrationMappingByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteSlackIntegrationMappingByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSlackIntegrationMappingHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateSlackIntegrationMappingHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSlackIntegrationMappingByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteSlackIntegrationMappingByIdHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class IntegrationMappingsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        getSlackIntegrationMapping() {
            return __awaiter(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetSlackIntegrationMappingHeaders({}), cancellationToken) {
                const headers = new GetSlackIntegrationMappingHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['partner_item_type']: toString(queryParams.partnerItemType),
                    ['partner_item_id']: toString(queryParams.partnerItemId),
                    ['box_item_id']: toString(queryParams.boxItemId),
                    ['box_item_type']: toString(queryParams.boxItemType),
                    ['is_manually_created']: toString(queryParams.isManuallyCreated),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack'), {
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeIntegrationMappings(response.data);
            });
        }
        createSlackIntegrationMapping(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateSlackIntegrationMappingOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeIntegrationMappingSlackCreateRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeIntegrationMapping(response.data);
            });
        }
        updateSlackIntegrationMappingById(integrationMappingId_1) {
            return __awaiter(this, arguments, void 0, function* (integrationMappingId, optionalsInput = {}) {
                const optionals = new UpdateSlackIntegrationMappingByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack/', toString(integrationMappingId)), {
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateSlackIntegrationMappingByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeIntegrationMapping(response.data);
            });
        }
        deleteSlackIntegrationMappingById(integrationMappingId_1) {
            return __awaiter(this, arguments, void 0, function* (integrationMappingId, optionalsInput = {}) {
                const optionals = new DeleteSlackIntegrationMappingByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack/', toString(integrationMappingId)), {
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: void 0,
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeUpdateSlackIntegrationMappingByIdRequestBody(val) {
        return {
            ['box_item']: val.boxItem == void 0
                ? void 0
                : serializeIntegrationMappingBoxItemSlack(val.boxItem),
            ['options']: val.options == void 0
                ? void 0
                : serializeIntegrationMappingSlackOptions(val.options),
        };
    }

    function deserializeAiResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiResponse"' });
        }
        if (val.answer == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "answer" of type "AiResponse" to be defined',
            });
        }
        if (!sdIsString(val.answer)) {
            throw new BoxSdkError({
                message: 'Expecting string for "answer" of type "AiResponse"',
            });
        }
        const answer = val.answer;
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "AiResponse" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "AiResponse"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (!(val.completion_reason == void 0) &&
            !sdIsString(val.completion_reason)) {
            throw new BoxSdkError({
                message: 'Expecting string for "completion_reason" of type "AiResponse"',
            });
        }
        const completionReason = val.completion_reason == void 0 ? void 0 : val.completion_reason;
        return {
            answer: answer,
            createdAt: createdAt,
            completionReason: completionReason,
        };
    }

    function serializeAiAskModeField(val) {
        return val;
    }
    function serializeAiAskItemsTypeField(val) {
        return val;
    }
    function serializeAiAskItemsField(val) {
        return {
            ['id']: val.id,
            ['type']: serializeAiAskItemsTypeField(val.type),
            ['content']: val.content == void 0 ? void 0 : val.content,
        };
    }
    function serializeAiAsk(val) {
        return {
            ['mode']: serializeAiAskModeField(val.mode),
            ['prompt']: val.prompt,
            ['items']: val.items.map(function (item) {
                return serializeAiAskItemsField(item);
            }),
        };
    }

    function serializeAiTextGenItemsTypeField(val) {
        return val;
    }
    function serializeAiTextGenItemsField(val) {
        return {
            ['id']: val.id == void 0 ? void 0 : val.id,
            ['type']: val.type == void 0 ? void 0 : serializeAiTextGenItemsTypeField(val.type),
            ['content']: val.content == void 0 ? void 0 : val.content,
        };
    }
    function serializeAiTextGenDialogueHistoryField(val) {
        return {
            ['prompt']: val.prompt == void 0 ? void 0 : val.prompt,
            ['answer']: val.answer == void 0 ? void 0 : val.answer,
            ['created_at']: val.createdAt == void 0 ? void 0 : dateTimeToString(val.createdAt),
        };
    }
    function serializeAiTextGen(val) {
        return {
            ['prompt']: val.prompt,
            ['items']: val.items.map(function (item) {
                return serializeAiTextGenItemsField(item);
            }),
            ['dialogue_history']: val.dialogueHistory == void 0
                ? void 0
                : val.dialogueHistory.map(function (item) {
                    return serializeAiTextGenDialogueHistoryField(item);
                }),
        };
    }

    class CreateAiAskOptionals {
        constructor(fields) {
            this.headers = new CreateAiAskHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateAiTextGenOptionals {
        constructor(fields) {
            this.headers = new CreateAiTextGenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateAiAskHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateAiTextGenHeaders {
        constructor(fields) {
            this.extraHeaders = {};
            if (fields.extraHeaders) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AiManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
        }
        createAiAsk(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateAiAskOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai/ask'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAiAsk(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeAiResponse(response.data);
            });
        }
        createAiTextGen(requestBody_1) {
            return __awaiter(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateAiTextGenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = (yield fetch(''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai/text_gen'), {
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAiTextGen(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return deserializeAiResponse(response.data);
            });
        }
    }

    class BoxClient {
        constructor(fields) {
            this.networkSession = new NetworkSession({
                baseUrls: new BaseUrls({}),
            });
            if (fields.auth) {
                this.auth = fields.auth;
            }
            if (fields.networkSession) {
                this.networkSession = fields.networkSession;
            }
            this.authorization = new AuthorizationManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.files = new FilesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedFiles = new TrashedFilesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.downloads = new DownloadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.uploads = new UploadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.chunkedUploads = new ChunkedUploadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.listCollaborations = new ListCollaborationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.comments = new CommentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.tasks = new TasksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileVersions = new FileVersionsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileMetadata = new FileMetadataManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileClassifications = new FileClassificationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.skills = new SkillsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileWatermarks = new FileWatermarksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileRequests = new FileRequestsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folders = new FoldersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedFolders = new TrashedFoldersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderMetadata = new FolderMetadataManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderClassifications = new FolderClassificationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedItems = new TrashedItemsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderWatermarks = new FolderWatermarksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderLocks = new FolderLocksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.metadataTemplates = new MetadataTemplatesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.classifications = new ClassificationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.metadataCascadePolicies = new MetadataCascadePoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.search = new SearchManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.userCollaborations = new UserCollaborationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.taskAssignments = new TaskAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sharedLinksFiles = new SharedLinksFilesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sharedLinksFolders = new SharedLinksFoldersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.webLinks = new WebLinksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedWebLinks = new TrashedWebLinksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sharedLinksWebLinks = new SharedLinksWebLinksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.users = new UsersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sessionTermination = new SessionTerminationManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.avatars = new AvatarsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.transfer = new TransferManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.emailAliases = new EmailAliasesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.memberships = new MembershipsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.invites = new InvitesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.groups = new GroupsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.webhooks = new WebhooksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.events = new EventsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.collections = new CollectionsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.recentItems = new RecentItemsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.retentionPolicies = new RetentionPoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.retentionPolicyAssignments = new RetentionPolicyAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.legalHoldPolicies = new LegalHoldPoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.legalHoldPolicyAssignments = new LegalHoldPolicyAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileVersionRetentions = new FileVersionRetentionsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileVersionLegalHolds = new FileVersionLegalHoldsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.shieldInformationBarriers = new ShieldInformationBarriersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.shieldInformationBarrierReports =
                new ShieldInformationBarrierReportsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.shieldInformationBarrierSegments =
                new ShieldInformationBarrierSegmentsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.shieldInformationBarrierSegmentMembers =
                new ShieldInformationBarrierSegmentMembersManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.shieldInformationBarrierSegmentRestrictions =
                new ShieldInformationBarrierSegmentRestrictionsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.devicePinners = new DevicePinnersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.termsOfServices = new TermsOfServicesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.termsOfServiceUserStatuses = new TermsOfServiceUserStatusesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.collaborationAllowlistEntries =
                new CollaborationAllowlistEntriesManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.collaborationAllowlistExemptTargets =
                new CollaborationAllowlistExemptTargetsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.storagePolicies = new StoragePoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.storagePolicyAssignments = new StoragePolicyAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.zipDownloads = new ZipDownloadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.signRequests = new SignRequestsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.workflows = new WorkflowsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.signTemplates = new SignTemplatesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.integrationMappings = new IntegrationMappingsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.ai = new AiManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
        }
        withAsUserHeader(userId) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withAdditionalHeaders({
                    ['As-User']: userId,
                }),
            });
        }
        withSuppressedNotifications() {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withAdditionalHeaders({
                    ['Box-Notifications']: 'off',
                }),
            });
        }
        withExtraHeaders(extraHeaders = {}) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withAdditionalHeaders(extraHeaders),
            });
        }
        withCustomBaseUrls(baseUrlsInput) {
            const baseUrls = new BaseUrls({
                baseUrl: baseUrlsInput.baseUrl,
                uploadUrl: baseUrlsInput.uploadUrl,
                oauth2Url: baseUrlsInput.oauth2Url,
            });
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withCustomBaseUrls(baseUrls),
            });
        }
        withCustomAgentOptions(agentOptions) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withCustomAgentOptions(agentOptions),
            });
        }
        withInterceptors(interceptors) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withInterceptors(interceptors),
            });
        }
    }

    exports.BoxCcgAuth = BoxCcgAuth;
    exports.BoxClient = BoxClient;
    exports.BoxDeveloperTokenAuth = BoxDeveloperTokenAuth;
    exports.BoxJwtAuth = BoxJwtAuth;
    exports.BoxOAuth = BoxOAuth;
    exports.CcgConfig = CcgConfig;
    exports.JwtConfig = JwtConfig;
    exports.OAuthConfig = OAuthConfig;

}));
//# sourceMappingURL=bundle.js.map
